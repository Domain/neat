module main;

import backend.base;
import backend.llvm;
import backend.proxy;
import cx.array;
import cx.base;
import cx.expr;
import cx.parser_base;
import cx.stuff;
import cx.types;
import helpers;

extern(C) int getpid();

string removeExtension(string s) {
    string shortened = s;
    while (shortened.length > 0 && shortened[shortened.length - 1 .. shortened.length] != ".")
        shortened = shortened[0 .. shortened.length - 1];
    if (shortened.length) return shortened[0 .. shortened.length - 1]; else return s;
}

string removeSlashes(string s) {
    string result;
    for (int i = 0; i < s.length; i += 1) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    string[] deps;
}

string slice(string* text, string marker)
{
    int pos = find(*text, marker);
    if (pos == -1) {
        string result = *text;
        *text = "";
        return result;
    }
    string result = (*text)[0 .. pos];
    *text = (*text)[pos + marker.length .. (*text).length];
    return result;
}

ASTPackage parsePackage(string arg)
{
    string name = slice(&arg, ":");
    assert(name.length > 0);
    string path = slice(&arg, ":");
    assert(path.length > 0);
    string[] deps;
    while (arg.length)
    {
        deps ~= slice(&arg, ",");
    }
    return ASTPackage(name, path, deps);
}

Package[] resolvePackages(ASTPackage[] astPackages)
{
    Package[] result;
    for (int i = 0; i < astPackages.length; i += 1) {
        result ~= new Package(astPackages[i].name, astPackages[i].path);
    }
    for (int i = 0; i < astPackages.length; i += 1) {
        auto astPackage = astPackages[i];
        for (int j = 0; j < astPackage.deps.length; j += 1) {
            Package dep;
            for (int k = 0; k < result.length; k += 1) {
                if (result[k].name == astPackage.deps[j])
                {
                    assert(!dep);
                    dep = result[k];
                    // TODO break;
                }
            }
            if (!dep) {
                print("Missing package dependency: " ~ astPackage.deps[j]);
                assert(false);
            }
            result[i].addDependency(dep);
        }
    }
    return result;
}

void main(string[] args)
{
    // TODO std.string
    // TODO move to test
    string a = "b:c";
    assert(slice(&a, ":") == "b");
    assert(a == "c");

    print("# stage2");
    string[] includes;
    string output;
    string[] nextArgs;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool optimize;
    {
        string[] remArgs;
        for (size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                astPackages ~= parsePackage(arg[2 .. arg.length]);
            } else if (flag == "-I") {
                includes ~= arg[2 .. arg.length];
            } else if (flag == "-l") {
                linkerArgs ~= arg;
            } else if (flag == "-L") {
                linkerArgs ~= arg[2 .. arg.length];
            } else if (arg == "--") {
                nextArgs = args[i + 1 .. args.length];
                i = args.length; // break
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                optimize = true;
            } else {
                remArgs = remArgs ~ arg;
            }
        }
        args = remArgs;
    }
    Package[] packages = resolvePackages(astPackages);

    if (args.length != 1)
    {
        print("Usage: cx [-Iincludepath]* [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!output.length) output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");

    auto builtins = new Module("", null, new MacroState, null);
    // auto backend = new ProxyBackend();
    auto backend = new LLVMBackend();
    // auto platform = new ProxyPlatform();
    auto platform = new DefaultPlatform();
    auto backendModule = backend.createModule(platform);

    builtins.add("string", new Array(new Character));
    builtins.add("bool", new Integer);
    builtins.add("true", new IntLiteral(1));
    builtins.add("false", new IntLiteral(0));
    builtins.add("null", new NullExpr(new Pointer(new Void)));
    builtins.add("size_t", nativeWordType(platform));

    auto defaultImports = new Module[](0) ~ builtins;
    auto cache = new ModuleCache;
    auto modParseConfig = new ModuleParserConfig(platform, includes, packages, defaultImports, cache);
    auto toplevel = parseModule(args[0], null, false, modParseConfig, Loc(null, ""));
    auto generator = new Generator(platform, backendModule);

    toplevel.emit(generator);

    // backendModule.callMain(nextArgs);
    auto llFile = ".obj/" ~ removeSlashes(output) ~ ".ll";
    cxruntime_file_write(llFile, backendModule.output.text());
    // int pid = getpid();
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = " -rdynamic";
    if (optimize) flags ~= " -Ofast";
    string linkerFlags = " -ldl";
    for (int i = 0; i < linkerArgs.length; i += 1) linkerFlags ~= " " ~ linkerArgs[i];
    string cmd = "clang" ~ flags ~ " " ~ llFile ~ " src/runtime.c -o " ~ output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}
