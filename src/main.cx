module main;

import backend.base;
import backend.c;
import backend.llvm;
import backend.proxy;
import cx.array;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser_base;
import cx.statements;
import cx.stuff;
import cx.types;
import helpers;

extern(C) int getpid();

string removeExtension(string s) {
    string shortened = s;
    while (shortened.length > 0 && shortened[shortened.length - 1 .. shortened.length] != ".")
        shortened = shortened[0 .. shortened.length - 1];
    if (shortened.length) return shortened[0 .. shortened.length - 1]; else return s;
}

string removeSlashes(string s) {
    string result;
    for (int i = 0; i < s.length; i += 1) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

string emitModule(CompilerBase compiler, Backend backend, Platform platform, Module module_, string baseCmd)
{
    auto hash = new Hash;

    hash.adds(baseCmd);
    // TODO add compiler checksum (generation number?)

    auto symbols = module_.compile(compiler, platform);
    for (int i = 0; i < symbols.length; i += 1)
        symbols[i].hash(hash);

    string objFile = ".obj/" ~ hash.text() ~ ".o";

    if (cxruntime_file_exists(objFile))
        return objFile;

    auto backendModule = backend.createModule(platform);
    auto generator = new Generator(platform, backendModule);
    auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    auto backendModuleC = backendModule.instanceOf(CBackendModule);
    module_.emit(generator, symbols);
    backendModule.done();
    string srcFile;
    if (backendModuleLLVM) {
        srcFile = ".obj/" ~ removeSlashes(module_.mangle()) ~ ".ll";
        auto llText = backendModuleLLVM.output.text();
        cxruntime_file_write(srcFile, llText);
        backendModuleLLVM.output.free();
    } else {
        assert(!!backendModuleC);
        srcFile = ".obj/" ~ removeSlashes(module_.mangle()) ~ ".c";
        auto csrc = backendModuleC.output.text();
        cxruntime_file_write(srcFile, csrc);
        backendModuleC.output.free();
    }
    string cmd = baseCmd ~ " " ~ srcFile ~ " -c -o " ~ objFile;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
    return objFile;
}

class ParserHelperImpl : ParserHelper
{
    CompilerBase compiler;

    Backend backend;

    bool x86_32;

    this(this.compiler, this.backend, this.x86_32) { }

    // TODO why do we need 'config'?
    override void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        print("# stageM");
        BackendType macroWordType;
        if (x86_32) macroWordType = new BackendIntType;
        else macroWordType = new BackendLongType;
        auto platform = new Platform(macroWordType);

        // throwaway compilation (TODO cache?)
        Module module_ = compileModule(astModule, this, config, compiler, platform, true);
        Module[] allModules = module_.allModules();
        BackendModule[] backendModules;

        string baseCmd;
        if (backend.instanceOf(LLVMBackend)) baseCmd = "clang -Wno-unused-command-line-argument -fpic";
        else if (backend.instanceOf(CBackend)) baseCmd = "gcc -fpic";
        else assert(false);
        if (x86_32) baseCmd ~= " -m32";

        string objFiles;
        for (int i = 0; i < allModules.length; i += 1) {
            string objFile = emitModule(compiler, backend, platform, allModules[i], baseCmd);
            objFiles ~= " " ~ objFile;
        }

        auto fun = module_.lookup(function_, null).instanceOf(Function);
        string name = fun.mangle();
        string soname;
        string cmd;
        if (backend.instanceOf(LLVMBackend)) {
            soname = ".obj/macro_" ~ name ~ ".so";
            cmd = baseCmd ~ " -shared" ~ objFiles ~ " -o " ~ soname;
        }
        else if (backend.instanceOf(CBackend)) {
            soname = ".obj/macro_" ~ name ~ ".so";
            string flags = " -shared -g src/runtime.c";
            if (platform.nativeWordType.instanceOf(BackendIntType)) flags ~= " -m32";
            cmd = baseCmd ~ flags ~ objFiles ~ " -o " ~ soname;
        }
        else assert(false);

        print("$ " ~ cmd);
        cxruntime_system(cmd);
        cxruntime_dlcall(soname, name, macroState);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    string[] deps;
}

string slice(string* text, string marker)
{
    int pos = find(*text, marker);
    if (pos == -1) {
        string result = *text;
        *text = "";
        return result;
    }
    string result = (*text)[0 .. pos];
    *text = (*text)[pos + marker.length .. (*text).length];
    return result;
}

ASTPackage parsePackage(string arg)
{
    string name = slice(&arg, ":");
    assert(name.length > 0);
    string path = slice(&arg, ":");
    assert(path.length > 0);
    string[] deps;
    while (arg.length)
    {
        deps ~= slice(&arg, ",");
    }
    return ASTPackage(name, path, deps);
}

Package[] resolvePackages(ASTPackage[] astPackages)
{
    Package[] result;
    for (int i = 0; i < astPackages.length; i += 1) {
        result ~= new Package(astPackages[i].name, astPackages[i].path);
    }
    for (int i = 0; i < astPackages.length; i += 1) {
        auto astPackage = astPackages[i];
        for (int j = 0; j < astPackage.deps.length; j += 1) {
            Package dep;
            for (int k = 0; k < result.length; k += 1) {
                if (result[k].name == astPackage.deps[j]) {
                    if (dep) print("Dependency '" ~ astPackage.deps[j] ~ "' of '" ~ astPackage.name ~ "' exists twice!");
                    assert(!dep);
                    dep = result[k];
                    break;
                }
            }
            if (!dep) {
                print("Missing package dependency: " ~ astPackage.deps[j]);
                assert(false);
            }
            result[i].addDependency(dep);
        }
    }
    return result;
}

class FixedTypeAlias : ASTType
{
    Type type;

    this(this.type) { }

    override Type compile(Context context) { return this.type; }
}

class FixedExpressionAlias : ASTSymbol
{
    Symbol symbol;

    this(this.symbol) { }

    override Symbol compile(Context context) { return this.symbol; }
}

class ASTSizeT : ASTType
{
    this() { }

    override Type compile(Context context) {
        return nativeWordType(context.platform);
    }
}

// TODO fqn calls, .name calls
Expression implicitConvertToProxy(Expression from, Type to)
{
    return implicitConvertTo(from, to);
}

// TODO fqn calls, .name calls
ASTSymbol parseExpressionProxy(Parser parser, LexicalContext lexicalContext)
{
    return parseExpression(parser, lexicalContext);
}

// TODO fqn calls, .name calls
ASTSymbol parseExpressionLeafProxy(Parser parser, LexicalContext lexicalContext)
{
    return parseExpressionLeaf(parser, lexicalContext);
}

// TODO fqn calls, .name calls
ASTStatement parseStatementProxy(Parser parser, LexicalContext lexicalContext)
{
    return parseStatement(parser, lexicalContext);
}

Expression truthyProxy(Expression value, Loc loc)
{
    return truthy(value, loc);
}

class CompilerImpl : CompilerBase
{
    this() { }

    // parser
    override ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return parseExpressionProxy(parser, lexicalContext);
    }

    override ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return parseExpressionLeafProxy(parser, lexicalContext);
    }

    override ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return parseStatementProxy(parser, lexicalContext);
    }

    // expressions and statements
    override Expression implicitConvertTo(Expression from, Type to)
    {
        return implicitConvertToProxy(from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Expression call(FunctionDeclaration fun, Expression[] args, Loc loc)
    {
        return new Call(fun, args, loc);
    }

    override Expression binaryOp(string op, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return new ArrayCat(left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression truthy(Expression value, Loc loc)
    {
        return truthyProxy(value, loc);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override VariableDeclarationBase variableDeclaration(Namespace parent, string name, Type type)
    {
        return new VariableDeclaration(parent, name, type);
    }
}

void main(string[] args)
{
    print("# stage2");
    string output;
    string[] nextArgs;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool dontLink;
    bool optimize;
    bool x86_32; bool macro_x86_32;
    CompilerBase compilerImpl = new CompilerImpl();
    // auto backend = new ProxyBackend();
    Backend backend = new LLVMBackend();
    Backend macroBackend = backend;
    {
        string[] remArgs;
        for (size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                astPackages ~= parsePackage(arg[2 .. arg.length]);
            } else if (flag == "-l") {
                linkerArgs ~= arg;
            } else if (flag == "-L") {
                linkerArgs ~= arg[2 .. arg.length];
            } else if (arg == "--") {
                nextArgs = args[i + 1 .. args.length];
                break;
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                optimize = true;
            } else if (arg == "-c") {
                dontLink = true;
            } else if (arg == "-backend=c") {
                backend = new CBackend;
            } else if (arg == "-macro-backend=c") {
                macroBackend = new CBackend;
            } else if (arg == "-m32") {
                x86_32 = true;
            } else if (arg == "-macro-m32") {
                macro_x86_32 = true;
            } else {
                remArgs = remArgs ~ arg;
            }
        }
        args = remArgs;
    }
    Package[] packages = resolvePackages(astPackages);

    if (args.length != 1)
    {
        print("Usage: cx [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!output.length) output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");

    auto builtins = new ASTModule("", new Package("builtins", ""), new MacroState, null);
    BackendType nativeWordType;
    if (x86_32) nativeWordType = new BackendIntType;
    else nativeWordType = new BackendLongType;
    auto platform = new Platform(nativeWordType);

    builtins.addTypeAlias("string", new FixedTypeAlias(new Array(new Character)));
    builtins.addTypeAlias("bool", new FixedTypeAlias(new Integer));
    builtins.addTypeAlias("size_t", new ASTSizeT);
    builtins.addExprAlias("true", new FixedExpressionAlias(new IntLiteral(1)));
    builtins.addExprAlias("false", new FixedExpressionAlias(new IntLiteral(0)));
    builtins.addExprAlias("null", new FixedExpressionAlias(new NullExpr(new Pointer(new Void))));

    auto defaultImports = new ASTModule[](0) ~ builtins;
    auto astCache = new ASTModuleCache;
    auto cache = new ModuleCache;
    auto modParseConfig = new ModuleParserConfig(packages, defaultImports, astCache, cache);
    auto helper = new ParserHelperImpl(
        compilerImpl, macroBackend,
        macro_x86_32);
    auto astToplevel = getModule(compilerImpl, args[0], null, false, helper, modParseConfig, Loc(null, ""));
    auto toplevel = compileModule(astToplevel, helper, modParseConfig, compilerImpl, platform, true);

    string baseFlags;
    if (optimize) baseFlags ~= " -Ofast";
    if (x86_32) baseFlags ~= " -m32";

    string compiler = "clang -Wno-unused-command-line-argument";
    if (backend.instanceOf(CBackend)) compiler = "gcc";

    auto modules = toplevel.allModules();

    string fileArgs;
    for (int i = 0; i < modules.length; i += 1) {
        string objFile = emitModule(compilerImpl, backend, platform, modules[i], compiler ~ baseFlags);
        fileArgs ~= " " ~ objFile;
    }

    if (dontLink) return;

    // int pid = getpid();
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = baseFlags ~ " -rdynamic";
    string linkerFlags = " -ldl";
    for (int i = 0; i < linkerArgs.length; i += 1) linkerFlags ~= " " ~ linkerArgs[i];
    string cmd = compiler ~ flags ~ fileArgs ~ " src/runtime.c -o " ~ output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}
