module main;

macro import cx.macros.listcomprehension;

import backend.base;
import backend.c;
import backend.llvm;
import cx.array;
import cx.base;
import cx.class_;
import cx.expr;
import cx.function_;
import cx.hash;
import cx.linenr;
import cx.parser_base;
import cx.statements;
import cx.struct_;
import cx.stuff;
import cx.types;
import helpers;
import std.file : realpath;

extern(C) int getpid();
extern(C) void cxruntime_system(string command);
extern(C) void cxruntime_dlcall(string soname, string name, void* arg);
extern(C) bool cxruntime_waitpid(int pid);
extern(C) int cxruntime_execbg(string command, string[] arguments);
extern(C) size_t poly_hash_whole_string(string s);
extern(C) long compiler_hash_add();
extern(C) long compiler_hash_mult();

string removeExtension(string s) {
    mut string shortened = s;
    while (shortened.length > 0 && shortened[$ - 1 .. $] != ".")
        shortened = shortened[0 .. $ - 1];
    if (shortened.length) return shortened[0 .. $ - 1]; else return s;
}

string removeSlashes(string s) {
    mut string result;
    for (int i <- 0 .. s.length) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

// pseudo brute force zip compression
// Hallo Wallo
// "Hallo Wallo" in ""? No.
// "Hallo Wall" in ""? No.
// ... "H" in ""? No.
// "allo Wallo" in "H"? No.
// ...
// "allo" in "Hallo W"? Yes.
// Hallo WB1N4
string compress(string symbol) {
    mut string result;
    for (mut size_t i = 0; i < symbol.length; i += 1) {
        mut bool found;
        for (mut size_t k = symbol.length; k > i; k -= 1) {
            if (k - i < 4) continue; // pointless - replacement will always be larger
            string sample = symbol[i .. k];
            int pos = find(symbol[0 .. i], sample);
            if (pos != -1) {
                string replace = "B" ~ ltoa(pos) ~ "N" ~ ltoa(k - i);
                if (replace.length < sample.length)
                {
                    result ~= replace;
                    i += sample.length - 1;
                    found = true;
                    break;
                }
            }
        }
        if (!found) result ~= symbol[i];
    }
    return result;
}

string replace(string str, string match, string replace) {
    mut string result;
    mut size_t i = 0;
    while (i <= str.length - match.length) {
        if (str[i .. i + match.length] == match) {
            result ~= replace;
            i += match.length;
        } else {
            result ~= str[i];
            i += 1;
        }
    }
    result ~= str[i .. $];
    return result;
}

struct BackgroundCompilation
{
    Hash hash;
    string objFile;
    int pid;
}

// how many levels of cache are we even on rn
class ObjectCache
{
    (string earlyHash, Hash resultHash, string objFile, int pid)[] entries;

    int[] donePids;

    this() { }

    bool has(string earlyHash) {
        return [any a.earlyHash == earlyHash for a in entries];
    }

    void add(string earlyHash, Hash resultHash, string objFile, int pid) {
        this.entries ~= (earlyHash, resultHash, objFile, pid);
    }

    BackgroundCompilation get(string earlyHash) {
        typeof(entries[0]) nothing;
        auto entry = [first a for a in entries where a.earlyHash == earlyHash else nothing];
        return BackgroundCompilation(entry.resultHash, entry.objFile, entry.pid);
    }

    void waitpid(int pid) {
        if (pid == 0) return;
        if ([any a == pid for a in donePids]) return;
        if (!cxruntime_waitpid(pid))
            assert(false);
        donePids ~= pid;
    }
}

BackgroundCompilation emitModule(CompilerBase compiler, ObjectCache cache, Backend backend, Platform platform,
    Module module_, bool opt, bool m32, bool caching, bool forMacro)
{
    auto backendModule = backend.createModule(platform, module_.loc.toBackendLoc, forMacro);
    auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    auto backendModuleC = backendModule.instanceOf(CBackendModule);
    auto hash = new Hash;

    hash.apply(compiler_hash_add, compiler_hash_mult);

    int build(string src, string obj) {
        import std.string : join;

        mut string exec;
        mut string[] args;
        if (backendModuleLLVM) {
            if (opt) { exec = "sh"; args = [".obj/llvmBuildOpt.sh", src, obj]; }
            else { exec = "sh"; args = [".obj/llvmBuild.sh", src, obj]; }
            assert(!m32);
        } else {
            if (opt) { exec = "gcc"; args = ["-c", "-fpic", "-O3", src, "-o", obj]; }
            else { exec = "gcc"; args = ["-c", "-fpic", src, "-o", obj]; }
            if (m32) args ~= "-m32";
        }
        string cmd = exec ~ " " ~ args.join(" ");
        int pid = cxruntime_execbg(exec, args);
        print("$ " ~ cmd ~ " [&" ~ itoa(pid) ~ "]");
        return pid;
    }

    // TODO add compiler checksum (generation number?)
    if (backendModuleLLVM) hash.adds("LLVM");
    else hash.adds("gcc");
    if (m32) hash.adds("m32");
    if (opt) hash.adds("opt");
    // Macros and binaries must not share objects!
    // Macros have special magic to avoid dlopen issues.
    if (forMacro) hash.adds("macro");

    string moduleMangle = module_.mangle;
    hash.adds(moduleMangle);

    string earlyHash = hash.text;
    if (cache.has(earlyHash)) {
        return cache.get(earlyHash);
    }

    auto symbols = module_.compile(compiler, platform);
    [symbol.hash(hash) for symbol in symbols];

    mut string objFile = ".obj/" ~ hash.text ~ ".o";
    if (backendModuleLLVM && opt) {
        objFile = ".obj/" ~ hash.text ~ ".bc";
    }

    if (caching && exists(objFile)) {
        // preexisting object
        cache.add(earlyHash, hash, objFile, 0);
        return BackgroundCompilation(hash, objFile, 0);
    }

    auto generator = new Generator(platform, backendModule);
    module_.emit(generator, symbols);
    backendModule.done;

    mut int pid;
    if (backendModuleLLVM) {
        string srcFile = ".obj/" ~ compress(removeSlashes(moduleMangle)) ~ ".ll";
        {
            auto llText = backendModuleLLVM.output.text;
            write(srcFile, llText);
        }
        pid = build(srcFile, objFile);
    } else {
        assert(!!backendModuleC);
        string srcFile = ".obj/" ~ compress(removeSlashes(moduleMangle)) ~ ".c";
        {
            auto csrc = backendModuleC.output.text;
            write(srcFile, csrc);
        }
        pid = build(srcFile, objFile);
    }
    cache.add(earlyHash, hash, objFile, pid);
    return BackgroundCompilation(hash, objFile, pid);
}

class ParserHelperImpl : ParserHelper
{
    CompilerBase compiler;

    ObjectCache cache;

    Backend backend;

    bool x86_32;

    bool caching;

    PlatformFlags platformFlags;

    this(this.compiler, this.cache, this.backend, this.x86_32, this.caching, this.platformFlags) { }

    // TODO why do we need 'config'?
    override void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        print("# stageM");
        mut BackendType macroWordType;
        if (x86_32) macroWordType = new BackendIntType;
        else macroWordType = new BackendLongType;
        auto platform = new Platform(macroWordType, platformFlags);

        // throwaway compilation (TODO cache?)
        auto context = makeContext(compiler, platform, null, astModule.macroState);
        Module module_ = compileModule(context, astModule, true);

        mut string baseCmd;
        if (backend.instanceOf(LLVMBackend)) baseCmd = "clang -Wno-unused-command-line-argument -fpic";
        else if (backend.instanceOf(CBackend)) baseCmd = "gcc -fpic";
        else assert(false);
        if (x86_32) baseCmd ~= " -m32";

        auto libHash = new Hash;
        mut string objFiles;
        mut int[] pids;

        auto allModules = new ModuleSet(0);
        void add(Module mod) { allModules.add(mod); }
        module_.walkModules(&add);

        mut auto remainingModules = allModules.array;
        while (remainingModules.length > 0) {
            for (auto remainingModule <- remainingModules) {
                auto compilation = emitModule(
                    compiler, cache, backend, platform, remainingModule, false, x86_32, caching, true);
                objFiles ~= " " ~ compilation.objFile;
                pids ~= compilation.pid;
                with (compilation.hash.state) libHash.apply(add, mult);
            }
            auto remainingSet = new ModuleSet(0);
            // TODO add()
            void add2(Module mod) {
                if (!allModules.has(mod)) {
                    allModules.add(mod);
                    remainingSet.add(mod);
                }
            }
            module_.walkModules(&add2);
            remainingModules = remainingSet.array;
        }

        [cache.waitpid(pid) for pid in pids];

        auto simpleContext = makeContext(compiler, platform, null, null);
        auto fun = module_.lookup(function_, simpleContext, null).instanceOf(Function);
        string name = fun.mangle;
        mut string soname;
        mut string cmd;
        if (backend.instanceOf(LLVMBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text ~ ".so";
            cmd = baseCmd ~ " -shared" ~ objFiles ~ " -o " ~ soname;
        }
        else if (backend.instanceOf(CBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text ~ ".so";
            mut string flags = " -shared -g src/runtime.c";
            if (platform.nativeWordType.instanceOf(BackendIntType)) flags ~= " -m32";
            cmd = baseCmd ~ flags ~ objFiles ~ " -o " ~ soname;
        }
        else assert(false);

        if (!caching || !exists(soname)) {
            print("$ " ~ cmd);
            cxruntime_system(cmd);
        }
        cxruntime_dlcall(soname, name, macroState);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    bool syspkg;
    string[] deps;
}

// better way to do this (reassign?)
(string result, string remainder) slice(string text, string marker)
{
    int pos = find(text, marker);
    if (pos == -1) {
        return (text, "");
    }
    return (text[0 .. pos], text[pos + marker.length .. $]);
}

ASTPackage parsePackage(mut string arg, bool syspkg)
{
    auto pair1 = slice(arg, ":");
    string name = pair1.result; arg = pair1.remainder;
    assert(name.length > 0);
    auto pair2 = slice(arg, ":");
    string path = pair2.result; arg = pair2.remainder;
    assert(path.length > 0);
    mut string[] deps;
    while (arg.length)
    {
        auto pair3 = slice(arg, ",");
        deps ~= pair3.result; arg = pair3.remainder;
    }
    return ASTPackage(name, path, syspkg, deps);
}

string resolvePath(ASTPackage pak, string execPath) {
    if (!pak.syspkg) return realpath(pak.path);
    return realpath(execPath ~ "/" ~ pak.path);
}

Package[] resolvePackages(ASTPackage[] astPackages, string execPath) {
    Package[] result = [new Package(pkg.name, resolvePath(pkg, execPath)) for pkg in astPackages];
    for (int i <- 0 .. astPackages.length) {
        auto astPackage = astPackages[i];
        for (auto dep <- astPackage.deps) {
            mut Package foundDep;
            for (auto resultPak <- result) {
                if (resultPak.name == dep) {
                    if (foundDep) print("Dependency '" ~ dep ~ "' of '" ~ astPackage.name ~ "' exists twice!");
                    assert(!foundDep);
                    foundDep = resultPak;
                    break;
                }
            }
            if (!foundDep) {
                print("Missing package dependency: " ~ dep);
                assert(false);
            }
            result[i].addDependency(foundDep);
        }
    }
    return result;
}

class FixedTypeAlias : ASTSymbol
{
    Type type;

    this(this.type) { }

    override Type compile(Context context) { return this.type; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedTypeAlias'!"); assert(false); }
}

class FixedExpressionAlias : ASTSymbol
{
    Symbol symbol;

    this(this.symbol) { }

    override Symbol compile(Context context) { return this.symbol; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedExpressionAlias'"); assert(false); }
}

// TODO this should be ASTBasicType(?)
class ASTSizeT : ASTSymbol
{
    this() { }

    override Type compile(Context context) {
        return context.nativeWordType;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTSizeT'!"); assert(false); }
}

struct CachedRuntimeFunction
{
    FunctionDeclaration fun;

    Module rtMod;
}

class UmlClassGraph : GlobalStats
{
    (string base, string child)[] inheritance;

    this() { }

    override void observe(Type type) {
        if (auto class_ = type.instanceOf(Class)) {
            if (class_.superClass) {
                auto pair = (class_.superClass.name, class_.name);
                // TODO
                // if (![any a == pair for a in this.inheritance])
                if (![any a[0] == pair[0] && a[1] == pair[1] for a in this.inheritance])
                    this.inheritance ~= pair;
            }
        }
    }

    void writeTo(string filename) {
        mut string diagram = "Digraph G {\n";
        void addl(string s) { diagram ~= "  " ~ s ~ "\n"; }
        for (auto pair <- inheritance) {
            addl(pair.base ~ " -> " ~ pair.child ~ " [dir=back, arrowhead=empty];");
        }
        diagram ~= "}\n";
        write(filename, diagram);
    }
}

class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    (string key, Module mod)[] modules;

    this(this.defaultImports) {
        this.linenr = new LineNumberRegistry;
        this.stats = new UmlClassGraph;
    }

    CachedRuntimeFunction[] cachedRuntimeFunctions;

    Module delegate(ASTModule, bool) compile;

    // parser
    override ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser, lexicalContext);
    }

    override ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser, lexicalContext);
    }

    override ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser, lexicalContext);
    }

    override ASTSymbol parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser, lexicalContext);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, ReLoc reloc)
    {
        return new ASTBinaryOp(op, left, right, Loc(linenr, reloc));
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, ReLoc reloc)
    {
        return new ASTIndexAccess(base, index, Loc(linenr, reloc));
    }

    override ASTSymbol astMember(ASTSymbol base, string member, ReLoc reloc)
    {
        return new ASTMember(base, member, Loc(linenr, reloc));
    }

    override ASTSymbol astReference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astDereference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTDereference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astIntLiteral(int value, ReLoc reloc)
    {
        return new ASTIntLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astLongLiteral(long value, ReLoc reloc)
    {
        return new ASTLongLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astStringLiteral(string text, ReLoc reloc)
    {
        return new ASTStringLiteral(text, Loc(linenr, reloc));
    }

    override ASTSymbol astArrayLiteral(ASTSymbol[] values, ReLoc reloc)
    {
        auto elements = [ASTArrayLiteralElement(value, Loc(linenr, reloc)) for value in values];
        return new ASTArrayLiteral(elements);
    }

    override ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, ReLoc reloc)
    {
        return new ASTArraySlice(array, lower, upper, Loc(linenr, reloc));
    }

    override ASTSymbol astVoidLiteral(ReLoc reloc)
    {
        return new ASTVoidExpression(Loc(linenr, reloc));
    }

    override ASTSymbol astIdentifier(string name, ReLoc reloc)
    {
        return new ASTIdentifier(name, false, Loc(linenr, reloc));
    }

    override ASTSymbol astNegation(ASTSymbol value, ReLoc reloc)
    {
        return new ASTNegation(value, Loc(linenr, reloc));
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTCall(target, [(sym, "") for sym in args], Loc(linenr, reloc));
    }

    override ASTSymbol astNewExpression(ASTSymbol type, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTNewExpression(type, args, Loc(linenr, reloc));
    }

    override ASTSymbol astDestroy(ASTSymbol target, ReLoc reloc)
    {
        return new ASTDestroy(target, Loc(linenr, reloc));
    }

    override ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, ReLoc reloc)
    {
        return new ASTStatementExpression(statements, expr, reloc);
    }

    override ASTSymbol astCast(ASTSymbol target, ASTSymbol value, ReLoc reloc)
    {
        return new ASTCastExpr(target, value, Loc(linenr, reloc));
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, ReLoc reloc)
    {
        return new ASTExprStatement(expr, Loc(linenr, reloc));
    }

    override ASTStatement astScope(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTScopeStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astSequence(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTSequenceStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astIf(ASTSymbol test, ASTStatement then, ASTStatement else_, ReLoc reloc)
    {
        return new ASTIfStatement(test, then, else_, Loc(linenr, reloc));
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, ReLoc reloc)
    {
        return new ASTForLoop(init, test, step, body_, Loc(linenr, reloc));
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, ReLoc reloc)
    {
        return new ASTAssignStatement(target, source, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareVar(string name, bool mutable, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, mutable, true, null, initial, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareTypedVar(string name, bool mutable, ASTSymbol type, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, mutable, false, type, initial, Loc(linenr, reloc));
    }

    override ASTStatement astReturn(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReturnStatement(value, Loc(linenr, reloc));
    }

    override ASTSymbol astArray(ASTSymbol elementType, ReLoc reloc)
    {
        return new ASTArray(elementType, Loc(linenr, reloc));
    }

    override ASTSymbol astBasicType(string name, ReLoc reloc)
    {
        return new ASTBasicType(name, Loc(linenr, reloc));
    }

    override ASTSymbol astTypeOf(ASTSymbol value, ReLoc reloc)
    {
        return new ASTTypeof(value, Loc(linenr, reloc));
    }

    override ASTSymbol astPointer(ASTSymbol target, ReLoc reloc)
    {
        return new ASTPointer(target, Loc(linenr, reloc));
    }

    // expressions and statements
    override Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        return .implicitConvertTo(context, from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Expression call(FunctionDeclaration fun, Expression[] args, Loc loc)
    {
        return new Call(fun, args, loc);
    }

    override Expression callWithLifetime(Context context, Symbol target, Expression[] args, Loc loc)
    {
        return .callWithLifetime(context, target, args, loc, false);
    }

    override Expression implicitCall(Context context, Symbol target, Loc loc)
    {
        return .callWithLifetime(context, target, [], loc, true);
    }

    override Expression binaryOp(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression truthy(Context context, Expression value, Loc loc)
    {
        return .truthy(context, value, loc);
    }

    override Expression castTo(Type target, Expression source)
    {
        return new CastExpr(target, source);
    }

    override Expression wrap(Statement before, Expression value, Statement after)
    {
        if (!before && !after) return value;
        return new WrapExpression(before, value, after);
    }

    // wrap, allowing references
    override Expression wrapRef(Statement before, Expression value, Statement after)
    {
        if (!before && !after) return value;
        auto valueRef = value.instanceOf(Reference);
        if (valueRef) return new WrapReference(before, valueRef, after);
        return new WrapExpression(before, value, after);
    }

    override Expression consume(Context context, Expression expr, Expression delegate(Expression) dg)
    {
        if (expr.info.ownership != Ownership.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporary(type, false);
        auto assign = new InitializeTemporaryStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp);
        return wrap(assign, result, cleanup);
    }

    override Expression consumeTemporary(Context context, bool allowRefReturn, Expression expr, Expression delegate(Reference) dg)
    {
        auto type = expr.type;
        // "owned" by the temporary()
        auto temp = new PairedTemporary(type, false);
        auto result = dg(temp);
        if (!result) return null;

        Statement assign = new InitializeTemporaryStatement(temp, expr);
        mut Statement cleanup;
        if (expr.info.ownership == Ownership.gifted) {
            cleanup = type.endLifetime(context, temp);
        }
        if (allowRefReturn)
            return wrapRef(assign, result, cleanup);
        return wrap(assign, result, cleanup);
    }

    override Statement consumeTemporaryStmt(Context context, Expression expr, Statement delegate(Reference) dg)
    {
        auto type = expr.type;
        // "owned" by the temporary()
        auto temp = new PairedTemporary(type, false);
        auto result = dg(temp);
        if (!result) return null;

        Statement assign = new InitializeTemporaryStatement(temp, expr);
        mut Statement cleanup;
        if (expr.info.ownership == Ownership.gifted) {
            cleanup = type.endLifetime(context, temp);
        }
        return .sequence(.sequence(assign, result), cleanup);
    }

    override Symbol accessMember(Context context, Symbol base, string member, Loc loc, bool allowUndefined)
    {
        return .accessMember(context, base, member, loc, allowUndefined);
    }

    override Symbol accessMemberWithLifetime(Context context, Symbol base, string member, Loc loc, bool allowUndefined)
    {
        return .accessMemberWithLifetime(context, base, member, loc, allowUndefined);
    }

    override Reference structMemberReference(Reference base, int index) {
        return new StructMemberReference(base, index);
    }

    override Symbol lookup(Context context, string name)
    {
        auto frame = new ReferenceExpression(new StackFrame(new Void));

        return context.namespace.lookup(name, context, frame);
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression reference(Reference ref_)
    {
        return new ReferenceExpression(ref_);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequence(Statement left, Statement right)
    {
        return .sequence(left, right);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel, initializer, test, body_, step);
    }

    override Statement returnStatement(Expression value) {
        return new ReturnStatement(value);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override Statement unwindScope(Context context, Namespace target, Statement next)
    {
        return .unwindScope(context, target, next);
    }

    override Namespace symbolAlias(Namespace parent, string name, Symbol value)
    {
        return new SymbolAlias(parent, name, value);
    }

    override DeclarationHolder variableDeclaration(Namespace parent, string name, Type type, bool hidden)
    {
        return new VariableDeclaration(parent, name, type, ExprInfo(false, Ownership.owned), hidden);
    }

    override Statement move(Context context, Reference target, Expression source)
    {
        return .move(context, target, source);
    }

    override Expression exprWithScratchspace(Type type, bool temporary, Statement delegate(Reference) callback)
    {
        auto temp = new PairedTemporary(type, temporary);
        auto initialize = new UninitializeTemporaryStatement(temp);
        auto stmt = callback(temp);
        if (!stmt) return null;
        return wrap(sequence(initialize, stmt), temp, null);
    }

    override Statement stmtWithTemporary(Expression value, Statement delegate(Reference) callback)
    {
        auto temp = new PairedTemporary(value.type, value.info.ownership == Ownership.gifted);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto stmt = callback(temp);
        if (!stmt) return null;
        return new SequenceStatement([start, stmt]);
    }

    override Expression exprWithTemporary(Expression value, Expression delegate(Reference) callback)
    {
        // TODO: the way gifted works here is almost certainly wrong,
        // cause the Reference can be read multiple times - that's
        // what it's for.
        auto temp = new PairedTemporary(value.type, value.info.ownership == Ownership.gifted);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto expr = callback(temp);
        if (!expr) return null;
        return new StatementExpression(start, expr, false);
    }

    override Statement stmtWithTemporaryExpr(Expression value, Statement delegate(Expression) callback)
    {
        // TODO: does endLifetime *really* need to take a Reference?
        // cause that's the only reason we need to stmtWithTemporary here.
        if (value.info.ownership == Ownership.gifted) {
            Statement do_(Reference ref_) {
                return callback(ref_);
            }
            return stmtWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.ownership);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto stmt = callback(temp);
        if (!stmt) return null;
        return new SequenceStatement([start, stmt]);
    }

    override Expression exprWithTemporaryExpr(Expression value, Expression delegate(Expression) callback)
    {
        // see above
        if (value.info.ownership == Ownership.gifted) {
            Expression do_(Reference ref_) {
                return callback(ref_);
            }
            return exprWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.ownership);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto expr = callback(temp);
        if (!expr) return null;
        return new StatementExpression(start, expr, false);
    }

    override Expression referenceFunction(FunctionDeclaration decl)
    {
        return new FunctionReference(decl);
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression, false);
    }

    override void addDefaultImports(ModuleBase module_)
    {
        auto defaultMods = [compile(mod, false) for mod in this.defaultImports];
        [module_.addImport(mod, []) for mod in defaultMods];
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Argument[] args, ASTStatement delegate() makeBody)
    {
        Loc loc; // bleh
        string path;
        // TODO in Function
        mut string mangledName = name;
        for (auto arg <- args) {
            mangledName ~= "_" ~ arg.type.mangle;
        }
        for (auto cache <- cachedRuntimeFunctions) {
            if (cache.fun.name == mangledName) {
                auto usingMod = findParent!Module(context.namespace);
                usingMod.addImport(cache.rtMod, []);
                return cache.fun;
            }
        }

        Argument argument(string name, Type type) {
            return Argument(false, name, false, type);
        }

        auto fun = new Function(loc, mangledName, ret, args, makeBody(), context.macroState, false);
        auto pak = new Package("rt_" ~ mangledName, path);
        auto rtMod = new Module(loc, name, mangleModuleName(name, pak), null);
        rtMod.register("free", new FunctionDeclaration(
            "free", new Void, [argument("", new Pointer(new Void))]));
        rtMod.register("print", new FunctionDeclaration(
            "print", new Void, [argument("", new Array(new Character))]));
        rtMod.register("ltoa", new FunctionDeclaration(
            "cxruntime_ltoa", new Array(new Character), [argument("", new Long)]));
        rtMod.register("cxruntime_refcount_inc", new FunctionDeclaration(
            "cxruntime_refcount_inc", new Void, [
                argument("label", new Array(new Character)),
                argument("ptr", new Pointer(new Void))]));
        rtMod.register("cxruntime_refcount_dec", new FunctionDeclaration(
            "cxruntime_refcount_dec", new Integer, [
                argument("label", new Array(new Character)),
                argument("ptr", new Pointer(new Void))]));

        fun.parent = rtMod;
        rtMod.register("__" ~ name, fun);
        addDefaultImports(rtMod);
        auto usingMod = findParent!Module(context.namespace);
        usingMod.addImport(rtMod, []);

        cachedRuntimeFunctions ~= CachedRuntimeFunction(fun, rtMod);

        return fun;
    }

    override Type nativeWordType(Platform platform)
    {
        BackendType type = platform.nativeWordType;
        if (type.instanceOf(BackendIntType)) return new Integer;
        if (type.instanceOf(BackendLongType)) return new Long;
        assert(false);
    }

    override Type struct_(string name, StructMemberDeclaration[] members, Loc loc, string manglePrefix)
    {
        return new Struct(name, members, loc, manglePrefix);
    }

    override ModuleBase findModule(string key) {
        return [first a.mod for a in this.modules where a.key == key else null];
    }

    override void addModule(string key, ModuleBase module_) {
        this.modules ~= (key, module_.instanceOf(Module));
    }
}

// manual hashmap
struct ModuleSetBucket
{
    bool set;
    Module mod;
}

class ModuleSet
{
    ModuleSetBucket[] store;
    int occupied;
    this(int size) { this.store = new ModuleSetBucket[](size); this.occupied = 0; }
    void add(Module mod)
    {
        if (occupied >= (store.length * 3) / 4)
        {
            resize(cast(int) (store.length * 2 + 10));
        }
        mut size_t hash = poly_hash_whole_string(mod.mangledName);
        // TODO %
        size_t index(mut size_t hash) {
            // TODO proper unsigned types
            if (hash < 0) hash = -hash;
            return hash - (hash / store.length) * store.length;
        }
        while (store[index(hash)].set) {
            if (store[index(hash)].mod.mangledName == mod.mangledName)
                return; // already stored
            hash += 1;
        }
        store[index(hash)].set = true;
        store[index(hash)].mod = mod;
        occupied += 1;
    }
    bool has(Module mod)
    {
        mut size_t hash = poly_hash_whole_string(mod.mangledName);
        // TODO %
        size_t index(mut size_t hash) {
            // TODO proper unsigned types
            if (hash < 0) hash = -hash;
            return hash - (hash / store.length) * store.length;
        }
        while (store[index(hash)].set) {
            if (store[index(hash)].mod.mangledName == mod.mangledName)
                return true;
            hash += 1;
        }
        return false;
    }
    Module[] array()
    {
        Module[] res = new Module[](occupied);
        mut int k;
        for (auto entry <- store) {
            if (entry.set) {
                res[k] = entry.mod;
                k += 1;
            }
        }
        return res;
    }
    void resize(int newSize)
    {
        auto newSet = new ModuleSet(newSize);

        [newSet.add(bucket.mod) for bucket in store where bucket.set];
        this.store = newSet.store;
    }
}

class Options
{
    string output;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool dontLink;
    bool optimize;
    bool caching;
    bool x86_32, macro_x86_32;
    Backend backend, macroBackend;
    int generation;
    string umlFile;
    PlatformFlags platformFlags, macroPlatformFlags;

    this() {
        this.backend = new LLVMBackend();
        this.macroBackend = this.backend;
        this.caching = true;
        this.generation = __GENERATION__;
    }

    string[] parseArgs(string[] args) {
        mut string[] remArgs;
        for (mut size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            mut string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                addPackage(arg[2 .. $], false);
            } else if (arg == "-package") {
                assert(i + 1 < args.length);
                addPackage(args[i + 1], false);
                i += 1;
            } else if (flag == "-S") {
                addPackage(arg[2 .. $], true);
            } else if (arg == "-syspackage") {
                assert(i + 1 < args.length);
                addPackage(args[i + 1], true);
                i += 1;
            } else if (flag == "-l") {
                this.linkerArgs ~= arg;
            } else if (flag == "-L") {
                this.linkerArgs ~= arg[2 .. $];
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                this.output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                this.optimize = true;
            } else if (arg == "-c") {
                this.dontLink = true;
            } else if (arg == "-x") {
                this.caching = false;
            } else if (arg == "-backend=c") {
                this.backend = new CBackend;
            } else if (arg == "-macro-backend=c") {
                this.macroBackend = new CBackend;
            } else if (arg == "-m32") {
                this.x86_32 = true;
            } else if (arg == "-macro-m32") {
                this.macro_x86_32 = true;
            } else if (arg == "-print-generation") {
                print(itoa(__GENERATION__));
                exit(0); // TODO return :exit
            } else if (arg == "-next-generation") {
                // build the next generation of the compiler (used by rebuild.sh)
                this.generation = __GENERATION__ + 1;
            } else if (arg == "-uml") {
                assert(i + 1 < args.length);
                this.umlFile = args[i + 1];
                i += 1;
            } else {
                remArgs ~= arg;
            }
        }
        return remArgs;
    }

    void addPackage(string pak, bool relative) {
        auto pak = parsePackage(pak, relative);
        if ([any a.name == pak.name for a in this.astPackages]) {
            print("warn: package double-specified: " ~ pak.name ~ "; using newer definition");
            this.astPackages = [a for a in this.astPackages where a.name != pak.name];
        }
        this.astPackages ~= pak;
    }

    void parseConfig(string path) {
        if (!path.exists) return;
        auto lines = path.read.split("\n");
        mut string[] args;
        for (auto line <- lines) {
            // TODO slice()
            auto words = line.split(" ");
            args ~= words[0];
            if (words.length > 1) args ~= words[1 .. $].join(" ");
        }
        parseArgs(args);
    }
}

void main(mut string[] args)
{
    string executable = args[0];
    args = args[1 .. $];
    string execPath = executable.realpath.dirname;
    auto options = new Options;
    // TODO make configurable somehow? commandline arg?
    options.parseConfig(execPath ~ "/cx.ini");
    args = options.parseArgs(args);
    Package[] packages = options.astPackages.resolvePackages(execPath);

    if (args.length != 1)
    {
        print("Usage: cx [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!options.output.length) options.output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");
    createBuilderScripts;

    Loc loc; // bleh!
    auto builtins = new ASTModule(loc, "", new Package("builtins", ""), new MacroState, null);
    mut BackendType nativeWordType;
    if (options.x86_32) nativeWordType = new BackendIntType;
    else nativeWordType = new BackendLongType;
    auto platform = new Platform(nativeWordType, options.platformFlags);

    builtins.addSymbolAlias("string", new FixedTypeAlias(new Array(new Character)));
    builtins.addSymbolAlias("bool", new FixedTypeAlias(new Integer));
    builtins.addSymbolAlias("size_t", new ASTSizeT);
    builtins.addSymbolAlias("true", new FixedExpressionAlias(new IntLiteral(1)));
    builtins.addSymbolAlias("false", new FixedExpressionAlias(new IntLiteral(0)));
    builtins.addSymbolAlias("null", new FixedExpressionAlias(new NullExpr(new Pointer(new Void))));
    builtins.addSymbolAlias("__GENERATION__", new FixedExpressionAlias(new IntLiteral(options.generation)));

    auto defaultImports = new ASTModule[](0) ~ builtins;
    auto compilerImpl = new CompilerImpl(defaultImports);
    auto astCache = new ASTModuleCache;
    auto objectCache = new ObjectCache;
    auto modParseConfig = new ModuleParserConfig(packages, defaultImports, astCache);
    auto helper = new ParserHelperImpl(
        compilerImpl, objectCache, options.macroBackend,
        options.macro_x86_32, options.caching, options.macroPlatformFlags);

    Module compile(ASTModule astMod, bool addDefaultImports) {
        auto context = makeContext(compilerImpl, platform, null, astMod.macroState);
        return compileModule(context, astMod, addDefaultImports);
    }
    compilerImpl.compile = &compile;
    auto astToplevel = getModule(compilerImpl, args[0], null, false, helper, modParseConfig, Loc(null, ReLoc("", 0)));
    auto toplevel = compile(astToplevel, true);

    mut string baseFlags;
    if (options.optimize) baseFlags ~= " -Ofast";
    if (options.x86_32) baseFlags ~= " -m32";

    if (options.backend.instanceOf(LLVMBackend) && options.optimize)
        baseFlags ~= " -flto";

    auto allModules = new ModuleSet(0);
    void add(Module mod) {
        allModules.add(mod);
    }
    toplevel.walkModules(&add);
    auto binHash = new Hash;
    mut auto remainingModules = allModules.array;

    binHash.addl(options.generation);

    mut string fileArgs;
    mut int[] pids;
    while (remainingModules.length > 0) {
        for (auto remainingModule <- remainingModules) {
            auto compilation = emitModule(compilerImpl, objectCache, options.backend, platform, remainingModule,
                options.optimize, options.x86_32, options.caching, false);
            fileArgs ~= " " ~ compilation.objFile;
            with (compilation.hash.state) binHash.apply(add, mult);
            if (compilation.pid != 0) pids ~= compilation.pid;
        }
        auto remainingSet = new ModuleSet(0);
        // TODO add()
        void add2(Module mod) {
            if (!allModules.has(mod)) {
                allModules.add(mod);
                remainingSet.add(mod);
            }
        }
        toplevel.walkModules(&add2);
        remainingModules = remainingSet.array;
    }

    [objectCache.waitpid(pid) for pid in pids];

    if (options.umlFile != "") {
        compilerImpl.stats.instanceOf(UmlClassGraph).writeTo(options.umlFile);
    }

    if (options.dontLink) return;

    string binHashOutput = ".obj/hash_" ~ binHash.text ~ ".c";
    with (binHash.state) {
        write(binHashOutput,
"long long int compiler_hash_add() { return " ~ ltoa(add) ~ "LL; }
long long int compiler_hash_mult() { return " ~ ltoa(mult) ~ "LL; }
"       );
    }
    fileArgs ~= " " ~ binHashOutput;
    // int pid = getpid;
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = baseFlags ~ " -rdynamic";
    mut string linkerFlags = " -ldl";
    for (auto linkerArg <- options.linkerArgs) linkerFlags ~= " " ~ linkerArg;
    mut string compiler = "clang -Wno-unused-command-line-argument -fpic";
    if (options.backend.instanceOf(CBackend)) compiler = "gcc";
    string runtime = execPath ~ "/src/runtime.c";
    string cmd = compiler ~ flags ~ fileArgs ~ " " ~ runtime ~ " -o " ~ options.output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}

void createBuilderScripts() {
    write(".obj/llvmBuild.sh", "#!/usr/bin/env sh
set -e
llc $1 --filetype=obj --relocation-model=pic -o=$2
");
    // -Oz
    // disable -memcpyopt due to https://bugs.llvm.org/show_bug.cgi?id=48599
    write(".obj/llvmBuildOpt.sh", "#!/usr/bin/env sh
set -e
# opt -O3 $1 -o=$1.opt.bc
# llc -O3 --filetype=obj --relocation-model=pic $1.opt.bc -o=$2
llvm-as $1 -o=$2
");
}
