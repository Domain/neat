module main;

macro import cx.macros.listcomprehension;

import backend.base;
import backend.c;
import backend.llvm;
import backend.proxy;
import cx.array;
import cx.base;
import cx.expr;
import cx.hash;
import cx.linenr;
import cx.parser_base;
import cx.statements;
import cx.stuff;
import cx.types;
import helpers;

extern(C) int getpid();

string removeExtension(string s) {
    string shortened = s;
    while (shortened.length > 0 && shortened[shortened.length - 1 .. shortened.length] != ".")
        shortened = shortened[0 .. shortened.length - 1];
    if (shortened.length) return shortened[0 .. shortened.length - 1]; else return s;
}

string removeSlashes(string s) {
    string result;
    for (int i = 0; i < s.length; i += 1) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

string replace(string str, string match, string replace) {
    string result;
    size_t i = 0;
    while (i <= str.length - match.length) {
        if (str[i .. i + match.length] == match) {
            result ~= replace;
            i += match.length;
        } else {
            result ~= str[i];
            i += 1;
        }
    }
    result ~= str[i .. str.length];
    return result;
}

string emitModule(CompilerBase compiler, Backend backend, Platform platform, Module module_,
    bool opt, bool m32, bool caching)
{
    auto backendModule = backend.createModule(platform);
    auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    auto backendModuleC = backendModule.instanceOf(CBackendModule);
    auto hash = new Hash;

    string baseCmd;
    if (backendModuleLLVM) {
        if (opt) baseCmd = "sh .obj/llvmBuildOpt.sh %src %obj";
        else baseCmd = "sh .obj/llvmBuild.sh %src %obj";
        assert(!m32);
    } else {
        baseCmd = "gcc -fpic";
        if (opt) baseCmd ~= " -O3";
        if (m32) baseCmd ~= " -m32";
    }

    hash.adds(baseCmd);
    // TODO add compiler checksum (generation number?)

    auto symbols = module_.compile(compiler, platform);

    [symbol.hash(hash) for symbol in symbols];

    string objFile = ".obj/" ~ hash.text() ~ ".o";

    if (caching && cxruntime_file_exists(objFile))
        return objFile;

    auto generator = new Generator(platform, backendModule);
    module_.emit(generator, symbols);
    backendModule.done();
    string cmd;
    if (backendModuleLLVM) {
        string srcFile = ".obj/" ~ removeSlashes(module_.mangle()) ~ ".ll";
        auto llText = backendModuleLLVM.output.text();
        cxruntime_file_write(srcFile, llText);
        backendModuleLLVM.output.free();
        cmd = replace(replace(baseCmd, "%src", srcFile), "%obj", objFile);
    } else {
        assert(!!backendModuleC);
        string srcFile = ".obj/" ~ removeSlashes(module_.mangle()) ~ ".c";
        auto csrc = backendModuleC.output.text();
        cxruntime_file_write(srcFile, csrc);
        backendModuleC.output.free();
        cmd = baseCmd ~ " " ~ srcFile ~ " -c -o " ~ objFile;
    }
    print("$ " ~ cmd);
    cxruntime_system(cmd);
    return objFile;
}

class ParserHelperImpl : ParserHelper
{
    CompilerBase compiler;

    Backend backend;

    bool x86_32;

    bool caching;

    this(this.compiler, this.backend, this.x86_32, this.caching) { }

    // TODO why do we need 'config'?
    override void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        print("# stageM");
        BackendType macroWordType;
        if (x86_32) macroWordType = new BackendIntType;
        else macroWordType = new BackendLongType;
        auto platform = new Platform(macroWordType);

        // throwaway compilation (TODO cache?)
        Module module_ = compileModule(astModule, this, config, compiler, platform, true);
        Module[] allModules;
        Module[] remainingModules = module_.newModules(allModules);
        allModules = remainingModules;

        string baseCmd;
        if (backend.instanceOf(LLVMBackend)) baseCmd = "clang -Wno-unused-command-line-argument -fpic";
        else if (backend.instanceOf(CBackend)) baseCmd = "gcc -fpic";
        else assert(false);
        if (x86_32) baseCmd ~= " -m32";

        auto libHash = new Hash;
        string objFiles;
        while (remainingModules.length > 0) {
            for (int i = 0; i < remainingModules.length; i += 1) {
                string objFile = emitModule(compiler, backend, platform, remainingModules[i], false, x86_32, caching);
                objFiles ~= " " ~ objFile;
                libHash.adds(objFile);
            }
            remainingModules = module_.newModules(allModules);
            allModules ~= remainingModules;
        }

        auto fun = module_.lookup(function_, null).instanceOf(Function);
        string name = fun.mangle();
        string soname;
        string cmd;
        if (backend.instanceOf(LLVMBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text() ~ ".so";
            cmd = baseCmd ~ " -shared" ~ objFiles ~ " -o " ~ soname;
        }
        else if (backend.instanceOf(CBackend)) {
            soname = ".obj/macro_" ~ name ~ "_" ~ libHash.text() ~ ".so";
            string flags = " -shared -g src/runtime.c";
            if (platform.nativeWordType.instanceOf(BackendIntType)) flags ~= " -m32";
            cmd = baseCmd ~ flags ~ objFiles ~ " -o " ~ soname;
        }
        else assert(false);

        if (!caching || !cxruntime_file_exists(soname)) {
            print("$ " ~ cmd);
            cxruntime_system(cmd);
        }
        cxruntime_dlcall(soname, name, macroState);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    string[] deps;
}

string slice(string* text, string marker)
{
    int pos = find(*text, marker);
    if (pos == -1) {
        string result = *text;
        *text = "";
        return result;
    }
    string result = (*text)[0 .. pos];
    *text = (*text)[pos + marker.length .. (*text).length];
    return result;
}

ASTPackage parsePackage(string arg)
{
    string name = slice(&arg, ":");
    assert(name.length > 0);
    string path = slice(&arg, ":");
    assert(path.length > 0);
    string[] deps;
    while (arg.length)
    {
        deps ~= slice(&arg, ",");
    }
    return ASTPackage(name, path, deps);
}

Package[] resolvePackages(ASTPackage[] astPackages)
{
    Package[] result = [new Package(pkg.name, pkg.path) for pkg in astPackages];
    for (int i = 0; i < astPackages.length; i += 1) {
        auto astPackage = astPackages[i];
        for (int j = 0; j < astPackage.deps.length; j += 1) {
            Package dep;
            for (int k = 0; k < result.length; k += 1) {
                if (result[k].name == astPackage.deps[j]) {
                    if (dep) print("Dependency '" ~ astPackage.deps[j] ~ "' of '" ~ astPackage.name ~ "' exists twice!");
                    assert(!dep);
                    dep = result[k];
                    break;
                }
            }
            if (!dep) {
                print("Missing package dependency: " ~ astPackage.deps[j]);
                assert(false);
            }
            result[i].addDependency(dep);
        }
    }
    return result;
}

class FixedTypeAlias : ASTType
{
    Type type;

    this(this.type) { }

    override Type compile(Context context) { return this.type; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedTypeAlias'!"); assert(false); }
}

class FixedExpressionAlias : ASTSymbol
{
    Symbol symbol;

    this(this.symbol) { }

    override Symbol compile(Context context) { return this.symbol; }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'FixedExpressionAlias'"); assert(false); }
}

// TODO this should be ASTNamedType
class ASTSizeT : ASTType
{
    this() { }

    override Type compile(Context context) {
        return nativeWordType(context.platform);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTSizeT'!"); assert(false); }
}

class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    this(this.defaultImports) { this.linenr = new LineNumberRegistry; }

    Module delegate(ASTModule) compile;

    // parser
    override ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser, lexicalContext);
    }

    override ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser, lexicalContext);
    }

    override ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser, lexicalContext);
    }

    override ASTType parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser, lexicalContext);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, ReLoc reloc)
    {
        return new ASTBinaryOp(op, left, right, Loc(linenr, reloc));
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, ReLoc reloc)
    {
        return new ASTIndexAccess(base, index, Loc(linenr, reloc));
    }

    override ASTSymbol astMember(ASTSymbol base, string member, ReLoc reloc)
    {
        return new ASTMember(base, member, Loc(linenr, reloc));
    }

    override ASTSymbol astReference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astDereference(ASTSymbol value, ReLoc reloc)
    {
        return new ASTDereference(value, Loc(linenr, reloc));
    }

    override ASTSymbol astIntLiteral(int value, ReLoc reloc)
    {
        return new ASTIntLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astLongLiteral(long value, ReLoc reloc)
    {
        return new ASTLongLiteral(value, Loc(linenr, reloc));
    }

    override ASTSymbol astStringLiteral(string text, ReLoc reloc)
    {
        return new ASTStringLiteral(text);
    }

    override ASTSymbol astArrayLiteral(ASTSymbol[] values, ReLoc reloc)
    {
        auto elements = [ASTArrayLiteralElement(value, Loc(linenr, reloc)) for value in values];
        return new ASTArrayLiteral(elements);
    }

    override ASTSymbol astVoidLiteral(ReLoc reloc)
    {
        return new ASTVoidExpression(Loc(linenr, reloc));
    }

    override ASTSymbol astIdentifier(string name, ReLoc reloc)
    {
        return new ASTIdentifier(name, false, Loc(linenr, reloc));
    }

    override ASTSymbol astNegation(ASTSymbol value, ReLoc reloc)
    {
        return new ASTNegation(value, Loc(linenr, reloc));
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTCall(target, args, Loc(linenr, reloc));
    }

    override ASTSymbol astNewExpression(ASTType type, ASTSymbol[] args, ReLoc reloc)
    {
        return new ASTNewExpression(type, args, Loc(linenr, reloc));
    }

    override ASTSymbol astDestroy(ASTSymbol target, ReLoc reloc)
    {
        return new ASTDestroy(target, Loc(linenr, reloc));
    }

    override ASTSymbol astCast(ASTType target, ASTSymbol value, ReLoc reloc)
    {
        return new ASTCastExpr(target, value, Loc(linenr, reloc));
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, ReLoc reloc)
    {
        return new ASTExprStatement(expr, Loc(linenr, reloc));
    }

    override ASTStatement astScope(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTScopeStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astSequence(ASTStatement[] statements, ReLoc reloc)
    {
        return new ASTSequenceStatement(statements, Loc(linenr, reloc));
    }

    override ASTStatement astIf(ASTSymbol test, ASTStatement then, ASTStatement else_, ReLoc reloc)
    {
        return new ASTIfStatement(test, then, else_, Loc(linenr, reloc));
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, ReLoc reloc)
    {
        return new ASTForLoop(init, test, step, body_, Loc(linenr, reloc));
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, ReLoc reloc)
    {
        return new ASTAssignStatement(target, source, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareVar(string name, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, true, null, initial, Loc(linenr, reloc));
    }

    override ASTStatement astDeclareTypedVar(string name, ASTType type, ASTSymbol initial, ReLoc reloc)
    {
        return new ASTVarDeclStatement(name, false, type, initial, Loc(linenr, reloc));
    }

    override ASTStatement astReturn(ASTSymbol value, ReLoc reloc)
    {
        return new ASTReturnStatement(value, Loc(linenr, reloc));
    }

    override ASTType astArray(ASTType elementType, ReLoc reloc)
    {
        return new ASTArray(elementType, Loc(linenr, reloc));
    }

    override ASTType astNamedType(string name, ReLoc reloc)
    {
        return new ASTNamedType(name, Loc(linenr, reloc));
    }

    override ASTType astTypeOf(ASTSymbol value, ReLoc reloc)
    {
        return new ASTTypeof(value, Loc(linenr, reloc));
    }

    override ASTType astPointer(ASTType target, ReLoc reloc)
    {
        return new ASTPointer(target, Loc(linenr, reloc));
    }

    // expressions and statements
    override Expression implicitConvertTo(Expression from, Type to)
    {
        return .implicitConvertTo(from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Expression call(FunctionDeclaration fun, Expression[] args, Loc loc)
    {
        return new Call(fun, args, loc);
    }

    override Expression binaryOp(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression binaryOp2(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override Expression truthy(Expression value, Loc loc)
    {
        return .truthy(value, loc);
    }

    override Reference temporary(Expression value)
    {
        return new Temporary(value);
    }

    override TemporaryResult temporaryPair(Expression value)
    {
        auto temp = new UninitializedTemporary(value.type());

        return TemporaryResult(assignStatement(temp, value), temp);
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel(), initializer, test, body_, step);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override Namespace exprAlias(Namespace parent, string name, Expression value)
    {
        return new ExpressionAlias(parent, name, value);
    }

    override VariableDeclarationBase variableDeclaration(Namespace parent, string name, Type type)
    {
        return new VariableDeclaration(parent, name, type);
    }

    override Statement move(Context context, Reference target, Expression source)
    {
        return .move(context, target, source);
    }

    override Statement stmtWithTemporary(Expression value, Statement delegate(Expression) callback)
    {
        return .stmtWithTemporary(value, callback);
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression);
    }

    void addDefaultImports(Module module_)
    {
        auto defaultMods = [compile(mod) for mod in this.defaultImports];
        [module_.addImport(mod) for mod in defaultMods];
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Argument[] args, ASTStatement body_)
    {
        Loc loc; // bleh
        string path;
        // TODO in Function
        string mangledName = name;
        for (int i = 0; i < args.length; i += 1) {
            mangledName ~= "_" ~ args[i].type.mangle();
        }
        auto fun = new Function(loc, mangledName, ret, args, body_, context.macroState);
        auto rtMod = new Module(name, new Package("rt_" ~ mangledName, path), context.macroState, null);
        rtMod.add("free", new FunctionDeclaration(
            "free", new Void, [Argument(false, "", new Pointer(new Void))]));
        fun.parent = rtMod;
        string types;
        rtMod.add("__" ~ name, fun);
        addDefaultImports(rtMod);
        auto usingMod = findModule(context.namespace);
        usingMod.addImport(rtMod);
        return fun;
    }
}

void main(string[] args)
{
    print("# stage2");
    string output;
    string[] nextArgs;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool dontLink;
    bool optimize;
    bool caching = true;
    bool x86_32; bool macro_x86_32;
    // auto backend = new ProxyBackend();
    Backend backend = new LLVMBackend();
    Backend macroBackend = backend;
    {
        string[] remArgs;
        for (size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                astPackages ~= parsePackage(arg[2 .. arg.length]);
            } else if (flag == "-l") {
                linkerArgs ~= arg;
            } else if (flag == "-L") {
                linkerArgs ~= arg[2 .. arg.length];
            } else if (arg == "--") {
                nextArgs = args[i + 1 .. args.length];
                break;
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                optimize = true;
            } else if (arg == "-c") {
                dontLink = true;
            } else if (arg == "-x") {
                caching = false;
            } else if (arg == "-backend=c") {
                backend = new CBackend;
            } else if (arg == "-macro-backend=c") {
                macroBackend = new CBackend;
            } else if (arg == "-m32") {
                x86_32 = true;
            } else if (arg == "-macro-m32") {
                macro_x86_32 = true;
            } else {
                remArgs = remArgs ~ arg;
            }
        }
        args = remArgs;
    }
    Package[] packages = resolvePackages(astPackages);

    if (args.length != 1)
    {
        print("Usage: cx [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!output.length) output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");
    createBuilderScripts();

    auto builtins = new ASTModule("", new Package("builtins", ""), new MacroState, null);
    BackendType nativeWordType;
    if (x86_32) nativeWordType = new BackendIntType;
    else nativeWordType = new BackendLongType;
    auto platform = new Platform(nativeWordType);

    builtins.addTypeAlias("string", new FixedTypeAlias(new Array(new Character)));
    builtins.addTypeAlias("bool", new FixedTypeAlias(new Integer));
    builtins.addTypeAlias("size_t", new ASTSizeT);
    builtins.addExprAlias("true", new FixedExpressionAlias(new IntLiteral(1)));
    builtins.addExprAlias("false", new FixedExpressionAlias(new IntLiteral(0)));
    builtins.addExprAlias("null", new FixedExpressionAlias(new NullExpr(new Pointer(new Void))));

    auto defaultImports = new ASTModule[](0) ~ builtins;
    auto compilerImpl = new CompilerImpl(defaultImports);
    auto astCache = new ASTModuleCache;
    auto cache = new ModuleCache;
    auto modParseConfig = new ModuleParserConfig(packages, defaultImports, astCache, cache);
    auto helper = new ParserHelperImpl(
        compilerImpl, macroBackend,
        macro_x86_32, caching);

    Module compile(ASTModule astMod) {
        return compileModule(astMod, helper, modParseConfig, compilerImpl, platform, true);
    }
    compilerImpl.compile = &compile;
    auto astToplevel = getModule(compilerImpl, args[0], null, false, helper, modParseConfig, Loc(null, ReLoc("", 0)));
    auto toplevel = compile(astToplevel);

    string baseFlags;
    if (optimize) baseFlags ~= " -Ofast";
    if (x86_32) baseFlags ~= " -m32";

    Module[] allModules;
    Module[] remainingModules = toplevel.newModules(allModules);
    allModules = remainingModules;

    string fileArgs;
    while (remainingModules.length > 0) {
        for (int i = 0; i < remainingModules.length; i += 1) {
            string objFile = emitModule(compilerImpl, backend, platform, remainingModules[i],
                optimize, x86_32, caching);
            fileArgs ~= " " ~ objFile;
        }
        remainingModules = toplevel.newModules(allModules);
        allModules ~= remainingModules;
    }

    if (dontLink) return;

    // int pid = getpid();
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = baseFlags ~ " -rdynamic";
    string linkerFlags = " -ldl";
    for (int i = 0; i < linkerArgs.length; i += 1) linkerFlags ~= " " ~ linkerArgs[i];
    string compiler = "clang -Wno-unused-command-line-argument";
    if (backend.instanceOf(CBackend)) compiler = "gcc";
    string cmd = compiler ~ flags ~ fileArgs ~ " src/runtime.c -o " ~ output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}

void createBuilderScripts() {
    cxruntime_file_write(".obj/llvmBuild.sh", "#!/usr/bin/env sh
set -e
llc $1 --filetype=obj --relocation-model=pic -o=$2
");
    // -Oz
    // disable -memcpyopt due to https://bugs.llvm.org/show_bug.cgi?id=48599
    cxruntime_file_write(".obj/llvmBuildOpt.sh", "#!/usr/bin/env sh
set -e
opt -O3 $1 -o=$1.opt.bc
llc -O3 --filetype=obj --relocation-model=pic $1.opt.bc -o=$2
");
}
