module main;

import backend.base;
import backend.c;
import backend.llvm;
import backend.proxy;
import cx.array;
import cx.base;
import cx.expr;
import cx.parser_base;
import cx.stuff;
import cx.types;
import helpers;

extern(C) int getpid();

string removeExtension(string s) {
    string shortened = s;
    while (shortened.length > 0 && shortened[shortened.length - 1 .. shortened.length] != ".")
        shortened = shortened[0 .. shortened.length - 1];
    if (shortened.length) return shortened[0 .. shortened.length - 1]; else return s;
}

string removeSlashes(string s) {
    string result;
    for (int i = 0; i < s.length; i += 1) {
        if (s[i .. i + 1] == "/") result = result ~ "_";
        else result = result ~ s[i .. i + 1];
    }
    return result;
}

class ParserHelperImpl : ParserHelper
{
    Backend backend;

    Platform platform;

    this(Backend backend, Platform platform) {
        this.backend = backend;
        this.platform = platform;
    }

    override void proxyCall(Module module_, string function_, MacroState macroState)
    {
        print("# stageM");
        auto backendModule = backend.createModule(platform);
        auto proxyOutput = new Generator(platform, backendModule);

        module_.emit(proxyOutput);

        auto fun = module_.lookup(function_, null).instanceOf(Function);

        backendModule.callMacroFun(fun.mangle(), macroState);
    }
}

// "AST", lol. Package fresh off the commandline, dependencies not resolved yet.
// Needed because we can reference future packages.
struct ASTPackage
{
    string name;
    string path;
    string[] deps;
}

string slice(string* text, string marker)
{
    int pos = find(*text, marker);
    if (pos == -1) {
        string result = *text;
        *text = "";
        return result;
    }
    string result = (*text)[0 .. pos];
    *text = (*text)[pos + marker.length .. (*text).length];
    return result;
}

ASTPackage parsePackage(string arg)
{
    string name = slice(&arg, ":");
    assert(name.length > 0);
    string path = slice(&arg, ":");
    assert(path.length > 0);
    string[] deps;
    while (arg.length)
    {
        deps ~= slice(&arg, ",");
    }
    return ASTPackage(name, path, deps);
}

Package[] resolvePackages(ASTPackage[] astPackages)
{
    Package[] result;
    for (int i = 0; i < astPackages.length; i += 1) {
        result ~= new Package(astPackages[i].name, astPackages[i].path);
    }
    for (int i = 0; i < astPackages.length; i += 1) {
        auto astPackage = astPackages[i];
        for (int j = 0; j < astPackage.deps.length; j += 1) {
            Package dep;
            for (int k = 0; k < result.length; k += 1) {
                if (result[k].name == astPackage.deps[j]) {
                    if (dep) print("Dependency '" ~ astPackage.deps[j] ~ "' of '" ~ astPackage.name ~ "' exists twice!");
                    assert(!dep);
                    dep = result[k];
                    // TODO break;
                }
            }
            if (!dep) {
                print("Missing package dependency: " ~ astPackage.deps[j]);
                assert(false);
            }
            result[i].addDependency(dep);
        }
    }
    return result;
}

void main(string[] args)
{
    print("# stage2");
    string output;
    string[] nextArgs;
    string[] linkerArgs;
    ASTPackage[] astPackages;
    bool dontLink;
    bool optimize;
    bool x86_32;
    bool macro_x86_32;
    // auto backend = new ProxyBackend();
    Backend backend = new LLVMBackend();
    Backend macroBackend = backend;
    {
        string[] remArgs;
        for (size_t i = 0; i < args.length; i += 1) {
            string arg = args[i];
            string flag;
            if (arg.length >= 2) flag = arg[0 .. 2];

            // package: like includes, but scoped
            // -Pname:path[:dep1[,dep2]*]?
            if (flag == "-P") {
                astPackages ~= parsePackage(arg[2 .. arg.length]);
            } else if (flag == "-l") {
                linkerArgs ~= arg;
            } else if (flag == "-L") {
                linkerArgs ~= arg[2 .. arg.length];
            } else if (arg == "--") {
                nextArgs = args[i + 1 .. args.length];
                i = args.length; // break
            } else if (arg == "-o") {
                assert(i + 1 < args.length);
                output = args[i + 1];
                i += 1;
            } else if (arg == "-O") {
                optimize = true;
            } else if (arg == "-c") {
                dontLink = true;
            } else if (arg == "-backend=c") {
                backend = new CBackend;
            } else if (arg == "-macro-backend=c") {
                macroBackend = new CBackend;
            } else {
                remArgs = remArgs ~ arg;
            }
        }
        args = remArgs;
    }
    Package[] packages = resolvePackages(astPackages);

    if (args.length != 1)
    {
        print("Usage: cx [-Pname:path[:dep1[,dep2]*]?]* FILE.cx");
        return;
    }
    if (!output.length) output = removeExtension(args[0]);

    cxruntime_system("mkdir -p .obj");

    auto builtins = new Module("", new Package("builtins", ""));
    // auto platform = new ProxyPlatform();
    auto platform = new DefaultPlatform();
    auto backendModule = backend.createModule(platform);

    builtins.add("string", new Array(new Character));
    builtins.add("bool", new Integer);
    builtins.add("true", new IntLiteral(1));
    builtins.add("false", new IntLiteral(0));
    builtins.add("null", new NullExpr(new Pointer(new Void)));
    builtins.add("size_t", nativeWordType(platform));
    // builtins.addAlias("size_t", new ASTSizeT);

    auto defaultImports = new Module[](0) ~ builtins;
    auto cache = new ModuleCache;
    auto modParseConfig = new ModuleParserConfig(platform, packages, defaultImports, cache);
    auto helper = new ParserHelperImpl(macroBackend, platform);
    auto toplevel = parseModule(args[0], null, false, helper, modParseConfig, Loc(null, ""));
    auto generator = new Generator(platform, backendModule);

    toplevel.emit(generator);

    // backendModule.callMain(nextArgs);
    auto backendModuleLLVM = backendModule.instanceOf(LLVMBackendModule);
    auto backendModuleC = backendModule.instanceOf(CBackendModule);
    string srcFile;
    if (backendModuleLLVM) {
        srcFile = ".obj/" ~ removeSlashes(output) ~ ".ll";
        auto llText = backendModuleLLVM.output.text();
        cxruntime_file_write(srcFile, llText);
        free(llText.ptr);
        backendModuleLLVM.output.free();
    } else {
        assert(!!backendModuleC);
        srcFile = ".obj/" ~ removeSlashes(output) ~ ".c";
        auto csrc = backendModuleC.output.text();
        cxruntime_file_write(srcFile, csrc);
        free(csrc.ptr);
        backendModuleC.output.free();
    }

    if (dontLink) return;

    // int pid = getpid();
    // cxruntime_system("cat /proc/" ~ itoa(pid) ~ "/status");
    string flags = " -rdynamic";
    if (optimize) flags ~= " -Ofast";
    string linkerFlags = " -ldl";
    for (int i = 0; i < linkerArgs.length; i += 1) linkerFlags ~= " " ~ linkerArgs[i];
    string compiler = "clang";
    if (backend.instanceOf(CBackend)) compiler = "gcc";
    string cmd = compiler ~ flags ~ " " ~ srcFile ~ " src/runtime.c -o " ~ output ~ linkerFlags;
    print("$ " ~ cmd);
    cxruntime_system(cmd);
}
