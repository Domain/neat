module backend.llvm;

import backend.base;
import helpers;
macro import package(compiler).cx.macros.either;

class LLVMBackend : Backend {
    this() { }
    override LLVMBackendModule createModule(Platform platform) {
        return new LLVMBackendModule(platform);
    }
}

struct Global {
    string name;
    BackendType type;
}

struct Globals
{
    Global[] globals;
    int used;
    void add(Global global) {
        if (globals.length == 0) globals = new Global[](1);
        if (used == globals.length) {
            auto copy = new Global[](globals.length * 2);
            for (int i = 0; i < globals.length; i += 1)
                copy[i] = globals[i];
            free_(globals.ptr);
            globals = copy;
        }
        globals[used] = global;
        used += 1;
    }
    Global[] array() {
        return this.globals[0 .. this.used];
    }
    void free() { free_(globals.ptr); }
}

extern(C) void cxruntime_file_write(string file, string content);
extern(C) void cxruntime_system(string command);
extern(C) void cxruntime_dlcall(string soname, string name, void* arg);

void free_(void* p) { free(p); }
void print2(string s) { print(s); }

class LLVMBackendModule : BackendModule {
    Platform platform;
    LineWriter output;

    int literalId;
    Globals globals;

    this(Platform platform) {
        this.platform = platform;
        this.output = new LineWriter;
        this.output.print("target triple = \"x86_64-unknown-linux-gnu\"");
        this.output.print("declare i8* @llvm.stacksave()");
        this.output.print("declare void @llvm.stackrestore(i8* %ptr)");
        defineIntrinsics(this, platform);
    }

    bool declared(string name) {
        auto globals = this.globals.array();
        for (int i = 0; i < globals.length; i += 1)
            if (globals[i].name == name) return true;
        return false;
    }

    override void declare(string name, bool extern_, BackendType ret, BackendType[] args)
    {
        if (this.declared(name)) return;
        if (extern_) {
            string argstr = "(";
            for (int i = 0; i < args.length; i += 1) {
                if (i) argstr = argstr ~ ", ";
                argstr = argstr ~ llvmFmt(args[i]) ~ " %arg" ~ itoa(i);
            }
            argstr = argstr ~ ")";
            string retstr = llvmFmt(ret);
            this.output.print("declare " ~ retstr ~ " @" ~ name ~ argstr);
        }
        this.globals.add(Global(name, new BackendFunctionPointerType(ret, args)));
    }

    override BackendFunction define(string name, BackendType ret, BackendType[] args)
    {
        this.globals.add(Global(name, new BackendFunctionPointerType(ret, args)));
        return new LLVMBackendFunction(this, name, ret, args);
    }
    override void defineSymbolList(string name, string[] symbols)
    {
        string symbolList;
        for (int i = 0; i < symbols.length; i += 1) {
            if (i) symbolList = symbolList ~ ", ";
            symbolList = symbolList ~ "void()* bitcast ("
                ~ llvmFmt(this.globalType(symbols[i])) ~ " @" ~ symbols[i] ~ " to void()*)";
        }
        int ilen = 0;
        for (int i = 0; i < symbols.length; i += 1) ilen += 1; // TODO cast
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0)), ilen);
        this.output.print("@" ~ name ~ " = global " ~ llvmFmt(globalType) ~ " [ " ~ symbolList ~ " ]");
        this.globals.add(Global(name, globalType));
    }
    string nextLiteral() {
        string res = "@str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }
    BackendType globalType(string name) {
        auto globals = this.globals.array();
        for (int i = 0; i < globals.length; i += 1)
            if (globals[i].name == name)
                return globals[i].type;
        print2("no such global " ~ name);
        assert(false);
    }
    void free() {
        this.output.free();
    }
    override void callMacroFun(string name, void* ptr) {
        // TODO hash, cache backend
        auto filename = ".obj/macro_" ~ name ~ ".ll";
        auto soname = ".obj/macro_" ~ name ~ ".so";
        auto cmd = "clang -shared -fpic " ~ filename ~ " -o " ~ soname;
        auto text = this.output.text();
        cxruntime_file_write(filename, text);
        free_(text.ptr);
        this.output.free();
        print("$ " ~ cmd);
        cxruntime_system(cmd);
        cxruntime_dlcall(soname, name, ptr);
    }
}

string llvmFmt(BackendType type) {
    if (type.instanceOf(BackendLongType)) return "i64";
    if (type.instanceOf(BackendIntType)) return "i32";
    if (type.instanceOf(BackendShortType)) return "i16";
    if (type.instanceOf(BackendCharType)) return "i8";
    if (type.instanceOf(BackendFloatType)) return "float";
    if (type.instanceOf(BackendVoidType)) return "void";
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) return "[" ~ ltoa(backendSpacerType.size_) ~ " x i8]";
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            return "i8*";
        }
        return llvmFmt(backendPointerType.target) ~ "*";
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        string res = "{ ";
        for (int i = 0; i < backendStructType.members.length; i += 1) {
            if (i) res = res ~ ", ";
            res = res ~ llvmFmt(backendStructType.members[i]);
        }
        res = res ~ " }";
        return res;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        string res = llvmFmt(backendFpType.ret) ~ "(";
        for (int i = 0; i < backendFpType.args.length; i += 1) {
            if (i) res = res ~ ", ";
            res = res ~ llvmFmt(backendFpType.args[i]);
        }
        res = res ~ ")*";
        return res;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        return "[" ~ itoa(backendSAtype.length) ~ " x " ~ llvmFmt(backendSAtype.element) ~ "]";
    }
    print(type.repr());
    assert(false);
}

struct Reg { int id; }
struct Arg { int id; }

struct RegDefine
{
    int reg;
    BackendType type;
    Either(Reg, Arg, string) value;
}

struct RegDefines
{
    RegDefine[] regDefines;
    int regsDefined;
    void add(RegDefine define) {
        if (regDefines.length == 0) regDefines = new RegDefine[](1);
        if (regsDefined == regDefines.length) {
            auto copy = new RegDefine[](regDefines.length * 2);
            for (int i = 0; i < regDefines.length; i += 1)
                copy[i] = regDefines[i];
            free_(regDefines.ptr);
            regDefines = copy;
        }
        regDefines[regsDefined] = define;
        regsDefined += 1;
    }
    RegDefine[] array() {
        return this.regDefines[0 .. this.regsDefined];
    }
    void free() { free_(regDefines.ptr); }
}

class LLVMBackendFunction : BackendFunction {
    string name;
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] args;

    LineWriter output;
    RegDefines regDefines;
    int regId;
    int blockId;

    this(LLVMBackendModule mod, string name, BackendType ret, BackendType[] args)
    {
        this.name = name;
        this.mod = mod;
        this.ret_ = ret;
        this.args = args;
        this.output = new LineWriter;
        this.regId = 1;
    }
    void print(string msg) {
        this.output.append("  ");
        this.output.append(msg);
        this.output.endl();
    }
    string reg(int reg) {
        auto regDefines = this.regDefines.array();
        for (int i = 0; i < regDefines.length; i += 1) {
            RegDefine def = regDefines[i];
            if (def.reg == reg)
            {
                return def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
            }
        }
        return "%reg" ~ itoa(reg);
    }
    string treg(int reg) {
        auto regDefines = this.regDefines.array();
        for (int i = 0; i < regDefines.length; i += 1) {
            RegDefine def = regDefines[i];
            if (def.reg == reg)
            {
                string val = def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
                string type = llvmFmt(def.type);
                return type ~ " " ~ val;
            }
        }
        return "NOTFOUND %reg" ~ itoa(reg);
    }
    void outputTreg(int reg) {
        auto regDefines = this.regDefines.array();
        for (int i = 0; i < regDefines.length; i += 1) {
            RegDefine def = regDefines[i];
            if (def.reg == reg) {
                llvmFmtInto(def.type, this.output);

                this.output.append(" ");

                def.value.case {
                    Reg r: this.output.appendsi("%reg", r.id);
                    Arg a: this.output.appendsi("%arg", a.id);
                    string s: this.output.append(s);
                }

                return;
            }
        }
        print("reg " ~ itoa(reg) ~ " not found!");
        assert(false);
    }
    void defReg2(int reg, BackendType type, Either(Reg, Arg, string) value) {
        this.regDefines.add(RegDefine(reg, type, value));
    }
    int defReg(BackendType type, Either(Reg, Arg, string) value) {
        int reg = this.nextReg();
        this.defReg2(reg, type, value);
        return reg;
    }
    int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    string nextBlockLabel() {
        string res = "Label" ~ itoa(this.blockId);
        this.blockId = this.blockId + 1;
        return res;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override void setLabel(string label) {
        this.print("br label %" ~ label);
        this.print(label ~ ":");
    }
    override int arg(int index) {
        return this.defReg(this.args[index], Arg(index));
    }
    override int intLiteral(long value) {
        return this.defReg(new BackendIntType, ltoa(value));
    }
    override int shortLiteral(int value) {
        return this.defReg(new BackendShortType, itoa(value));
    }
    override int byteLiteral(int value) {
        return this.defReg(new BackendCharType, itoa(value));
    }
    override int longLiteral(long value) {
        return this.defReg(new BackendLongType, ltoa(value));
    }
    override int floatLiteral(float value) {
        return this.defReg(new BackendFloatType, "0x" ~ ftoa_hex(value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        return this.defReg(platform.nativeWordType(), ltoa(value));
    }
    override int stringLiteral(string text) {
        // TODO move to LLVMBackendModule
        string literalId = this.mod.nextLiteral();
        string type = "[" ~ ltoa(text.length) ~ " x i8]";
        string escapedText;
        // TODO ord()
        for (int i = 0; i < text.length; i += 1) {
            if (text[i .. i + 1] == "\"") escapedText ~= "\\22";
            else if (text[i .. i + 1] == "\\") escapedText ~= "\\5C";
            else escapedText ~= text[i .. i + 1];
        }
        this.mod.output.print(
            literalId ~ " = private unnamed_addr constant " ~ type ~ " c\"" ~ escapedText ~ "\"");
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ type ~ "* " ~ literalId ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int voidLiteral() {
        return this.defReg(this.ret_, "zeroinitializer");
    }
    override int symbolList(string name) {
        int reg = this.nextReg();
        auto type = this.mod.globalType(name);
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ llvmFmt(type) ~ "* @" ~ name ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int binop(string op, BackendType type, int left, int right) {
        int reg = this.nextReg();
        string typestr = llvmFmt(type);
        string instr;
        if (typestr == "float") {
            if (op == "+") instr = "fadd";
            else if (op == "-") instr = "fsub";
            else if (op == "*") instr = "fmul";
            else if (op == "/") instr = "fdiv";
            else if (op == "==") instr = "fcmp oeq";
            else if (op == "<") instr = "fcmp olt";
            else if (op == "<=") instr = "fcmp ole";
            else if (op == ">") instr = "fcmp ogt";
            else if (op == ">=") instr = "fcmp oge";
            else { print2(op); assert(false); }
        } else {
            if (op == "+") instr = "add";
            else if (op == "-") instr = "sub";
            else if (op == "*") instr = "mul";
            else if (op == "/") instr = "div";
            else if (op == "&") instr = "and";
            else if (op == "==") instr = "icmp eq";
            else if (op == "<") instr = "icmp slt";
            else if (op == "<=") instr = "icmp sle";
            else if (op == ">") instr = "icmp sgt";
            else if (op == ">=") instr = "icmp sge";
            else { print2(op); assert(false); }
        }
        this.print("%reg" ~ itoa(reg) ~ " = " ~ instr ~ " " ~ typestr ~ " " ~ this.reg(left) ~ ", " ~ this.reg(right));
        int i1 = reg;
        if (op == "==" || op == "<" || op == ">" || op == "<=" || op == ">=") {
            reg = this.nextReg();
            this.print("%reg" ~ itoa(reg) ~ " = zext i1 %reg" ~ itoa(i1) ~ " to i32");
            this.defReg2(reg, new BackendIntType, Reg(reg));
        } else {
            this.defReg2(reg, type, Reg(reg));
        }
        return reg;
    }
    override int bitcast(int from, BackendType to) {
        auto regDefines = this.regDefines.array();
        for (int i = 0; i < regDefines.length; i += 1) {
            RegDefine def = regDefines[i];
            if (def.reg == from && def.type.same(to)) {
                return from;
            }
        }
        int reg = this.nextReg();
        this.output.appendsi("  %reg", reg);
        this.output.append(" = bitcast ");
        this.outputTreg(from);
        this.output.append(" to ");
        llvmFmtInto(to, output);
        this.output.endl();
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int zeroExtend(int value, BackendType from, BackendType to) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = zext " ~ llvmFmt(from) ~ " " ~ this.reg(value) ~ " to " ~ llvmFmt(to));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int signExtend(int value, BackendType from, BackendType to) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = sext " ~ llvmFmt(from) ~ " " ~ this.reg(value) ~ " to " ~ llvmFmt(to));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int intToFloat(int value) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = sitofp " ~ this.treg(value) ~ " to float");
        this.defReg2(reg, new BackendFloatType, Reg(reg));
        return reg;
    }
    override int call(BackendType ret, string name, int[] args) {
        int reg = this.nextReg();
        string argstr = "(";
        for (int i = 0; i < args.length; i += 1) {
            if (i) argstr ~= ", ";
            argstr ~= this.treg(args[i]);
        }
        argstr ~= ")";
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void @" ~ name ~ argstr);
        } else {
            this.print("%reg" ~ itoa(reg) ~ " = call " ~ llvmFmt(ret) ~ " @" ~ name ~ argstr);
            this.defReg2(reg, ret, Reg(reg));
        }
        return reg;
    }
    override int getFuncPtr(string name) {
        auto type = this.mod.globalType(name);

        return this.defReg(type, "@" ~ name);
    }
    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType);
        assert(!!backendFpType);
        auto ret = backendFpType.ret;
        int reg = this.nextReg();
        string argstr = "(";
        for (int i = 0; i < args.length; i += 1) {
            if (i) argstr ~= ", ";
            argstr ~= this.treg(args[i]);
        }
        argstr ~= ")";
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void " ~ this.reg(callReg) ~ argstr);
        } else {
            this.print("%reg" ~ itoa(reg) ~ " = call " ~ llvmFmt(ret) ~ " " ~ this.reg(callReg) ~ argstr);
            this.defReg2(reg, ret, Reg(reg));
        }
        return reg;
    }
    override int load(BackendType backendType, int source) {
        int reg = this.nextReg();
        string typeFmt = llvmFmt(backendType);
        this.output.appendsi("  %reg", reg);
        this.output.append6s(" = load ", typeFmt, ", ", typeFmt, "* ", this.reg(source));
        this.output.endl();
        this.defReg2(reg, backendType, Reg(reg));
        return reg;
    }
    override int alloca(BackendType backendType) {
        int reg = this.nextReg();
        string typefmt = llvmFmt(backendType);
        this.print("%reg" ~ itoa(reg) ~ " = alloca " ~ typefmt);
        this.print("store " ~ typefmt ~ " zeroinitializer, " ~ typefmt ~ "* %reg" ~ itoa(reg));
        this.defReg2(reg, new BackendPointerType(backendType), Reg(reg));
        return reg;
    }
    override int field(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = extractvalue " ~ this.treg(source) ~ ", " ~ itoa(index));
        this.defReg2(reg, backendStructType.members[index], Reg(reg));
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg1 = this.bitcast(source, new BackendPointerType(backendType));
        int reg2 = this.nextReg();
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output);
        this.output.append(", ");
        llvmFmtInto(backendType, this.output);
        this.output.append("* ");
        this.output.appendsi("%reg", reg1);
        this.output.appendsi(", i32 0, i32 ", index);
        this.output.endl();
        this.defReg2(reg2, new BackendPointerType(backendStructType.members[index]), Reg(reg2));
        return reg2;
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        auto ptrType = new BackendPointerType(backendType);

        int reg1 = this.bitcast(ptrReg, ptrType);
        int reg2 = this.nextReg();
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output);
        this.output.append(", ");
        llvmFmtInto(ptrType, this.output);
        this.output.appendsis("%reg", reg1, ", ");
        llvmFmtInto(this.mod.platform.nativeWordType(), this.output);
        this.output.appendsi(" %reg", offsetReg);
        this.output.endl();
        this.defReg2(reg2, ptrType, Reg(reg2));
        return reg2;
    }
    override int saveStack() {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = call i8* @llvm.stacksave()");
        return reg;
    }
    override void restoreStack(int reg) {
        this.print("call void @llvm.stackrestore(i8* %reg" ~ itoa(reg) ~ ")");
    }
    override void store(BackendType backendType, int target_reg, int value_reg) {
        string typeStr = llvmFmt(backendType);
        this.print("store " ~ typeStr ~ " " ~ this.reg(value_reg) ~ ", " ~ this.treg(target_reg));
    }
    override void ret(int reg) {
        if (this.ret_.instanceOf(BackendVoidType)) {
            this.print("ret void");
        } else {
            this.print("ret " ~ this.treg(reg));
        }
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void branch(string label) {
        this.print("br label %" ~ label);
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg();
        this.print("%reg" ~ itoa(testReg) ~ " = icmp ne i32 " ~ this.reg(reg) ~ ", 0");
        this.print("br i1 %reg" ~ itoa(testReg) ~ ", label %" ~ thenLabel ~ ", label %" ~ elseLabel);
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void done() {
        string argstr = "(";
        this.print("unreachable");
        for (int i = 0; i < this.args.length; i += 1) {
            if (i) argstr = argstr ~ ", ";
            argstr = argstr ~ llvmFmt(this.args[i]) ~ " %arg" ~ itoa(i);
        }
        argstr = argstr ~ ")";
        string retstr = llvmFmt(this.ret_);
        this.mod.output.print("define " ~ retstr ~ " @" ~ this.name ~ argstr ~ "{");
        auto funtext = this.output.text();
        this.mod.output.print(funtext);
        free_(funtext.ptr);
        this.output.free();
        this.mod.output.print("}");

        this.regDefines.free();
    }
}

class LineAppender
{
    string buffer;
    size_t used;
    this() {
        this.buffer = new string(128);
    }
    void appends(string msg) {
        this.expand(this.used + msg.length);
        memcpy(&this.buffer[this.used], msg.ptr, msg.length);
        this.used = this.used + msg.length;
    }
    void appendi(int i) {
        this.appends(itoa(i)); // TODO
    }
    void expand(size_t newLength) {
        while (newLength > this.buffer.length)
        {
            size_t newBufLen = this.buffer.length * 2;
            auto newBuf = new string(newBufLen);
            for (int i = 0; i < this.used; i += 1) newBuf[i] = this.buffer[i];
            free();
            this.buffer = newBuf;
        }
    }
    void free() {
        free_(this.buffer.ptr);
    }
    string flush() {
        string result = new string(this.used);
        memcpy(result.ptr, this.buffer.ptr, this.used);
        this.used = 0;
        return result;
    }
}

class LineWriter
{
    string[] lines;
    int length;
    LineAppender line;
    this() {
        this.line = new LineAppender;
    }
    void free() {
        for (int i = 0; i < this.lines.length; i += 1) {
            free_(this.lines[i].ptr);
        }
        free_(this.lines.ptr);
        this.line.free();
    }
    void print(string msg) {
        this.line.appends(msg);
        this.endl();
    }
    void appendsi(string s, int i)
    {
        this.line.appends(s);
        this.line.appendi(i);
    }
    void appendsis(string s1, int i, string s2)
    {
        this.line.appends(s1);
        this.line.appendi(i);
        this.line.appends(s2);
    }
    void append(string a)
    {
        this.line.appends(a);
    }
    void append2s(string a, string b)
    {
        this.line.appends(a);
        this.line.appends(b);
    }
    void append3s(string a, string b, string c)
    {
        this.line.appends(a);
        this.line.appends(b);
        this.line.appends(c);
    }
    void append5s(string a, string b, string c, string d, string e)
    {
        this.line.appends(a);
        this.line.appends(b);
        this.line.appends(c);
        this.line.appends(d);
        this.line.appends(e);
    }
    void append6s(string a, string b, string c, string d, string e, string f)
    {
        this.append5s(a, b, c, d, e);
        this.line.appends(f);
    }
    void endl() {
        this.line.appends("\n");
        this.append_(this.line.flush());
    }
    void append_(string line) {
        if (this.length == this.lines.length) {
            size_t newLen = this.lines.length * 2;
            if (newLen == 0) newLen = 1;
            auto newLines = new string[](newLen);
            for (int i = 0; i < this.length; i += 1) newLines[i] = this.lines[i];
            free_(this.lines.ptr);
            this.lines = newLines;
        }
        this.lines[this.length] = line;
        this.length = this.length + 1;
    }
    string text()
    {
        size_t sum;
        for (int i = 0; i < this.length; i += 1)
            sum = sum + this.lines[i].length;
        string res = new char[](sum);
        size_t offset = 0;
        for (int i = 0; i < this.length; i += 1)
        {
            string line = this.lines[i];
            memcpy(&res[offset], line.ptr, line.length);
            offset = offset + line.length;
        }
        assert(offset == sum);
        return res;
    }
}

void llvmFmtInto(BackendType type, LineWriter output)
{
    if (type.instanceOf(BackendLongType)) { output.append("i64"); return; }
    if (type.instanceOf(BackendIntType)) { output.append("i32"); return; }
    if (type.instanceOf(BackendShortType)) { output.append("i16"); return; }
    if (type.instanceOf(BackendCharType)) { output.append("i8"); return; }
    if (type.instanceOf(BackendFloatType)) { output.append("float"); return; }
    if (type.instanceOf(BackendVoidType)) { output.append("void"); return; }
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) {
        output.append("[");
        output.append(ltoa(backendSpacerType.size_));
        output.append(" x i8]");
        return;
    }
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            output.append("i8*");
            return;
        }
        llvmFmtInto(backendPointerType.target, output);
        output.append("*");
        return;
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        output.append("{ ");
        for (int i = 0; i < backendStructType.members.length; i += 1) {
            if (i) output.append(", ");
            llvmFmtInto(backendStructType.members[i], output);
        }
        output.append(" }");
        return;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        llvmFmtInto(backendFpType.ret, output);
        output.append("(");
        for (int i = 0; i < backendFpType.args.length; i += 1) {
            if (i) output.append(", ");
            llvmFmtInto(backendFpType.args[i], output);
        }
        output.append(")*");
        return;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        output.append("[");
        output.append(itoa(backendSAtype.length));
        output.append(" x ");
        llvmFmtInto(backendSAtype.element, output);
        output.append("]");
    }
    print(type.repr());
    assert(false);
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = new BackendPointerType(new BackendVoidType);
    BackendType sizet = platform.nativeWordType();
    {
        auto argTypes = new BackendType[](5);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        argTypes[3] = sizet;
        argTypes[4] = sizet;
        mod.declare("_arraycmp", true, new BackendIntType, argTypes);
    }
    {
        auto argTypes = new BackendType[](3);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        mod.declare("memcpy", true, voidp, argTypes);
    }
    mod.declare("cxruntime_ptr_test", true, new BackendIntType, new BackendType[](0) ~ voidp);
    mod.declare("cxruntime_alloc", true, voidp, new BackendType[](0) ~ sizet);
}
