module backend.llvm;

macro import cx.macros.either;
macro import cx.macros.listcomprehension;

import backend.base;
import helpers;

class LLVMBackend : Backend {
    this() { }
    override LLVMBackendModule createModule(Platform platform) {
        return new LLVMBackendModule(platform);
    }
}

struct Global {
    string name;
    BackendType type;
}

struct Globals
{
    Global[] globals;
    int used;
    void add(Global global) {
        if (globals.length == 0) globals = new Global[](1);
        if (used == globals.length) {
            auto copy = new Global[](globals.length * 2);
            for (int i = 0; i < globals.length; i += 1)
                copy[i] = globals[i];
            auto baseptr = globals.base;
            globals = copy;
            .free(baseptr);
        }
        globals[used] = global;
        used += 1;
    }
    Global[] array() {
        return this.globals[0 .. this.used];
    }
    void free() { .free(globals.base); globals = []; }
}

struct DeclarationEntry
{
    string name;
    bool function_;
    BackendType type;
}

bool passByMemory(BackendType type, Platform platform) {
    // AMD64 ABI, rule 5c: aggregates over 16 bytes that are not SSE are passed in memory (byval).
    if (type.instanceOf(BackendStructType) && type.size(platform) > 16)
        return true;
    return false;
}

class LLVMBackendModule : BackendModule {
    Platform platform;
    LineWriter output;

    // LLVM can't have a symbol both declared and defined, so hold declared lines until the end;
    // remove entries that get defined.
    DeclarationEntry[] pendingDeclarations;

    int literalId;
    Globals globals;

    this(Platform platform) {
        this.platform = platform;
        this.output = new LineWriter;
        this.output.print("target triple = \"x86_64-unknown-linux-gnu\"");
        this.output.print("declare i8* @llvm.stacksave()");
        this.output.print("declare void @llvm.stackrestore(i8* %ptr)");
        defineIntrinsics(this, platform);
    }

    override bool declared(string name) {
        return [any a.name == name for a in this.globals.array()];
    }

    override void declare(string name, BackendType ret, BackendType[] args)
    {
        assert(!this.declared(name));
        auto type = new BackendFunctionPointerType(ret, args);
        pendingDeclarations ~= DeclarationEntry(name, true, type);
        this.globals.add(Global(name, type));
    }

    void removePendingDecl(string name)
    {
        for (int i = 0; i < pendingDeclarations.length; i += 1) {
            if (pendingDeclarations[i].name == name) {
                // remove entry
                pendingDeclarations[i] = pendingDeclarations[pendingDeclarations.length - 1];
                pendingDeclarations = pendingDeclarations[0 .. pendingDeclarations.length - 1];
                break;
            }
        }
    }

    override BackendFunction define(string name, BackendType ret, BackendType[] args)
    {
        removePendingDecl(name);
        this.globals.add(Global(name, new BackendFunctionPointerType(ret, args)));
        return new LLVMBackendFunction(this, name, ret, args);
    }

    override void declareSymbolList(string name, size_t length)
    {
        int ilen = 0;
        for (int i = 0; i < length; i += 1) ilen += 1; // TODO cast
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0)), ilen);
        pendingDeclarations ~= DeclarationEntry(name, false, globalType);
        this.globals.add(Global(name, globalType));
    }

    override void defineSymbolList(string name, string[] symbols)
    {
        removePendingDecl(name);
        int ilen = 0;
        for (int i = 0; i < symbols.length; i += 1) ilen += 1; // TODO cast
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0)), ilen);

        this.output.append3s("@", name, " = global ");
        llvmFmtInto(globalType, this.output, this.platform);
        this.output.appends(" [ ");
        string symbolList;
        for (int i = 0; i < symbols.length; i += 1) {
            if (i) this.output.appends(", ");
            this.output.appends("void()* bitcast (");
            llvmFmtInto(this.globalType(symbols[i]), this.output, this.platform);
            this.output.append3s(" @", symbols[i], " to void()*)");
        }
        this.output.appends(" ]");
        this.output.endl();
        this.globals.add(Global(name, globalType));
    }

    string nextLiteral() {
        string res = "@str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }

    BackendType globalType(string name) {
        auto globals = this.globals.array();
        for (int i = 0; i < globals.length; i += 1)
            if (globals[i].name == name)
                return globals[i].type;
        .print("no such global " ~ name);
        assert(false);
    }

    override void done()
    {
        for (int i = 0; i < pendingDeclarations.length; i += 1) {
            auto decl = pendingDeclarations[i];
            if (decl.function_) {
                auto type = decl.type.instanceOf(BackendFunctionPointerType);
                this.output.appends("declare ");
                bool retByMemory = passByMemory(type.ret, this.platform);
                if (retByMemory) {
                    this.output.appends("void ");
                } else {
                    llvmFmtInto(type.ret, this.output, this.platform);
                }
                this.output.append3s(" @", decl.name, "(");
                if (retByMemory) {
                    llvmFmtInto(type.ret, this.output, this.platform);
                    this.output.appends("* sret %ret");
                    if (type.args.length) this.output.appends(", ");
                }
                for (int i = 0; i < type.args.length; i += 1) {
                    if (i) this.output.appends(", ");
                    if (passByMemory(type.args[i], this.platform)) {
                        llvmFmtInto(type.args[i], this.output, this.platform);
                        this.output.appends("* byval");
                    } else {
                        llvmFmtInto(type.args[i], this.output, this.platform);
                    }
                    this.output.appendsi(" %arg", i);
                }
                this.output.appends(")");
            } else {
                this.output.append3s("@", decl.name, " = external global ");
                llvmFmtInto(decl.type, this.output, this.platform);
            }
            this.output.endl();
        }
    }

    void free() {
        this.output.free();
    }
}

string llvmFmt(BackendType type, Platform platform) {
    assert(!!type);
    if (type.instanceOf(BackendLongType)) return "i64";
    if (type.instanceOf(BackendIntType)) return "i32";
    if (type.instanceOf(BackendShortType)) return "i16";
    if (type.instanceOf(BackendCharType)) return "i8";
    if (type.instanceOf(BackendFloatType)) return "float";
    if (type.instanceOf(BackendVoidType)) return "void";
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) return "[" ~ ltoa(backendSpacerType.size_) ~ " x i8]";
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            return "i8*";
        }
        return llvmFmt(backendPointerType.target, platform) ~ "*";
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        string res = "{ ";
        for (int i = 0; i < backendStructType.members.length; i += 1) {
            if (i) res ~= ", ";
            res ~= llvmFmt(backendStructType.members[i], platform);
        }
        res ~= " }";
        return res;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        bool sret = passByMemory(backendFpType.ret, platform);
        string res;
        if (sret) res ~= "void";
        else res ~= llvmFmt(backendFpType.ret, platform);
        res ~= "(";
        if (sret) {
            res ~= llvmFmt(backendFpType.ret, platform) ~ "*";
            if (backendFpType.args.length) res ~= ", ";
        }
        for (int i = 0; i < backendFpType.args.length; i += 1) {
            if (i) res ~= ", ";
            if (passByMemory(backendFpType.args[i], platform))
                res ~= llvmFmt(backendFpType.args[i], platform) ~ "*";
            else
                res ~= llvmFmt(backendFpType.args[i], platform);
        }
        res = res ~ ")*";
        return res;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        return "[" ~ itoa(backendSAtype.length) ~ " x " ~ llvmFmt(backendSAtype.element, platform) ~ "]";
    }
    print(type.repr());
    assert(false);
}

struct Reg { int id; }
struct Arg { int id; }

struct RegDefine
{
    int reg;
    BackendType type;
    Either(Reg, Arg, string) value;
}

struct RegDefines
{
    // reg is index
    RegDefine[] regDefines;
    void add(RegDefine define) {
        resize(define.reg + 1);
        regDefines[define.reg] = define;
    }
    void resize(int targetLength) {
        if (regDefines.length < targetLength) {
            auto copy = new RegDefine[](targetLength * 2);
            for (int i = 0; i < regDefines.length; i += 1)
                copy[i] = regDefines[i];
            auto baseptr = regDefines.base;
            regDefines = copy;
            .free(baseptr);
        }
    }
    // TODO Maybe(RegDefine)
    Either(RegDefine, int) get(int reg) {
        if (reg >= regDefines.length || regDefines[reg].reg != reg)
            return 0;
        return regDefines[reg];
    }
    void free() { .free(regDefines.base); }
}

struct StaticAlloca
{
    Either(int, string) reg;
    BackendType type;
}

class LLVMBackendFunction : BackendFunction {
    string name;
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] args;

    LineWriter output;
    RegDefines regDefines;
    int regId;
    int blockId;
    StaticAlloca[] staticAllocas;

    this(LLVMBackendModule mod, string name, BackendType ret, BackendType[] args)
    {
        this.name = name;
        this.mod = mod;
        this.ret_ = ret;
        this.args = args;
        this.output = new LineWriter;
        this.regId = 1;
    }
    void print(string msg) {
        this.output.append("  ");
        this.output.append(msg);
        this.output.endl();
    }
    string reg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def:
                return def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
            int:
                return "%reg" ~ itoa(reg);
        }
    }
    string treg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                string val = def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
                string type = llvmFmt(def.type, this.mod.platform);
                return type ~ " " ~ val;
            }
            int:
                return "NOTFOUND %reg" ~ itoa(reg);
        }
    }
    void outputReg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                def.value.case {
                    Reg r: this.output.appendsi("%reg", r.id);
                    Arg a: this.output.appendsi("%arg", a.id);
                    string s: this.output.append(s);
                }
            }
            int: this.output.appendsi("%reg", reg);
        }
    }
    void outputTreg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                llvmFmtInto(def.type, this.output, this.mod.platform);

                this.output.append(" ");

                def.value.case {
                    Reg r: this.output.appendsi("%reg", r.id);
                    Arg a: this.output.appendsi("%arg", a.id);
                    string s: this.output.append(s);
                }

                return;
            }
            int: {
                .print("reg " ~ itoa(reg) ~ " not found!");
                assert(false);
            }
        }
    }
    void defReg2(int reg, BackendType type, Either(Reg, Arg, string) value) {
        this.regDefines.add(RegDefine(reg, type, value));
    }
    int defReg(BackendType type, Either(Reg, Arg, string) value) {
        int reg = this.nextReg();
        this.defReg2(reg, type, value);
        return reg;
    }
    int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override void setLabel(string label) {
        this.print(label ~ ":");
    }
    override int arg(int index) {
        return this.defReg(this.args[index], Arg(index));
    }
    override int intLiteral(long value) {
        return this.defReg(new BackendIntType, ltoa(value));
    }
    override int shortLiteral(int value) {
        return this.defReg(new BackendShortType, itoa(value));
    }
    override int byteLiteral(int value) {
        return this.defReg(new BackendCharType, itoa(value));
    }
    override int longLiteral(long value) {
        return this.defReg(new BackendLongType, ltoa(value));
    }
    override int floatLiteral(float value) {
        return this.defReg(new BackendFloatType, "0x" ~ ftoa_hex(value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        return this.defReg(platform.nativeWordType, ltoa(value));
    }
    override int stringLiteral(string text) {
        // TODO move to LLVMBackendModule
        string literalId = this.mod.nextLiteral();
        string type = "[" ~ ltoa(text.length) ~ " x i8]";
        string escapedText;
        // TODO ord()
        for (int i = 0; i < text.length; i += 1) {
            if (text[i .. i + 1] == "\"") escapedText ~= "\\22";
            else if (text[i .. i + 1] == "\\") escapedText ~= "\\5C";
            else escapedText ~= text[i .. i + 1];
        }
        this.mod.output.print(
            literalId ~ " = private unnamed_addr constant " ~ type ~ " c\"" ~ escapedText ~ "\"");
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ type ~ "* " ~ literalId ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int voidLiteral() {
        return this.defReg(this.ret_, "zeroinitializer");
    }
    override int structLiteral(BackendType struct_, int[] regs) {
        string typestr = llvmFmt(struct_, this.mod.platform);
        int curReg = this.defReg(struct_, "undef");
        for (int i = 0; i < regs.length; i += 1) {
            int nextReg = this.nextReg();
            this.print("%reg" ~ itoa(nextReg) ~ " = insertvalue " ~ this.treg(curReg)
                ~ ", " ~ this.treg(regs[i])
                ~ ", " ~ itoa(i));
            this.defReg2(nextReg, struct_, Reg(nextReg));
            curReg = nextReg;
        }
        return curReg;
    }
    override int symbolList(string name) {
        int reg = this.nextReg();
        auto type = this.mod.globalType(name);
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = bitcast " ~ llvmFmt(type, this.mod.platform) ~ "* @" ~ name ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int binop(string op, BackendType type, int left, int right) {
        int reg = this.nextReg();
        string typestr = llvmFmt(type, this.mod.platform);
        string instr;
        if (typestr == "float") {
            if (op == "+") instr = "fadd";
            else if (op == "-") instr = "fsub";
            else if (op == "*") instr = "fmul";
            else if (op == "/") instr = "fdiv";
            else if (op == "==") instr = "fcmp oeq";
            else if (op == "!=") instr = "fcmp one";
            else if (op == "<") instr = "fcmp olt";
            else if (op == "<=") instr = "fcmp ole";
            else if (op == ">") instr = "fcmp ogt";
            else if (op == ">=") instr = "fcmp oge";
            else { .print(op); assert(false); }
        } else {
            if (op == "+") instr = "add";
            else if (op == "-") instr = "sub";
            else if (op == "*") instr = "mul";
            else if (op == "/") instr = "sdiv";
            else if (op == "&") instr = "and";
            else if (op == "==") instr = "icmp eq";
            else if (op == "!=") instr = "icmp ne";
            else if (op == "<") instr = "icmp slt";
            else if (op == "<=") instr = "icmp sle";
            else if (op == ">") instr = "icmp sgt";
            else if (op == ">=") instr = "icmp sge";
            else { .print(op); assert(false); }
        }
        this.output.appendsi("  %reg", reg);
        this.output.append5s(" = ", instr, " ", typestr, " ");
        this.outputReg(left);
        this.output.append(", ");
        this.outputReg(right);
        this.output.endl();
        int i1 = reg;
        if (op == "==" || op == "!=" || op == "<" || op == ">" || op == "<=" || op == ">=") {
            reg = this.nextReg();
            this.output.appendsi("  %reg", reg);
            this.output.appendsis(" = zext i1 %reg", i1, " to i32");
            this.output.endl();
            this.defReg2(reg, new BackendIntType, Reg(reg));
        } else {
            this.defReg2(reg, type, Reg(reg));
        }
        return reg;
    }
    override int bitcast(int from, BackendType to) {
        BackendType fromType;
        {
            this.regDefines.get(from).case {
                RegDefine def: {
                    if (def.type.same(to)) return from;
                    fromType = def.type;
                }
                int: {}
            }
        }
        string castType = "bitcast";
        if (fromType && !fromType.instanceOf(BackendPointerType) && to.instanceOf(BackendPointerType))
            castType = "inttoptr";
        else if (fromType && fromType.instanceOf(BackendPointerType) && !to.instanceOf(BackendPointerType))
            castType = "ptrtoint";
        int reg = this.nextReg();
        this.output.appendsi("  %reg", reg);
        this.output.append3s(" = ", castType, " ");
        this.outputTreg(from);
        this.output.append(" to ");
        llvmFmtInto(to, output, this.mod.platform);
        this.output.endl();
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int zeroExtend(int value, BackendType to) {
        int reg = this.nextReg();
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = zext " ~ treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int signExtend(int value, BackendType to) {
        int reg = this.nextReg();
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = sext " ~ this.treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int trunc(int value, BackendType to) {
        int reg = this.nextReg();
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = trunc " ~ this.treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int intToFloat(int value) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = sitofp " ~ this.treg(value) ~ " to float");
        this.defReg2(reg, new BackendFloatType, Reg(reg));
        return reg;
    }
    override int floatToInt(int value) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = fptosi " ~ this.treg(value) ~ " to i32");
        this.defReg2(reg, new BackendFloatType, Reg(reg));
        return reg;
    }
    override int call(BackendType ret, string name, int[] args) {
        if (!mod.declared(name)) { .print(name ~ " not declared"); assert(false); }
        int reg = this.nextReg();
        auto type = this.mod.globalType(name).instanceOf(BackendFunctionPointerType);
        assert(!!type);
        string coerceReg(int i) {
            return "%reg" ~ itoa(reg) ~ ".coerce" ~ itoa(i);
        }
        for (int i = 0; i < args.length; i += 1) {
            if (passByMemory(type.args[i], this.mod.platform)) {
                string coerceReg = coerceReg(i);
                string typeFmt = llvmFmt(type.args[i], this.mod.platform);
                staticAllocas ~= StaticAlloca(coerceReg, type.args[i]);
                this.print("store " ~ this.treg(args[i]) ~ ", " ~ typeFmt ~ "* " ~ coerceReg);
            }
        }
        string retFmt = llvmFmt(ret, this.mod.platform);
        bool sret = passByMemory(ret, this.mod.platform);
        if (sret) this.print("%reg" ~ itoa(reg) ~ ".ret = alloca " ~ retFmt);
        string argstr = "(";
        if (sret) {
            argstr ~= retFmt ~ "* sret %reg" ~ itoa(reg) ~ ".ret";
            if (args.length) argstr ~= ", ";
        }
        for (int i = 0; i < args.length; i += 1) {
            if (i) argstr ~= ", ";
            if (passByMemory(type.args[i], this.mod.platform))
                argstr ~= llvmFmt(type.args[i], this.mod.platform) ~ "* byval " ~ coerceReg(i);
            else
                argstr ~= this.treg(args[i]);
        }
        argstr ~= ")";
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void @" ~ name ~ argstr);
        } else if (sret) {
            this.print("call void @" ~ name ~ argstr);
            this.defReg2(reg, ret, Reg(reg));
        } else {
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = call " ~ retFmt ~ " @" ~ name ~ argstr);
            this.defReg2(reg, ret, Reg(reg));
        }
        if (sret)
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = load " ~ retFmt ~ ", " ~ retFmt ~ "* %reg" ~ itoa(reg) ~ ".ret");
        return reg;
    }
    override int getFuncPtr(string name) {
        auto type = this.mod.globalType(name);

        return this.defReg(type, "@" ~ name);
    }
    // TODO merge with call()
    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType);
        assert(!!backendFpType);
        auto ret = backendFpType.ret;
        int reg = this.nextReg();
        string coerceReg(int i) {
            return "%reg" ~ itoa(reg) ~ ".coerce" ~ itoa(i);
        }
        for (int i = 0; i < args.length; i += 1) {
            if (passByMemory(backendFpType.args[i], this.mod.platform)) {
                string coerceReg = coerceReg(i);
                string typeFmt = llvmFmt(backendFpType.args[i], this.mod.platform);
                staticAllocas ~= StaticAlloca(coerceReg, backendFpType.args[i]);
                this.print("store " ~ this.treg(args[i]) ~ ", " ~ typeFmt ~ "* " ~ coerceReg);
            }
        }
        bool sret = passByMemory(ret, this.mod.platform);
        string retFmt = llvmFmt(ret, this.mod.platform);
        if (sret) this.print("%reg" ~ itoa(reg) ~ ".ret = alloca " ~ retFmt);
        if (ret.instanceOf(BackendVoidType)) {
            this.output.appends("  call void ");
            this.outputReg(callReg);
        } else if (sret) {
            this.output.appends("  call void ");
            this.outputReg(callReg);
            this.defReg2(reg, ret, Reg(reg));
        } else {
            this.output.appendsis("  %reg", reg, " = call ");
            llvmFmtInto(ret, this.output, this.mod.platform);
            this.output.appends(" ");
            this.outputReg(callReg);
            this.defReg2(reg, ret, Reg(reg));
        }
        output.append("(");
        if (sret) {
            llvmFmtInto(backendFpType.ret, this.output, this.mod.platform);
            this.output.appendsis("* sret %reg", reg, ".ret");
            if (args.length) this.output.appends(", ");
        }
        for (int i = 0; i < args.length; i += 1) {
            if (i) output.append(", ");
            if (passByMemory(backendFpType.args[i], this.mod.platform)) {
                llvmFmtInto(backendFpType.args[i], this.output, this.mod.platform);
                this.output.append2s("* byval ", coerceReg(i));
            }
            else
                this.outputTreg(args[i]);
        }
        this.output.appends(")");
        this.output.endl();
        if (sret)
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = load " ~ retFmt ~ ", " ~ retFmt ~ "* %reg" ~ itoa(reg) ~ ".ret");
        return reg;
    }
    override int load(BackendType backendType, int source) {
        int reg = this.nextReg();
        string typeFmt = llvmFmt(backendType, this.mod.platform);
        this.output.appendsi("  %reg", reg);
        this.output.append6s(" = load ", typeFmt, ", ", typeFmt, "* ", this.reg(source));
        this.output.endl();
        this.defReg2(reg, backendType, Reg(reg));
        return reg;
    }
    override int staticAlloca(BackendType backendType) {
        int reg = this.nextReg();
        this.staticAllocas ~= StaticAlloca(reg, backendType);
        this.defReg2(reg, new BackendPointerType(backendType), Reg(reg));
        string typefmt = llvmFmt(backendType, this.mod.platform);
        // TODO zeroLiteral
        this.print("store " ~ typefmt ~ " zeroinitializer, " ~ typefmt ~ "* %reg" ~ itoa(reg));
        return reg;
    }
    override int field(BackendType backendType, int source, size_t index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg = this.nextReg();
        this.output.appendsis("  %reg", reg, " = extractvalue ");
        this.outputTreg(source);
        this.output.appendsi(", ", index);
        this.output.endl();
        this.defReg2(reg, backendStructType.members[index], Reg(reg));
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg1 = this.bitcast(source, new BackendPointerType(backendType));
        int reg2 = this.nextReg();
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append(", ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append("* ");
        this.output.appendsi("%reg", reg1);
        this.output.appendsi(", i32 0, i32 ", index);
        this.output.endl();
        this.defReg2(reg2, new BackendPointerType(backendStructType.members[index]), Reg(reg2));
        return reg2;
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        auto ptrType = new BackendPointerType(backendType);

        int reg1 = this.bitcast(ptrReg, ptrType);
        int reg2 = this.nextReg();
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append(", ");
        llvmFmtInto(ptrType, this.output, this.mod.platform);
        this.output.appendsis(" %reg", reg1, ", ");
        this.outputTreg(offsetReg);
        this.output.endl();
        this.defReg2(reg2, ptrType, Reg(reg2));
        return reg2;
    }
    override void store(BackendType backendType, int target_reg, int value_reg) {
        this.output.appends("  store ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.appends(" ");
        this.outputReg(value_reg);
        this.output.appends(", ");
        this.outputTreg(target_reg);
        this.output.endl();
    }
    override void ret(int reg) {
        bool sret = passByMemory(this.ret_, this.mod.platform);
        if (this.ret_.instanceOf(BackendVoidType)) {
            this.print("ret void");
        } else if (sret) {
            this.print(
                "store " ~ this.treg(reg) ~ ", "
                ~ llvmFmt(this.ret_, this.mod.platform) ~ " *%ret");
            this.print("ret void");
        } else {
            this.print("ret " ~ this.treg(reg));
        }
        this.blockId += 1;
    }
    override void branch(string label) {
        this.print("br label %" ~ label);
        this.blockId += 1;
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg();
        this.print("%reg" ~ itoa(testReg) ~ " = icmp ne i32 " ~ this.reg(reg) ~ ", 0");
        this.print("br i1 %reg" ~ itoa(testReg) ~ ", label %" ~ thenLabel ~ ", label %" ~ elseLabel);
        this.blockId += 1;
    }
    override void done() {
        string argstr = "(";
        this.print("unreachable");
        bool sret = passByMemory(this.ret_, this.mod.platform);
        string retFmt = llvmFmt(this.ret_, this.mod.platform);
        if (sret) {
            argstr ~= retFmt ~ "* sret %ret";
            if (this.args.length) argstr ~= ", ";
        }
        for (int i = 0; i < this.args.length; i += 1) {
            if (i) argstr = argstr ~ ", ";
            if (passByMemory(this.args[i], this.mod.platform))
                argstr ~= llvmFmt(this.args[i], this.mod.platform)
                    ~ "* byval %arg" ~ itoa(i) ~ ".coerce";
            else
                argstr ~= llvmFmt(this.args[i], this.mod.platform) ~ " %arg" ~ itoa(i);
        }
        string retstr;
        if (sret)
            retstr = "void";
        else
            retstr = retFmt;
        argstr = argstr ~ ")";
        this.mod.output.print("define " ~ retstr ~ " @" ~ this.name ~ argstr ~ "{");
        for (int i = 0; i < this.args.length; i += 1) {
            string argFmt = llvmFmt(this.args[i], this.mod.platform);
            if (passByMemory(this.args[i], this.mod.platform))
                this.mod.output.print(
                    "%arg" ~ itoa(i)
                    ~ " = load " ~ argFmt ~ ", " ~ argFmt ~ "* %arg" ~ itoa(i) ~ ".coerce");
        }
        for (int i = 0; i < this.staticAllocas.length; i += 1) {
            auto reg = this.staticAllocas[i].reg;
            auto type = this.staticAllocas[i].type;
            string typefmt = llvmFmt(type, this.mod.platform);
            this.mod.output.print(reg.case(string s: s, int i: "%reg" ~ itoa(i)) ~ " = alloca " ~ typefmt);
        }
        {
            auto funtext = this.output.text();
            this.mod.output.print(funtext);
        }
        this.output.free();
        this.mod.output.print("}");

        this.regDefines.free();
    }
}

class LineWriter
{
    string buffer;
    size_t used;
    this() {
        this.buffer = new string(128);
    }
    void appends(string msg) {
        this.expand(this.used + msg.length);
        memcpy(&this.buffer[this.used], msg.ptr, msg.length);
        this.used = this.used + msg.length;
    }
    void appendi(long i) {
        if (i == 0) {
            this.appends("0");
            return;
        }
        if (i < 0)
        {
            this.appends("-");
            appendi(0 - i);
            return;
        }
        int k = 1;
        while (k <= i) k *= 10;
        while (k >= 10)
        {
            k /= 10;
            size_t digit = i / k;
            this.appends("0123456789"[digit .. digit + 1]);
            i -= digit * k;
        }
    }
    void expand(size_t newLength) {
        while (newLength > this.buffer.length)
        {
            size_t newBufLen = this.buffer.length * 2;
            auto newBuf = new string(newBufLen);
            for (int i = 0; i < this.used; i += 1) newBuf[i] = this.buffer[i];
            free();
            this.buffer = newBuf;
        }
    }
    void free() {
        auto baseptr = this.buffer.base;
        this.buffer = [];
        .free(baseptr);
    }
    string text() {
        return this.buffer[0 .. this.used];
    }
    void print(string msg) {
        this.appends(msg);
        this.endl();
    }
    void appendsi(string s, long l)
    {
        this.appends(s);
        this.appendi(l);
    }
    void appendsis(string s1, int i, string s2)
    {
        this.appends(s1);
        this.appendi(i);
        this.appends(s2);
    }
    void append(string a)
    {
        this.appends(a);
    }
    void append2s(string a, string b)
    {
        this.appends(a);
        this.appends(b);
    }
    void append3s(string a, string b, string c)
    {
        this.appends(a);
        this.appends(b);
        this.appends(c);
    }
    void append5s(string a, string b, string c, string d, string e)
    {
        this.appends(a);
        this.appends(b);
        this.appends(c);
        this.appends(d);
        this.appends(e);
    }
    void append6s(string a, string b, string c, string d, string e, string f)
    {
        this.append5s(a, b, c, d, e);
        this.appends(f);
    }
    void endl() {
        this.appends("\n");
    }
}

void llvmFmtInto(BackendType type, LineWriter output, Platform platform)
{
    if (type.instanceOf(BackendLongType)) { output.append("i64"); return; }
    if (type.instanceOf(BackendIntType)) { output.append("i32"); return; }
    if (type.instanceOf(BackendShortType)) { output.append("i16"); return; }
    if (type.instanceOf(BackendCharType)) { output.append("i8"); return; }
    if (type.instanceOf(BackendFloatType)) { output.append("float"); return; }
    if (type.instanceOf(BackendVoidType)) { output.append("void"); return; }
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) {
        output.append("[");
        output.append(ltoa(backendSpacerType.size_));
        output.append(" x i8]");
        return;
    }
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            output.append("i8*");
            return;
        }
        llvmFmtInto(backendPointerType.target, output, platform);
        output.append("*");
        return;
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        output.append("{ ");
        for (int i = 0; i < backendStructType.members.length; i += 1) {
            if (i) output.append(", ");
            llvmFmtInto(backendStructType.members[i], output, platform);
        }
        output.append(" }");
        return;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        bool sret = passByMemory(backendFpType.ret, platform);
        if (sret)
            output.append("void");
        else
            llvmFmtInto(backendFpType.ret, output, platform);
        output.append("(");
        if (sret) {
            llvmFmtInto(backendFpType.ret, output, platform);
            if (backendFpType.args.length) output.append("*,");
            else output.append("*");
        }
        for (int i = 0; i < backendFpType.args.length; i += 1) {
            if (i) output.append(", ");
            if (passByMemory(backendFpType.args[i], platform)) {
                llvmFmtInto(backendFpType.args[i], output, platform);
                output.appends("*");
            } else
                llvmFmtInto(backendFpType.args[i], output, platform);
        }
        output.append(")*");
        return;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        output.append("[");
        output.append(itoa(backendSAtype.length));
        output.append(" x ");
        llvmFmtInto(backendSAtype.element, output, platform);
        output.append("]");
        return;
    }
    print(type.repr());
    assert(false);
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = platform.voidp();
    BackendType sizet = platform.nativeWordType;
    {
        auto argTypes = new BackendType[](5);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        argTypes[3] = sizet;
        argTypes[4] = sizet;
        mod.declare("_arraycmp", new BackendIntType, argTypes);
    }
    {
        auto argTypes = new BackendType[](3);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        mod.declare("memcpy", voidp, argTypes);
    }
    mod.declare("cxruntime_ptr_test", new BackendIntType, [voidp]);
    mod.declare("cxruntime_alloc", voidp, [sizet]);
}
