module backend.llvm;

macro import cx.macros.listcomprehension;

import backend.base;
import helpers;

class LLVMBackend : Backend {
    this() { }
    override LLVMBackendModule createModule(Platform platform, BackendLocation loc, bool forMacro) {
        return new LLVMBackendModule(platform, loc, forMacro);
    }
}

struct Global {
    string name;
    BackendType type;
}

struct Globals
{
    Global[] globals;
    int used;
    void add(Global global) {
        if (globals.length == 0) globals = new Global[](1);
        if (used == globals.length) {
            auto copy = new Global[](globals.length * 2);
            for (int i <- 0 .. globals.length)
                copy[i] = globals[i];
            globals = copy;
        }
        globals[used] = global;
        used += 1;
    }
    Global[] array() {
        return this.globals[0 .. this.used];
    }
}

struct DeclarationEntry
{
    string name;
    bool function_;
    BackendType type;
}

bool passByMemory(BackendType type, Platform platform) {
    // AMD64 ABI, rule 5c: aggregates over 16 bytes that are not SSE are passed in memory (byval).
    if (type.instanceOf(BackendStructType) && type.size(platform) > 16)
        return true;
    return false;
}

struct DebugInfo {
    string key;
    string value;
}

extern(C) bool cxruntime_symbol_defined_in_main(string symbol);

class LLVMBackendModule : BackendModule {
    Platform platform;
    LineWriter output;

    // LLVM can't have a symbol both declared and defined, so hold declared lines until the end;
    // remove entries that get defined.
    DeclarationEntry[] pendingDeclarations;

    int literalId;
    Globals globals;

    DebugInfo[] debugInfos;
    string compileUnit;

    bool forMacro;

    this(this.platform, BackendLocation loc, this.forMacro) {
        this.output = new LineWriter;
        this.output.print("target triple = \"x86_64-unknown-linux-gnu\"");
        this.output.print("declare i8* @llvm.stacksave()");
        this.output.print("declare void @llvm.stackrestore(i8* %ptr)");

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        string debugFileKey = debugInfo("!DIFile(filename: \"" ~ filename ~ "\", directory: \"" ~ dir ~ "\")");
        this.compileUnit = distinctDebugInfo(
            "!DICompileUnit(language: DW_LANG_C99, file: " ~ debugFileKey ~ ", emissionKind: FullDebug)");
        this.output.print("!llvm.dbg.cu = !{" ~ compileUnit ~ "}");

        string dwarfVersion = this.debugInfo("!{i32 2, !\"Dwarf Version\", i32 2}");
        string dbgVersion = this.debugInfo("!{i32 2, !\"Debug Info Version\", i32 3}");
        string picLevel = this.debugInfo("!{i32 1, !\"PIC Level\", i32 2}");
        this.output.print("!llvm.module.flags = !{" ~ dwarfVersion ~ ", " ~ dbgVersion ~ ", " ~ picLevel ~ "}");

        defineIntrinsics(this, platform);
    }

    override bool declared(string name) {
        return [any a.name == name for a in this.globals.array];
    }

    override void declare(string name, BackendType ret, BackendType[] args)
    {
        assert(!this.declared(name));
        auto type = new BackendFunctionPointerType(ret, args);
        pendingDeclarations ~= DeclarationEntry(name, true, type);
        this.globals.add(Global(name, type));
    }

    void removePendingDecl(string name)
    {
        for (int i <- 0 .. pendingDeclarations.length) {
            if (pendingDeclarations[i].name == name) {
                // remove entry
                pendingDeclarations[i] = pendingDeclarations[$ - 1];
                pendingDeclarations = pendingDeclarations[0 .. $ - 1];
                break;
            }
        }
    }

    string debugInfo_(bool distinct, string value) {
        string insert() {
            string key = "!" ~ ltoa(this.debugInfos.length);
            if (distinct) this.debugInfos ~= DebugInfo(key, "distinct " ~ value);
            else this.debugInfos ~= DebugInfo(key, value);
            return key;
        }
        if (distinct) return insert;
        return [first a.key for a in debugInfos where a.value == value else insert];
    }

    string debugInfo(string value) { return debugInfo_(false, value); }
    string distinctDebugInfo(string value) { return debugInfo_(true, value); }

    override BackendFunction define(
        string name, string decoration, BackendType ret, BackendType[] args, BackendLocation loc)
    {
        removePendingDecl(name);
        this.globals.add(Global(name, new BackendFunctionPointerType(ret, args)));

        auto comps = split(loc.file, "/");
        auto dir = join(comps[0 .. $ - 1], "/");
        auto filename = comps[$ - 1];

        auto debugFileKey = debugInfo("!DIFile(filename: \"" ~ filename ~ "\", directory: \"" ~ dir ~ "\")");
        auto typeKey = debugInfo("!DISubroutineType(types: " ~ debugInfo("!{null}") ~ ")");
        string subProgram = distinctDebugInfo(
            "!DISubprogram(name: \"" ~ decoration ~ /*"\", linkageName: \"" ~ name ~ */"\", " ~
            "scope: " ~ debugFileKey ~ ", file: " ~ debugFileKey ~ ", line: " ~ ltoa(loc.line) ~ ", " ~
            "type: " ~ typeKey ~ ", unit: " ~ this.compileUnit ~ ")");

        return new LLVMBackendFunction(this, name, ret, args, subProgram);
    }

    override void declareSymbolList(string name, size_t length)
    {
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0)), cast(int) length);
        pendingDeclarations ~= DeclarationEntry(name, false, globalType);
        this.globals.add(Global(name, globalType));
    }

    override void defineSymbolList(string name, string[] symbols)
    {
        if (forMacro && cxruntime_symbol_defined_in_main(name))
            return;

        removePendingDecl(name);
        auto globalType = new BackendStaticArrayType(
            new BackendFunctionPointerType(new BackendVoidType, new BackendType[](0)), cast(int) symbols.length);

        this.output.append3s("@", name, " = global ");
        llvmFmtInto(globalType, this.output, this.platform);
        this.output.appends(" [ ");
        string symbolList;
        for (int i <- 0 .. symbols.length) {
            if (i) this.output.appends(", ");
            this.output.appends("void()* bitcast (");
            llvmFmtInto(this.globalType(symbols[i]), this.output, this.platform);
            this.output.append3s(" @", symbols[i], " to void()*)");
        }
        this.output.appends(" ]");
        this.output.endl;
        this.globals.add(Global(name, globalType));
    }

    string nextLiteral() {
        string res = "@str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }

    BackendType globalType(string name) {
        auto globals = this.globals.array;
        for (int i <- 0 .. globals.length)
            if (globals[i].name == name)
                return globals[i].type;
        .print("no such global " ~ name);
        assert(false);
    }

    override void done()
    {
        for (int i <- 0 .. pendingDeclarations.length) {
            auto decl = pendingDeclarations[i];
            if (decl.function_) {
                auto type = decl.type.instanceOf(BackendFunctionPointerType);
                this.output.appends("declare ");
                bool retByMemory = passByMemory(type.ret, this.platform);
                if (retByMemory) {
                    this.output.appends("void ");
                } else {
                    llvmFmtInto2(type.ret, this.output, this.platform, true);
                }
                this.output.append3s(" @", decl.name, "(");
                if (retByMemory) {
                    llvmFmtInto2(type.ret, this.output, this.platform, true);
                    this.output.appends("* sret %ret");
                    if (type.args.length) this.output.appends(", ");
                }
                for (int i <- 0 .. type.args.length) {
                    if (i) this.output.appends(", ");
                    if (passByMemory(type.args[i], this.platform)) {
                        llvmFmtInto(type.args[i], this.output, this.platform);
                        this.output.appends("* byval");
                    } else {
                        llvmFmtInto(type.args[i], this.output, this.platform);
                    }
                    this.output.appendsi(" %arg", i);
                }
                this.output.appends(")");
            } else {
                this.output.append3s("@", decl.name, " = external global ");
                llvmFmtInto(decl.type, this.output, this.platform);
            }
            this.output.endl;
        }
        for (int i <- 0 .. this.debugInfos.length) {
            auto debugInfo = this.debugInfos[i];
            this.output.append3s(debugInfo.key, " = ", debugInfo.value);
            this.output.endl;
        }
    }
}

string llvmFmt(BackendType type, Platform platform) {
    return type.llvmFmt2(platform, false);
}

string llvmFmt2(BackendType type, Platform platform, bool returnType) {
    assert(!!type);
    if (type.instanceOf(BackendLongType)) return "i64";
    if (type.instanceOf(BackendIntType)) return "i32";
    if (type.instanceOf(BackendShortType)) return "i16";
    if (type.instanceOf(BackendCharType)) return "i8";
    if (type.instanceOf(BackendFloatType)) return "float";
    if (type.instanceOf(BackendDoubleType)) return "double";
    if (type.instanceOf(BackendVoidType)) {
        if (returnType) return "void";
        return "{}";
    }
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) return "[" ~ ltoa(backendSpacerType.size_) ~ " x i8]";
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            return "i8*";
        }
        return llvmFmt2(backendPointerType.target, platform, false) ~ "*";
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        mut string res = "{ ";
        for (int i <- 0 .. backendStructType.members.length) {
            if (i) res ~= ", ";
            res ~= llvmFmt2(backendStructType.members[i], platform, false);
        }
        res ~= " }";
        return res;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        bool sret = passByMemory(backendFpType.ret, platform);
        mut string res;
        if (sret) res ~= "void";
        else res ~= llvmFmt2(backendFpType.ret, platform, true);
        res ~= "(";
        if (sret) {
            res ~= llvmFmt2(backendFpType.ret, platform, true) ~ "*";
            if (backendFpType.args.length) res ~= ", ";
        }
        for (int i <- 0 .. backendFpType.args.length) {
            if (i) res ~= ", ";
            if (passByMemory(backendFpType.args[i], platform))
                res ~= llvmFmt2(backendFpType.args[i], platform, false) ~ "*";
            else
                res ~= llvmFmt2(backendFpType.args[i], platform, false);
        }
        res = res ~ ")*";
        return res;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        return "[" ~ itoa(backendSAtype.length) ~ " x " ~ llvmFmt2(backendSAtype.element, platform, false) ~ "]";
    }
    print(type.repr);
    assert(false);
}

struct Reg { int id; }
struct Arg { int id; }

struct RegDefine
{
    int reg;
    BackendType type;
    (Reg | Arg | string) value;
}

struct RegDefines
{
    // reg is index
    RegDefine[] regDefines;
    void add(RegDefine define) {
        resize(define.reg + 1);
        regDefines[define.reg] = define;
    }
    void resize(int targetLength) {
        if (regDefines.length < targetLength) {
            auto copy = new RegDefine[](targetLength * 2);
            for (int i <- 0 .. regDefines.length)
                copy[i] = regDefines[i];
            regDefines = copy;
        }
    }
    // TODO Maybe(RegDefine)
    (RegDefine | :notFound) get(int reg) {
        if (reg >= regDefines.length || regDefines[reg].reg != reg)
            return :notFound;
        return regDefines[reg];
    }
}

struct StaticAlloca
{
    (int | string) reg;
    BackendType type;
}

class LLVMBackendFunction : BackendFunction {
    string name;
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] args;

    LineWriter output;
    RegDefines regDefines;
    int regId;
    int blockId;
    StaticAlloca[] staticAllocas;
    string debugSubProgram;

    this(this.mod, this.name, this.ret_, this.args, this.debugSubProgram)
    {
        this.output = new LineWriter;
        this.regId = 1;
    }
    void print(string msg) {
        this.output.append("  ");
        this.output.append(msg);
        this.output.endl;
    }
    string reg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def:
                return def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
            (:notFound):
                return "%reg" ~ itoa(reg);
        }
    }
    string treg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                string val = def.value.case(
                    Reg r: "%reg" ~ itoa(r.id),
                    Arg a: "%arg" ~ itoa(a.id),
                    string s: s);
                string type = llvmFmt(def.type, this.mod.platform);
                return type ~ " " ~ val;
            }
            (:notFound):
                return "NOTFOUND %reg" ~ itoa(reg);
        }
    }
    void outputReg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                def.value.case {
                    Reg r: this.output.appendsi("%reg", r.id);
                    Arg a: this.output.appendsi("%arg", a.id);
                    string s: this.output.append(s);
                }
            }
            (:notFound): this.output.appendsi("%reg", reg);
        }
    }
    void outputTreg(int reg) {
        // TODO
        // if (RegDefine def <- this.regDefines.get(reg)) {
        this.regDefines.get(reg).case {
            RegDefine def: {
                llvmFmtInto(def.type, this.output, this.mod.platform);

                this.output.append(" ");

                def.value.case {
                    Reg r: this.output.appendsi("%reg", r.id);
                    Arg a: this.output.appendsi("%arg", a.id);
                    string s: this.output.append(s);
                }

                return;
            }
            (:notFound): {
                .print("reg " ~ itoa(reg) ~ " not found!");
                assert(false);
            }
        }
    }
    void defReg2(int reg, BackendType type, (Reg | Arg | string) value) {
        this.regDefines.add(RegDefine(reg, type, value));
    }
    int defReg(BackendType type, (Reg | Arg | string) value) {
        int reg = this.nextReg;
        this.defReg2(reg, type, value);
        return reg;
    }
    int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override void setLabel(string label) {
        this.print(label ~ ":");
    }
    override int arg(int index) {
        return this.defReg(this.args[index], Arg(index));
    }
    override int intLiteral(long value) {
        return this.defReg(new BackendIntType, ltoa(value));
    }
    override int shortLiteral(int value) {
        return this.defReg(new BackendShortType, itoa(value));
    }
    override int byteLiteral(int value) {
        return this.defReg(new BackendCharType, itoa(value));
    }
    override int longLiteral(long value) {
        return this.defReg(new BackendLongType, ltoa(value));
    }
    override int floatLiteral(float value) {
        return this.defReg(new BackendFloatType, "0x" ~ ftoa_hex(value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        return this.defReg(platform.nativeWordType, ltoa(value));
    }
    override int stringLiteral(string text) {
        // TODO move to LLVMBackendModule
        string literalId = this.mod.nextLiteral;
        string type = "[" ~ ltoa(text.length) ~ " x i8]";
        mut string escapedText;
        // TODO ord()
        for (int i <- 0 .. text.length) {
            if (text[i .. i + 1] == "\"") escapedText ~= "\\22";
            else if (text[i .. i + 1] == "\\") escapedText ~= "\\5C";
            else escapedText ~= text[i .. i + 1];
        }
        this.mod.output.print(
            literalId ~ " = private unnamed_addr constant " ~ type ~ " c\"" ~ escapedText ~ "\"");
        int reg = this.nextReg;
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ type ~ "* " ~ literalId ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int voidLiteral() {
        return zeroLiteral(this.ret_);
    }
    override int zeroLiteral(BackendType type) {
        return this.defReg(type, "zeroinitializer");
    }
    override int structLiteral(BackendType struct_, int[] regs) {
        string typestr = llvmFmt(struct_, this.mod.platform);
        mut int curReg = this.defReg(struct_, "undef");
        for (int i <- 0 .. regs.length) {
            int nextReg = this.nextReg;
            this.print("%reg" ~ itoa(nextReg) ~ " = insertvalue " ~ this.treg(curReg)
                ~ ", " ~ this.treg(regs[i])
                ~ ", " ~ itoa(i));
            this.defReg2(nextReg, struct_, Reg(nextReg));
            curReg = nextReg;
        }
        return curReg;
    }
    override int symbolList(string name) {
        int reg = this.nextReg;
        auto type = this.mod.globalType(name);
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = bitcast " ~ llvmFmt(type, this.mod.platform) ~ "* @" ~ name ~ " to i8*");
        return this.defReg(new BackendPointerType(new BackendCharType), Reg(reg));
    }
    override int binop(string op, BackendType type, int left, int right) {
        mut int reg = this.nextReg;
        string typestr = llvmFmt(type, this.mod.platform);
        mut string instr;
        if (typestr == "float") {
            if (op == "+") instr = "fadd";
            else if (op == "-") instr = "fsub";
            else if (op == "*") instr = "fmul";
            else if (op == "/") instr = "fdiv";
            else if (op == "==") instr = "fcmp oeq";
            else if (op == "!=") instr = "fcmp one";
            else if (op == "<") instr = "fcmp olt";
            else if (op == "<=") instr = "fcmp ole";
            else if (op == ">") instr = "fcmp ogt";
            else if (op == ">=") instr = "fcmp oge";
            else { .print(op); assert(false); }
        } else {
            if (op == "+") instr = "add";
            else if (op == "-") instr = "sub";
            else if (op == "*") instr = "mul";
            else if (op == "/") instr = "sdiv";
            else if (op == "%") instr = "srem";
            else if (op == "&") instr = "and";
            else if (op == "|") instr = "or";
            else if (op == "<<") instr = "shl";
            else if (op == ">>") instr = "ashr";
            else if (op == "==") instr = "icmp eq";
            else if (op == "!=") instr = "icmp ne";
            else if (op == "<") instr = "icmp slt";
            else if (op == "<=") instr = "icmp sle";
            else if (op == ">") instr = "icmp sgt";
            else if (op == ">=") instr = "icmp sge";
            else { .print(op); assert(false); }
        }
        this.output.appendsi("  %reg", reg);
        this.output.append5s(" = ", instr, " ", typestr, " ");
        this.outputReg(left);
        this.output.append(", ");
        this.outputReg(right);
        this.output.endl;
        int i1 = reg;
        if (isBooleanOp(op)) {
            reg = this.nextReg;
            this.output.appendsi("  %reg", reg);
            this.output.appendsis(" = zext i1 %reg", i1, " to i32");
            this.output.endl;
            this.defReg2(reg, new BackendIntType, Reg(reg));
        } else {
            this.defReg2(reg, type, Reg(reg));
        }
        return reg;
    }
    override int bitcast(int from, BackendType to) {
        mut BackendType fromType;
        this.regDefines.get(from).case {
            RegDefine def: {
                if (def.type.same(to)) return from;
                fromType = def.type;
            }
            (:notFound): {}
        }
        assert(!fromType || !fromType.instanceOf(BackendStructType));
        mut string castType = "bitcast";
        if (fromType && !fromType.instanceOf(BackendPointerType) && to.instanceOf(BackendPointerType))
            castType = "inttoptr";
        else if (fromType && fromType.instanceOf(BackendPointerType) && !to.instanceOf(BackendPointerType))
            castType = "ptrtoint";
        else if (fromType && !fromType.instanceOf(BackendPointerType) && to.instanceOf(BackendCharType))
            castType = "trunc";
        else if (fromType && fromType.instanceOf(BackendDoubleType) && to.instanceOf(BackendFloatType))
            castType = "fptrunc";
        assert(!fromType || fromType.instanceOf(BackendPointerType) || to.instanceOf(BackendPointerType)
            || fromType.size(this.mod.platform) >= to.size(this.mod.platform));
        int reg = this.nextReg;
        this.output.appendsi("  %reg", reg);
        this.output.append3s(" = ", castType, " ");
        this.outputTreg(from);
        this.output.append(" to ");
        llvmFmtInto(to, output, this.mod.platform);
        this.output.endl;
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int zeroExtend(int value, BackendType to) {
        int reg = this.nextReg;
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = zext " ~ treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int signExtend(int value, BackendType to) {
        int reg = this.nextReg;
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = sext " ~ this.treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int trunc(int value, BackendType to) {
        int reg = this.nextReg;
        this.print(
            "%reg" ~ itoa(reg)
            ~ " = trunc " ~ this.treg(value)
            ~ " to " ~ llvmFmt(to, this.mod.platform));
        this.defReg2(reg, to, Reg(reg));
        return reg;
    }
    override int intToFloat(int value) {
        int reg = this.nextReg;
        this.print("%reg" ~ itoa(reg) ~ " = sitofp " ~ this.treg(value) ~ " to float");
        this.defReg2(reg, new BackendFloatType, Reg(reg));
        return reg;
    }
    override int floatToInt(int value) {
        int reg = this.nextReg;
        this.print("%reg" ~ itoa(reg) ~ " = fptosi " ~ this.treg(value) ~ " to i32");
        this.defReg2(reg, new BackendFloatType, Reg(reg));
        return reg;
    }
    override int call(BackendType ret, string name, int[] args) {
        if (!mod.declared(name)) { .print(name ~ " not declared"); assert(false); }
        int reg = this.nextReg;
        auto type = this.mod.globalType(name).instanceOf(BackendFunctionPointerType);
        assert(!!type);
        string coerceReg(int i) {
            return "%reg" ~ itoa(reg) ~ ".coerce" ~ itoa(i);
        }
        string retReg() {
            return "%reg" ~ itoa(reg) ~ ".ret";
        }
        for (int i <- 0 .. args.length) {
            if (passByMemory(type.args[i], this.mod.platform)) {
                string coerceReg = coerceReg(i);
                string typeFmt = llvmFmt(type.args[i], this.mod.platform);
                staticAllocas ~= StaticAlloca(coerceReg, type.args[i]);
                this.print("store " ~ this.treg(args[i]) ~ ", " ~ typeFmt ~ "* " ~ coerceReg);
            }
        }
        string retFmt = llvmFmt(ret, this.mod.platform);
        bool sret = passByMemory(ret, this.mod.platform);
        if (sret) {
            staticAllocas ~= StaticAlloca(retReg, ret);
        }
        mut string argstr = "(";
        if (sret) {
            argstr ~= retFmt ~ "* sret " ~ retReg;
            if (args.length) argstr ~= ", ";
        }
        for (int i <- 0 .. args.length) {
            if (i) argstr ~= ", ";
            if (passByMemory(type.args[i], this.mod.platform))
                argstr ~= llvmFmt(type.args[i], this.mod.platform) ~ "* byval " ~ coerceReg(i);
            else
                argstr ~= this.treg(args[i]);
        }
        argstr ~= ")";

        string locationKey = this.mod.debugInfo("!DILocation(line: 0, column: 0, scope: " ~ this.debugSubProgram ~ ")");
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void @" ~ name ~ argstr ~ ", !dbg " ~ locationKey);
        } else if (sret) {
            this.print("call void @" ~ name ~ argstr ~ ", !dbg " ~ locationKey);
            this.defReg2(reg, ret, Reg(reg));
        } else {
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = call " ~ retFmt ~ " @" ~ name ~ argstr ~ ", !dbg " ~ locationKey);
            this.defReg2(reg, ret, Reg(reg));
        }
        if (sret)
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = load " ~ retFmt ~ ", " ~ retFmt ~ "* " ~ retReg);
        return reg;
    }
    override int getFuncPtr(string name) {
        auto type = this.mod.globalType(name);

        return this.defReg(type, "@" ~ name);
    }
    // TODO merge with call()
    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType);
        assert(!!backendFpType);
        auto ret = backendFpType.ret;
        int reg = this.nextReg;
        string coerceReg(int i) {
            return "%reg" ~ itoa(reg) ~ ".coerce" ~ itoa(i);
        }
        string retReg() {
            return "%reg" ~ itoa(reg) ~ ".ret";
        }
        for (int i <- 0 .. args.length) {
            if (passByMemory(backendFpType.args[i], this.mod.platform)) {
                string coerceReg = coerceReg(i);
                string typeFmt = llvmFmt(backendFpType.args[i], this.mod.platform);
                staticAllocas ~= StaticAlloca(coerceReg, backendFpType.args[i]);
                this.print("store " ~ this.treg(args[i]) ~ ", " ~ typeFmt ~ "* " ~ coerceReg);
            }
        }
        bool sret = passByMemory(ret, this.mod.platform);
        string retFmt = llvmFmt(ret, this.mod.platform);
        if (sret) staticAllocas ~= StaticAlloca(retReg, ret);
        string locationKey = this.mod.debugInfo("!DILocation(line: 0, column: 0, scope: " ~ this.debugSubProgram ~ ")");
        if (ret.instanceOf(BackendVoidType)) {
            this.output.appends("  call void ");
            this.outputReg(callReg);
        } else if (sret) {
            this.output.appends("  call void ");
            this.outputReg(callReg);
            this.defReg2(reg, ret, Reg(reg));
        } else {
            this.output.appendsis("  %reg", reg, " = call ");
            llvmFmtInto(ret, this.output, this.mod.platform);
            this.output.appends(" ");
            this.outputReg(callReg);
            this.defReg2(reg, ret, Reg(reg));
        }
        output.append("(");
        if (sret) {
            llvmFmtInto(backendFpType.ret, this.output, this.mod.platform);
            this.output.append2s("* sret ", retReg);
            if (args.length) this.output.appends(", ");
        }
        for (int i <- 0 .. args.length) {
            if (i) output.append(", ");
            if (passByMemory(backendFpType.args[i], this.mod.platform)) {
                llvmFmtInto(backendFpType.args[i], this.output, this.mod.platform);
                this.output.append2s("* byval ", coerceReg(i));
            }
            else
                this.outputTreg(args[i]);
        }
        this.output.append2s("), !dbg ", locationKey);
        this.output.endl;
        if (sret)
            this.print(
                "%reg" ~ itoa(reg)
                ~ " = load " ~ retFmt ~ ", " ~ retFmt ~ "* " ~ retReg);
        return reg;
    }
    override int load(BackendType backendType, int source) {
        int reg = this.nextReg;
        if (backendType.instanceOf(BackendVoidType)) {
            // fake reg
            this.defReg2(reg, backendType, "VOID");
            return reg;
        }
        string typeFmt = llvmFmt(backendType, this.mod.platform);
        this.output.appendsi("  %reg", reg);
        this.output.append6s(" = load ", typeFmt, ", ", typeFmt, "* ", this.reg(source));
        this.output.endl;
        this.defReg2(reg, backendType, Reg(reg));
        return reg;
    }
    override int staticAlloca(BackendType backendType) {
        int reg = this.nextReg;
        this.staticAllocas ~= StaticAlloca(reg, backendType);
        this.defReg2(reg, new BackendPointerType(backendType), Reg(reg));
        if (!backendType.instanceOf(BackendVoidType)) {
            string typefmt = llvmFmt(backendType, this.mod.platform);
            // TODO zeroLiteral
            this.print("store " ~ typefmt ~ " zeroinitializer, " ~ typefmt ~ "* %reg" ~ itoa(reg));
        }
        return reg;
    }
    override int field(BackendType backendType, int source, size_t index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg = this.nextReg;
        this.output.appendsis("  %reg", reg, " = extractvalue ");
        this.outputTreg(source);
        this.output.appendsi(", ", index);
        this.output.endl;
        this.defReg2(reg, backendStructType.members[index], Reg(reg));
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg1 = this.bitcast(source, new BackendPointerType(backendType));
        int reg2 = this.nextReg;
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append(", ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append("* ");
        this.output.appendsi("%reg", reg1);
        this.output.appendsi(", i32 0, i32 ", index);
        this.output.endl;
        this.defReg2(reg2, new BackendPointerType(backendStructType.members[index]), Reg(reg2));
        return reg2;
    }
    override int ptrOffset(BackendType backendType, int ptrReg, int offsetReg) {
        auto ptrType = new BackendPointerType(backendType);

        int reg1 = this.bitcast(ptrReg, ptrType);
        int reg2 = this.nextReg;
        this.output.appendsi("  %reg", reg2);
        this.output.append(" = getelementptr ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.append(", ");
        llvmFmtInto(ptrType, this.output, this.mod.platform);
        this.output.appendsis(" %reg", reg1, ", ");
        this.outputTreg(offsetReg);
        this.output.endl;
        this.defReg2(reg2, ptrType, Reg(reg2));
        return reg2;
    }
    override void store(BackendType backendType, int target_reg, int value_reg) {
        if (backendType.instanceOf(BackendVoidType)) return;
        this.output.appends("  store ");
        llvmFmtInto(backendType, this.output, this.mod.platform);
        this.output.appends(" ");
        this.outputReg(value_reg);
        this.output.appends(", ");
        this.outputTreg(target_reg);
        this.output.endl;
    }
    override void ret(int reg) {
        bool sret = passByMemory(this.ret_, this.mod.platform);
        if (this.ret_.instanceOf(BackendVoidType)) {
            this.print("ret void");
        } else if (sret) {
            this.print(
                "store " ~ this.treg(reg) ~ ", "
                ~ llvmFmt(this.ret_, this.mod.platform) ~ " *%ret");
            this.print("ret void");
        } else {
            this.print("ret " ~ this.treg(reg));
        }
        this.blockId += 1;
    }
    override void branch(string label) {
        this.print("br label %" ~ label);
        this.blockId += 1;
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg;
        this.print("%reg" ~ itoa(testReg) ~ " = icmp ne i32 " ~ this.reg(reg) ~ ", 0");
        this.print("br i1 %reg" ~ itoa(testReg) ~ ", label %" ~ thenLabel ~ ", label %" ~ elseLabel);
        this.blockId += 1;
    }
    override void done() {
        mut string argstr = "(";
        this.print("unreachable");
        bool sret = passByMemory(this.ret_, this.mod.platform);
        string retFmt = llvmFmt2(this.ret_, this.mod.platform, true);
        if (sret) {
            argstr ~= retFmt ~ "* sret %ret";
            if (this.args.length) argstr ~= ", ";
        }
        for (int i <- 0 .. this.args.length) {
            if (i) argstr = argstr ~ ", ";
            if (passByMemory(this.args[i], this.mod.platform))
                argstr ~= llvmFmt(this.args[i], this.mod.platform)
                    ~ "* byval %arg" ~ itoa(i) ~ ".coerce";
            else
                argstr ~= llvmFmt(this.args[i], this.mod.platform) ~ " %arg" ~ itoa(i);
        }
        mut string retstr;
        if (sret)
            retstr = "void";
        else
            retstr = retFmt;
        argstr = argstr ~ ")";

        string dbgKey = " !dbg " ~ this.debugSubProgram;

        this.mod.output.print("define " ~ retstr ~ " @" ~ this.name ~ argstr ~ dbgKey ~ " {");
        for (int i <- 0 .. this.args.length) {
            string argFmt = llvmFmt(this.args[i], this.mod.platform);
            if (passByMemory(this.args[i], this.mod.platform))
                this.mod.output.print(
                    "%arg" ~ itoa(i)
                    ~ " = load " ~ argFmt ~ ", " ~ argFmt ~ "* %arg" ~ itoa(i) ~ ".coerce");
        }
        for (int i <- 0 .. this.staticAllocas.length) {
            auto reg = this.staticAllocas[i].reg;
            auto type = this.staticAllocas[i].type;
            if (type.instanceOf(BackendVoidType)) continue;
            string typefmt = llvmFmt(type, this.mod.platform);
            this.mod.output.print(reg.case(string s: s, int i: "%reg" ~ itoa(i)) ~ " = alloca " ~ typefmt);
        }
        {
            auto funtext = this.output.text;
            this.mod.output.print(funtext);
        }
        this.mod.output.print("}");
    }
}

class LineWriter
{
    string buffer;
    size_t used;
    this() {
        this.buffer = new string(128);
    }
    void appends(string msg) {
        this.expand(this.used + msg.length);
        memcpy(&this.buffer[this.used], msg.ptr, msg.length);
        this.used = this.used + msg.length;
    }
    void appendi(mut long i) {
        if (i == 0) {
            this.appends("0");
            return;
        }
        if (i < 0)
        {
            this.appends("-");
            appendi(0 - i);
            return;
        }
        mut int k = 1;
        while (k <= i) k *= 10;
        while (k >= 10)
        {
            k /= 10;
            size_t digit = i / k;
            this.appends("0123456789"[digit .. digit + 1]);
            i -= digit * k;
        }
    }
    void expand(size_t newLength) {
        while (newLength > this.buffer.length)
        {
            size_t newBufLen = this.buffer.length * 2;
            auto newBuf = new string(newBufLen);
            for (int i <- 0 .. this.used) newBuf[i] = this.buffer[i];
            this.buffer = newBuf;
        }
    }
    string text() {
        return this.buffer[0 .. this.used];
    }
    void print(string msg) {
        this.appends(msg);
        this.endl;
    }
    void appendsi(string s, long l)
    {
        this.appends(s);
        this.appendi(l);
    }
    void appendsis(string s1, int i, string s2)
    {
        this.appends(s1);
        this.appendi(i);
        this.appends(s2);
    }
    void append(string a)
    {
        this.appends(a);
    }
    void append2s(string a, string b)
    {
        this.appends(a);
        this.appends(b);
    }
    void append3s(string a, string b, string c)
    {
        this.appends(a);
        this.appends(b);
        this.appends(c);
    }
    void append5s(string a, string b, string c, string d, string e)
    {
        this.appends(a);
        this.appends(b);
        this.appends(c);
        this.appends(d);
        this.appends(e);
    }
    void append6s(string a, string b, string c, string d, string e, string f)
    {
        this.append5s(a, b, c, d, e);
        this.appends(f);
    }
    void endl() {
        this.appends("\n");
    }
}

void llvmFmtInto(BackendType type, LineWriter output, Platform platform) {
    return type.llvmFmtInto2(output, platform, false);
}

void llvmFmtInto2(BackendType type, LineWriter output, Platform platform, bool returnType)
{
    if (type.instanceOf(BackendLongType)) { output.append("i64"); return; }
    if (type.instanceOf(BackendIntType)) { output.append("i32"); return; }
    if (type.instanceOf(BackendShortType)) { output.append("i16"); return; }
    if (type.instanceOf(BackendCharType)) { output.append("i8"); return; }
    if (type.instanceOf(BackendFloatType)) { output.append("float"); return; }
    if (type.instanceOf(BackendDoubleType)) { output.append("double"); return; }
    if (type.instanceOf(BackendVoidType)) {
        if (returnType) output.append("void");
        else output.append("{}");
        return;
    }
    auto backendSpacerType = type.instanceOf(BackendSpacerType);
    if (backendSpacerType) {
        output.append("[");
        output.append(ltoa(backendSpacerType.size_));
        output.append(" x i8]");
        return;
    }
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            output.append("i8*");
            return;
        }
        llvmFmtInto2(backendPointerType.target, output, platform, false);
        output.append("*");
        return;
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        output.append("{ ");
        for (int i <- 0 .. backendStructType.members.length) {
            if (i) output.append(", ");
            llvmFmtInto2(backendStructType.members[i], output, platform, false);
        }
        output.append(" }");
        return;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        bool sret = passByMemory(backendFpType.ret, platform);
        if (sret)
            output.append("void");
        else
            llvmFmtInto2(backendFpType.ret, output, platform, true);
        output.append("(");
        if (sret) {
            llvmFmtInto2(backendFpType.ret, output, platform, true);
            if (backendFpType.args.length) output.append("*,");
            else output.append("*");
        }
        for (int i <- 0 .. backendFpType.args.length) {
            if (i) output.append(", ");
            if (passByMemory(backendFpType.args[i], platform)) {
                llvmFmtInto2(backendFpType.args[i], output, platform, false);
                output.appends("*");
            } else
                llvmFmtInto2(backendFpType.args[i], output, platform, false);
        }
        output.append(")*");
        return;
    }
    auto backendSAtype = type.instanceOf(BackendStaticArrayType);
    if (backendSAtype) {
        output.append("[");
        output.append(itoa(backendSAtype.length));
        output.append(" x ");
        llvmFmtInto2(backendSAtype.element, output, platform, false);
        output.append("]");
        return;
    }
    print(type.repr);
    assert(false);
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = platform.voidp;
    BackendType sizet = platform.nativeWordType;
    {
        auto argTypes = new BackendType[](5);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        argTypes[3] = sizet;
        argTypes[4] = sizet;
        mod.declare("_arraycmp", new BackendIntType, argTypes);
    }
    {
        auto argTypes = new BackendType[](3);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        mod.declare("memcpy", voidp, argTypes);
    }
    mod.declare("cxruntime_ptr_test", new BackendIntType, [voidp]);
    mod.declare("cxruntime_alloc", voidp, [sizet]);
}
