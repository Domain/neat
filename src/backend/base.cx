module backend.base;

import helpers;

class BackendFunction
{
    int arg(int index) { assert(false); }
    // TODO trunc
    int shortLiteral(int value) { assert(false); }
    int byteLiteral(int value) { assert(false); }
    int intLiteral(long value) { assert(false); }
    int longLiteral(long value) { assert(false); }
    int wordLiteral(Platform platform, long value) { assert(false); }
    int floatLiteral(float value) { assert(false); }
    int stringLiteral(string text) { assert(false); }
    int voidLiteral() { assert(false); }
    int symbolList(string name) { assert(false); }
    int binop(string op, BackendType type, int left, int right) { assert(false); }
    int bitcast(int from, BackendType to) { assert(false); }
    int zeroExtend(int value, BackendType from, BackendType to) { assert(false); }
    int signExtend(int value, BackendType from, BackendType to) { assert(false); }
    int intToFloat(int reg) { assert(false); }
    int call(BackendType ret, string name, int[] args) { assert(false); }
    int getFuncPtr(string name) { assert(false); }
    int callFuncPtr(BackendType type, int reg, int[] args) { assert(false); }
    int load(BackendType backendType, int reg) { assert(false); }
    int alloca(BackendType backendType) { assert(false); }
    int field(BackendType backendType, int reg, int index) { assert(false); }
    int fieldOffset(BackendType backendType, int reg, int index) { assert(false); }
    int saveStack() { assert(false); }
    void restoreStack(int stack) { assert(false); } // allocas between saveStack and here are freed!
    void store(BackendType backendType, int target_reg, int value_reg) { assert(false); }
    void ret(int reg) { assert(false); }
    void branch(string label) { assert(false); }
    void testBranch(int reg, string thenLabel, string elseLabel) { assert(false); }
    void setLabel(string label) { assert(false); }
    string getLabel() { assert(false); }
    // call when the function is finished
    void done() { }
}

class BackendModule
{
    string[] alreadySeen;

    void declare(string name, bool extern_, BackendType ret, BackendType[] args) { assert(false); }
    BackendFunction define(string name, BackendType ret, BackendType[] args) { assert(false); }
    void defineSymbolList(string name, string[] symbols) { assert(false); }
    void callMacroFun(string name, void* ptr) { assert(false); }

    // allow to only emit a symbol once per module
    bool once(string identifier)
    {
        // TODO use a hash
        for (int i = 0; i < this.alreadySeen.length; i += 1)
            if (this.alreadySeen[i] == identifier)
                return false;
        this.alreadySeen ~= identifier;
        return true;
    }
}

class Backend
{
    BackendModule createModule(Platform platform) { assert(false); }
}

class Platform {
    BackendType nativeWordType() { assert(false); }
}

class DefaultPlatform : Platform
{
    BackendType type;
    this(bool x86_32) {
        if (x86_32) this.type = new BackendIntType;
        else this.type = new BackendLongType;
    }
    override BackendType nativeWordType() { return this.type; }
}

class BackendType
{
    string repr() { assert(false); }
    int size(Platform platform) { assert(false); }
    int alignment(Platform platform) { assert(false); }
    bool same(BackendType other) { assert(false); }
}

class BackendLongType : BackendType
{
    this() { }
    override string repr() { return "long"; }
    override int size(Platform platform) { return 8; }
    override int alignment(Platform platform) { return 8; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendLongType); }
}

class BackendIntType : BackendType
{
    this() { }
    override string repr() { return "int"; }
    override int size(Platform platform) { return 4; }
    override int alignment(Platform platform) { return 4; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendIntType); }
}

class BackendShortType : BackendType
{
    this() { }
    override string repr() { return "short"; }
    override int size(Platform platform) { return 2; }
    override int alignment(Platform platform) { return 2; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendShortType); }
}

class BackendCharType : BackendType
{
    this() { }
    override string repr() { return "char"; }
    override int size(Platform platform) { return 1; }
    override int alignment(Platform platform) { return 1; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendCharType); }
}

class BackendVoidType : BackendType
{
    this() { }
    override string repr() { return "void"; }
    override int size(Platform platform) { return 0; }
    override int alignment(Platform platform) { return 1; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendVoidType); }
}

class BackendFloatType : BackendType
{
    this() { }
    override string repr() { return "float"; }
    override int size(Platform platform) { return 4; }
    override int alignment(Platform platform) { return 4; }
    override bool same(BackendType other) { return !!other.instanceOf(BackendFloatType); }
}

class BackendPointerType : BackendType
{
    BackendType target;

    this(BackendType target) { this.target = target; }

    override string repr() { return this.target.repr() ~ "*"; }
    override int size(Platform platform) { return platform.nativeWordType().size(platform); }
    override int alignment(Platform platform) { return platform.nativeWordType().size(platform); }
    override bool same(BackendType other) {
        auto otherPtr = other.instanceOf(BackendPointerType);
        return otherPtr && this.target.same(otherPtr.target);
    }
}

class BackendFunctionPointerType : BackendType
{
    BackendType ret;
    BackendType[] args;

    this(BackendType ret, BackendType[] args) {
        this.ret = ret;
        this.args = args;
    }

    override string repr() { return "TODO fp"; }
    override int size(Platform platform) { return platform.nativeWordType().size(platform); }
    override int alignment(Platform platform) { return platform.nativeWordType().size(platform); }
    override bool same(BackendType other) {
        auto otherFp = other.instanceOf(BackendFunctionPointerType);
        if (!otherFp || !this.ret.same(otherFp.ret) || this.args.length != otherFp.args.length)
            return false;
        for (int i = 0; i < this.args.length; i += 1)
            if (!this.args[i].same(otherFp.args[i])) return false;
        return true;
    }
}

class BackendStructType : BackendType
{
    BackendType[] members;

    this(BackendType[] members) { this.members = members; }

    override string repr() { return "TODO struct"; }

    override int size(Platform platform) {
        int size; int alignment;
        calcPrefix(platform, this.members, &size, &alignment);

        return roundToNext(size, alignment);
    }

    override int alignment(Platform platform) {
        int size; int alignment;
        calcPrefix(platform, this.members, &size, &alignment);

        return alignment;
    }

    override bool same(BackendType other) {
        auto otherStr = other.instanceOf(BackendStructType);
        if (!otherStr || this.members.length != otherStr.members.length)
            return false;
        for (int i = 0; i < this.members.length; i += 1)
            if (!this.members[i].same(otherStr.members[i])) return false;
        return true;
    }
}

class BackendSpacerType : BackendType
{
    int size_;
    int alignment_;

    this(int size, int alignment) { this.size_ = size; this.alignment_ = alignment; }

    override string repr() { return "TODO spacer"; }
    override int size(Platform platform) { return this.size_; }
    override int alignment(Platform platform) { return this.alignment_; }
    override bool same(BackendType other) {
        auto otherSpacer = other.instanceOf(BackendSpacerType);
        return otherSpacer && this.size_ == otherSpacer.size_ && this.alignment_ == otherSpacer.alignment_;
    }
}

class BackendStaticArrayType : BackendType
{
    BackendType element;
    int length;

    this(BackendType element, int length) { this.element = element; this.length = length; }

    override string repr() { return element.repr() ~ "[" ~ itoa(length) ~ "]"; }
    override int size(Platform platform) { return element.size(platform) * length; }
    override int alignment(Platform platform) { return this.element.alignment(platform); }
    override bool same(BackendType other) {
        auto otherSA = other.instanceOf(BackendStaticArrayType);
        return otherSA && this.length == otherSA.length && this.element.same(otherSA.element);
    }
}

void calcPrefix(Platform platform, BackendType[] members, int* structSize, int* structAlign)
{
    *structSize = 0;
    *structAlign = 1;
    for (int i = 0; i < members.length; i += 1) {
        auto member = members[i];
        int alignment = member.alignment(platform);
        int size = member.size(platform);
        // round to next <alignment>
        *structSize = roundToNext(*structSize, alignment) + size;
        if (alignment > *structAlign) *structAlign = alignment;
    }
}

int roundToNext(int size, int alignment)
{
    size = size + alignment - 1;
    // alignment is a power of two, so alignment - 1 is a mask
    // size -= size % alignment;
    size = size - (size & (alignment - 1));
    return size;
}
