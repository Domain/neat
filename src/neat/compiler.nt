module neat.compiler;

macro import neat.macros.assert;
macro import neat.macros.listcomprehension;
macro import neat.macros.once;

import backend.base;
import neat.array;
import neat.base;
import neat.class_;
import neat.either;
import neat.expr;
import neat.function_;
import neat.parser_base;
import neat.statements;
import neat.struct_;
import neat.stuff;
import neat.tuples;
import neat.types;
import std.thread;

/**
 * This class pulls together all the Neat compiler functionality into one class.
 * It is passed around everywhere to break module dependency loops.
 */
class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    ParserHelper helper;

    ModuleParserConfig modParseConfig;

    Mutex mutex;

    this(this.defaultImports, this.modParseConfig, this.cFlags, this.workPool) {
        this.mutex = new Mutex;
    }

    CachedRuntimeFunction[] cachedRuntimeFunctions;

    // break reference cycles to avoid leaks
    void clear() {
        this.cachedRuntimeFunctions = [];
        this.defaultImports = [];
    }

    // parser
    override (nullable ASTSymbol | fail Error) parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser, lexicalContext);
    }

    override (nullable ASTSymbol | fail Error) parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser, lexicalContext);
    }

    override (ASTStatement | fail Error) parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser, lexicalContext);
    }

    override (nullable ASTDeclaration | fail Error) parseDeclaration(Parser parser, LexicalContext lexicalContext)
    {
        return .parseDeclaration(parser, lexicalContext);
    }

    override (nullable ASTSymbol | fail Error) parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser, lexicalContext);
    }

    override (ASTSymbol | fail Error) parseStringLiteral(
        Parser parser, LexicalContext lexicalContext, string endMarker, LocRange from)
    {
        return .parseStringLiteral(parser, lexicalContext, endMarker, from);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, LocRange locRange)
    {
        return new ASTBinaryOp(op, left, right, locRange);
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, LocRange locRange)
    {
        return new ASTIndexAccess(base, index, locRange);
    }

    override ASTSymbol astMember(ASTSymbol base, string member, LocRange locRange)
    {
        return new ASTMember(base, member, locRange);
    }

    override ASTSymbol astReference(ASTSymbol value, LocRange locRange)
    {
        return new ASTReference(value, locRange);
    }

    override ASTSymbol astDereference(ASTSymbol value, LocRange locRange)
    {
        return new ASTDereference(value, locRange);
    }

    override ASTSymbol astIntLiteral(int value, LocRange locRange)
    {
        return new ASTIntLiteral(value, locRange);
    }

    override ASTSymbol astLongLiteral(long value, LocRange locRange)
    {
        return new ASTLongLiteral(value, locRange);
    }

    override ASTSymbol astStringLiteral(string text, LocRange locRange)
    {
        return new ASTStringLiteral(text, locRange);
    }

    override ASTSymbol astArrayLiteralTypeHint(nullable ASTSymbol typeHint, ASTSymbol[] values, LocRange locRange)
    {
        auto elements = [ASTArrayLiteralElement(value, locRange) for value in values];
        return new ASTArrayLiteral(typeHint, elements);
    }

    override ASTSymbol astTupleLiteral(ASTSymbol[] entries, LocRange locRange)
    {
        return new ASTTupleExpr(entries, locRange);
    }

    override ASTSymbol astIota(ASTSymbol from, ASTSymbol to, LocRange locRange) {
        return new ASTIota(from, to, locRange);
    }

    override ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, LocRange locRange)
    {
        return new ASTArraySlice(array, lower, upper, locRange);
    }

    override ASTSymbol astVoidLiteral(LocRange locRange)
    {
        return new ASTVoidExpression(locRange);
    }

    override ASTSymbol astIdentifier(string name, LocRange locRange)
    {
        return new ASTIdentifier(name, false, locRange);
    }

    override ASTSymbol astNegation(ASTSymbol value, LocRange locRange)
    {
        return new ASTNegation(value, locRange);
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, LocRange locRange)
    {
        return new ASTCall(
            target,
            [ASTArgument(sym, "", sym.locRange) for sym in args],
            locRange);
    }

    override ASTSymbol astNewExpression(ASTSymbol type, (ASTSymbol[] | ASTArgument[]) args, LocRange locRange) {
        auto arguments = args.case(
            ASTArgument[] a: a,
            ASTSymbol[] s: [ASTArgument(sym, "", sym.locRange) for sym in s]);

        return new ASTNewExpression(type, arguments, locRange);
    }

    override ASTSymbol astDestroy(ASTSymbol target, LocRange locRange)
    {
        return new ASTDestroy(target, locRange);
    }

    override ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, LocRange locRange)
    {
        return new ASTStatementExpression(statements, expr, locRange);
    }

    override ASTSymbol astCast(ASTSymbol target, ASTSymbol value, LocRange locRange)
    {
        return new ASTCastExpr(target, value, locRange);
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, LocRange locRange)
    {
        return new ASTExprStatement(expr, locRange);
    }

    override ASTStatement astScope(ASTStatement[] statements, LocRange locRange)
    {
        return new ASTScopeStatement(statements, locRange);
    }

    override ASTStatement astSequence(ASTStatement[] statements, LocRange locRange)
    {
        return new ASTSequenceStatement(statements, locRange);
    }

    override ASTStatement astIf((ASTSymbol | ASTStatement) test, ASTStatement then, nullable ASTStatement else_, LocRange locRange)
    {
        test.case {
            ASTSymbol sym: return new ASTIfStatement(sym, then, else_, locRange);
            ASTStatement stmt: {
                if (auto vardecl = stmt.instanceOf(ASTVarDeclStatement))
                    return new ASTIfStatement(vardecl, then, else_, locRange);
                else if (auto extractdecl = stmt.instanceOf(ASTVarExtractDeclStatement))
                    return new ASTIfStatement(extractdecl, then, else_, locRange);
                else assert(false);
            }
        }
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, LocRange locRange)
    {
        return new ASTForLoop(init, test, step, body_, locRange);
    }

    override ASTStatement astExtForLoop(
        ASTSymbol source, ExtForVarDecl var1, (ExtForVarDecl | :none) var2, ASTStatement body_, LocRange locRange)
    {
        return new ASTExtForLoop(source, var1, var2, body_, locRange);
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, LocRange locRange)
    {
        return new ASTAssignStatement(target, source, locRange);
    }

    override ASTStatement astDeclareVar(
        string name, bool mutable, bool uninitialized, nullable ASTSymbol initial, LocRange locRange)
    {
        return new ASTVarDeclStatement(name, mutable, true, uninitialized=uninitialized, null, initial, locRange);
    }

    override ASTStatement astDeclareTypedVar(
        string name, bool mutable, bool uninitialized, ASTSymbol type, nullable ASTSymbol initial, LocRange locRange)
    {
        return new ASTVarDeclStatement(name, mutable, false, uninitialized=uninitialized, type, initial, locRange);
    }

    override ASTStatement astDeclareVarExtract(
        string name, bool mutable, bool infer, nullable ASTSymbol type, ASTSymbol source, LocRange locRange)
    {
        return new ASTVarExtractDeclStatement(name, mutable, infer, type, source, locRange);
    }

    override ASTStatement astReturn(ASTSymbol value, LocRange locRange)
    {
        return new ASTReturnStatement(value, locRange);
    }

    override ASTSymbol astArray(ASTSymbol elementType, LocRange locRange)
    {
        return new ASTArray(elementType, locRange);
    }

    override ASTSymbol astBasicType(string name, LocRange locRange)
    {
        return new ASTBasicType(name, locRange);
    }

    override ASTSymbol astTypeOf(ASTSymbol value, LocRange locRange)
    {
        return new ASTTypeof(value, locRange);
    }

    override ASTSymbol astPointer(ASTSymbol target, LocRange locRange)
    {
        return new ASTPointer(target, locRange);
    }

    override ASTSymbol astTupleType((string name, ASTSymbol type)[] members, LocRange locRange)
    {
        return new ASTTupleType(members, locRange);
    }

    override ASTSymbol astNullable(ASTSymbol next, bool nullify, LocRange locRange)
    {
        return new ASTNullable(next, nullify, locRange);
    }

    override ASTExternFunctionBase astExternFunction(
        string name, ASTSymbol ret, ASTParameter[] params, bool variadic, LocRange retLocRange)
    {
        return new ASTExternFunction(name, ret, params, variadic, retLocRange);
    }

    override ASTModule astModule(
        string name, Package pak, MacroState macroState, LocRange locRange, nullable ASTModuleBase parent)
    {
        if (!parent) return new ASTModule(name, pak, macroState, locRange, null);
        return new ASTModule(name, pak, macroState, locRange, parent.instanceOf(ASTModule));
    }

    override ASTDeclaration astImport(ASTImportStatement import_, ASTModuleBase module_, LocRange locRange)
    {
        return new ASTImport(import_, module_.instanceOf(ASTModule).notNull);
    }

    override ASTModuleBase resolveImport(string pak, ASTImportStatement import_, LocRange locRange)
    {
        .resolveImport(this, pak, import_, this.helper, this.modParseConfig).case {
            ASTModule mod: return mod;
            Error error: assert(false);
        }
    }

    // expressions and statements
    override nullable Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        return .implicitConvertTo(context, from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression wordLiteral(Platform platform, long value) {
        return new WordLiteral(this.nativeWordType(platform), value);
    }

    override Expression boolLiteral(bool value) { return new BoolLiteral(value); }

    override Expression voidLiteral() { return new VoidExpression; }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Reference stackFrame(Type type) {
        return new StackFrame(type);
    }

    override (nullable Expression | fail Error) plainCall(Context context, Symbol sym, Expression[] args, LocRange locRange,
        bool isImplCall)
    {
        .plainCall(context, sym, args, locRange, isImplCall)?.case {
            (Expression expr, CallQuality quality): return expr;
            (:argCastError, Error): return null;
            (:mismatch): return null;
        }
    }

    override (nullable Expression | fail Error) call(Context context, ASTSymbol target, ASTArgument[] args, LocRange locRange,
        bool isImplCall)
    {
        if (isImplCall && !target.instanceOf(ASTSymbolHelper).symbol.previewCanCallImplicit)
            return null;
        return .call(context, target, args, locRange, isImplCall);
    }

    override Expression mkCall(Symbol target, Expression[] args, LocRange locRange) {
        if (auto decl = target.instanceOf(FunctionDeclaration))
            return new Call(decl, args, locRange);
        assert(false);
    }

    override (Expression | fail Error) binaryOp(string op, Context context, Expression left, Expression right, LocRange locRange)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, locRange);
        }
        return new BinaryOp(op, left, right, locRange);
    }

    override (Expression | fail Error) truthy(Context context, Expression value, LocRange locRange)
    {
        return .truthy(context, value, locRange);
    }

    override Expression castTo(Type target, Expression source)
    {
        return new CastExpr(target, source);
    }

    override Expression wrap(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        return new WrapExpression(before, value, after);
    }

    // wrap, allowing references
    override Expression wrapRef(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        if (auto valueRef = value.instanceOf(Reference))
            return new WrapReference(before, valueRef, after);
        return new WrapExpression(before, value, after);
    }

    override (Expression | fail Error) consume(
        Context context, Expression expr, (Expression | fail Error) delegate(Expression) dg)
    {
        if (expr.info.lifetime != Lifetime.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporary(type, Lifetime.ephemeral);
        auto assign = new InitializeTemporaryStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp)?;
        return wrap(assign, result, cleanup);
    }

    override Statement consumeStmt(Context context, Expression expr, Statement delegate(Expression) dg)
    {
        if (expr.info.lifetime != Lifetime.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporary(type, Lifetime.ephemeral);
        auto assign = new InitializeTemporaryStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp);
        return sequence(assign, sequence(result, cleanup));
    }

    override (nullable Expression | fail Error) consumeTemporary(
        Context context, bool allowRefReturn, Expression expr,
        (nullable Expression | fail Error) delegate(Reference) dg)
    {
        auto type = expr.type;
        auto temp = new PairedTemporary(type, Lifetime.ephemeral);
        auto result = dg(temp)?;
        if (!result) return null;
        auto result = result.notNull;

        bool doCleanup = expr.info.lifetime == Lifetime.gifted;

        Statement assign = new InitializeTemporaryStatement(temp, expr);
        mut nullable Statement cleanup;
        if (doCleanup) {
            cleanup = type.endLifetime(context, temp);
        }
        if (allowRefReturn)
            return wrapRef(assign, result, cleanup);
        return wrap(assign, result, cleanup);
    }

    override (nullable Statement | fail Error) consumeTemporaryStmt(Context context, Expression expr,
        (nullable Statement | fail Error) delegate(Reference) dg)
    {
        auto type = expr.type;
        mut uninitialized Lifetime tempLifetime;
        if (expr.info.lifetime == Lifetime.gifted)
            tempLifetime = Lifetime.ephemeral;
        else
            tempLifetime = expr.info.lifetime; // ephemeral, permanent, lexical

        auto temp = new PairedTemporary(type, tempLifetime);
        auto result = dg(temp)?;
        if (!result) return null;
        auto result = result.notNull;

        Statement assign = new InitializeTemporaryStatement(temp, expr);
        mut nullable Statement cleanup;
        if (tempLifetime == Lifetime.ephemeral) {
            cleanup = type.endLifetime(context, temp);
        }
        return .sequence(.sequence(assign, result), cleanup);
    }

    override (nullable Symbol | fail Error) accessMember(Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
    {
        return .accessMember(context, base, member, locRange, allowUndefined);
    }

    override (nullable Symbol | fail Error) accessMemberWithLifetime(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
    {
        return .accessMemberWithLifetime(context, base, member, locRange, allowUndefined);
    }

    override Reference structMemberReference(Reference base, int index) {
        return new StructMemberReference(base, index);
    }

    override (nullable Symbol | fail Error) lookup(Context context, LocRange locRange, string name)
    {
        return context.namespace.lookup(name, context, locRange);
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression reference(Reference ref_)
    {
        return new ReferenceExpression(ref_);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequence(Statement left, nullable Statement right)
    {
        return .sequence(left, right);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, nullable Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel, initializer, test, body_, step);
    }

    override Statement returnStatement(Expression value) {
        return new ReturnStatement(value);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override (Statement | fail Error) unwindScope(Context context, Namespace target, Statement next)
    {
        return .unwindScope(context, target, next);
    }

    override Namespace symbolAlias(nullable Namespace parent, string name, Symbol value)
    {
        return new SymbolAlias(parent, name, value);
    }

    override DeclarationHolder variableDeclaration(nullable Namespace parent, string name, Type type,
                                                   bool mut, bool borrowed, bool hidden)
    {
        return new VariableDeclaration(parent, name, type, mut=mut, borrowed=borrowed, hidden);
    }

    override (Statement | fail Error) move(Context context, Reference target, Expression source)
    {
        return .move(context, target, source);
    }

    override (nullable Expression | fail Error) exprWithScratchspace(
        Type type, bool temporary, (nullable Statement | fail Error) delegate(Reference) callback)
    {
        mut uninitialized Lifetime tempLifetime;
        if (temporary) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(type, tempLifetime);
        auto initialize = new UninitializeTemporaryStatement(temp);
        auto stmt = callback(temp)?;
        if (!stmt) return null;
        auto stmt = stmt.notNull;
        return wrap(sequence(initialize, stmt), temp, null);
    }

    override (nullable Statement | fail Error) stmtWithTemporary(
        Expression value, (nullable Statement | fail Error) delegate(Reference) callback)
    {
        mut uninitialized Lifetime tempLifetime;
        if (value.info.lifetime == Lifetime.gifted) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(value.type, tempLifetime);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto stmt = callback(temp)?;
        if (!stmt) return null;
        auto stmt = stmt.notNull;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | fail Error) exprWithTemporary(
        Expression value, (nullable Expression | fail Error) delegate(Reference) callback)
    {
        // TODO: the way gifted works here is almost certainly wrong,
        // cause the Reference can be read multiple times - that's
        // what it's for.
        mut uninitialized Lifetime tempLifetime;
        if (value.info.lifetime == Lifetime.gifted) tempLifetime = Lifetime.gifted;
        else tempLifetime = Lifetime.lexical;

        auto temp = new PairedTemporary(value.type, tempLifetime);
        auto start = new InitializeTemporaryStatement(temp, value);
        auto expr = callback(temp)?;
        if (!expr) return null;
        auto expr = expr.notNull;
        return new StatementExpression(start, expr, false);
    }

    override (nullable Statement | fail Error) stmtWithTemporaryExpr(
        Expression value, (nullable Statement | fail Error) delegate(Expression) callback)
    {
        // TODO: does endLifetime *really* need to take a Reference?
        // cause that's the only reason we need to stmtWithTemporary here.
        if (value.info.lifetime == Lifetime.gifted) {
            (nullable Statement | fail Error) do_(Reference ref_) {
                return callback(ref_);
            }
            return stmtWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.lifetime);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto stmt = callback(temp)?;
        if (!stmt) return null;
        auto stmt = stmt.notNull;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | fail Error) exprWithTemporaryExpr(
        Expression value, (nullable Expression | fail Error) delegate(Expression) callback)
    {
        // see above
        if (value.info.lifetime == Lifetime.gifted) {
            (nullable Expression | fail Error) do_(Reference ref_) {
                return callback(ref_);
            }
            return exprWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.lifetime);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        auto expr = callback(temp)?;
        if (!expr) return null;
        auto expr = expr.notNull;
        return new StatementExpression(start, expr, false);
    }

    override Expression referenceFunction(FunctionDeclaration decl)
    {
        return new FunctionReference(decl);
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression, false);
    }

    override (void | fail Error) addDefaultImports(Context context, ModuleBase module_)
    {
        (Module | fail Error) compile(ASTModule astMod) {
            auto context = makeContext(this, context.platform, null, astMod.macroState, context.modulePostProcessor);
            return .compileModule(context, astMod, addDefaultImports=false);
        }
        auto defaultMods = [compile(mod)? for mod in this.defaultImports];
        [module_.addImport(mod, public_=false, []) for mod in defaultMods];
    }

    override ModuleBase createModule(string name, string mangle, LocRange locRange, nullable ModuleBase parent) {
        mut nullable Module parentMod = null;
        if (parent) parentMod = parent.instanceOf(Module);
        return new Module(name, mangle, locRange, parentMod);
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Parameter[] params, ASTStatement delegate() makeBody)
    {
        // TODO in Function
        mut string mangledName = name ~ "_" ~ ret.mangle;
        for (param in params) {
            mangledName ~= "_" ~ param.type.mangle;
        }
        with (this.mutex.locked) {
            for (entry in cachedRuntimeFunctions) {
                if (entry.fun.name == mangledName && entry.platformIdent == context.platform.ident) {
                    auto usingMod = findParent!Module(context.namespace);
                    usingMod.addImport(entry.rtMod, public_=false, []);
                    return entry.fun;
                }
            }
        }

        Parameter parameter(string name, Type type) {
            return Parameter(false, name, false, type);
        }

        auto fun = new Function(mangledName, ret, params, makeBody(), context.macroState, false, __RANGE__);
        auto pak = new Package("rt_" ~ mangledName, "", []);
        auto rtMod = new Module(name, mangleModuleName(name, pak, 0), __RANGE__, null);
        rtMod.register("free", Protection.public_, once new FunctionDeclaration(
            "free", new Void, [parameter("", new Pointer(new Void))]));
        rtMod.register("print", Protection.public_, once new FunctionDeclaration(
            "print", new Void, [parameter("", new Array(new Character))]));
        rtMod.register("neat_runtime_alloc", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_alloc", new Pointer(new Void), [parameter("", context.nativeWordType)]));
        rtMod.register("neat_runtime_refcount_inc", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_refcount_inc", new Void, [
                parameter("label", new Array(new Character)),
                parameter("ptr", new Pointer(new Void))]));
        rtMod.register("neat_runtime_refcount_dec", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                parameter("label", new Array(new Character)),
                parameter("ptr", new Pointer(new Void))]));

        fun.parent = rtMod;
        rtMod.track(fun);
        addDefaultImports(context, rtMod).case {
            void: {}
            Error err: exitWithError!void(err);
        }
        auto usingMod = findParent!Module(context.namespace);
        usingMod.addImport(rtMod, public_=false, []);

        with (this.mutex.locked) {
            cachedRuntimeFunctions ~= CachedRuntimeFunction(fun, rtMod, context.platform.ident);
        }
        // run AFTER module was added to cache, to break dependency loop for recursive types
        rtMod.compile(context).case {
            void: {}
            Error err: exitWithError!void(err);
        }

        return fun;
    }

    override Type nativeWordType(Platform platform)
    {
        BackendType type = platform.nativeWordType;
        if (type.instanceOf(BackendIntType)) return new Integer;
        if (type.instanceOf(BackendLongType)) return new Long;
        assert(false);
    }

    override Type struct_(string name, StructMemberDeclaration[] members, LocRange locRange, string manglePrefix)
    {
        return new Struct(name, members, locRange, manglePrefix);
    }

    override bool isClassType(Type type) {
        return type.instanceOf(ClassType) || type.instanceOf(IntfType);
    }

    // called when expr is discarded (usually via ignored return value)
    override (void | fail Error) discardErrorCheck(Expression expr, LocRange locRange) {
        if (auto either = expr.type.instanceOf(Either)) {
            if ([any type.fail for type in either.types]) {
                return locRange.fail("silently discarding failure type");
            }
        }
    }
}

struct CachedRuntimeFunction
{
    FunctionDeclaration fun;

    Module rtMod;

    string platformIdent;
}
