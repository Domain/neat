module neat.compiler;

macro import neat.macros.assert;
macro import neat.macros.listcomprehension;
macro import neat.macros.once;
macro import neat.macros.retfail;

import backend.base;
import neat.array;
import neat.base;
import neat.class_;
import neat.expr;
import neat.function_;
import neat.parser_base;
import neat.statements;
import neat.struct_;
import neat.stuff;
import neat.tuples;
import neat.types;

/**
 * This class pulls together all the Neat compiler functionality into one class.
 * It is passed around everywhere to break module dependency loops.
 */
class CompilerImpl : CompilerBase
{
    ASTModule[] defaultImports;

    ParserHelper helper;

    ModuleParserConfig modParseConfig;

    Mutex mutex;

    this(this.defaultImports, this.modParseConfig, this.cFlags,
        this.workPool) {
        this.mutex = new Mutex;
    }

    CachedRuntimeFunction[] cachedRuntimeFunctions;

    // break reference cycles to avoid leaks
    void clear() {
        this.cachedRuntimeFunctions = [];
        this.defaultImports = [];
    }

    // parser
    override (nullable ASTSymbol | fail Error) parseExpression(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpression(parser, lexicalContext);
    }

    override (nullable ASTSymbol | fail Error) parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
    {
        return .parseExpressionLeaf(parser, lexicalContext);
    }

    override (ASTStatement | fail Error) parseStatement(Parser parser, LexicalContext lexicalContext)
    {
        return .parseStatement(parser, lexicalContext);
    }

    override (nullable ASTDeclaration | fail Error) parseDeclaration(Parser parser, LexicalContext lexicalContext)
    {
        return .parseDeclaration(parser, lexicalContext);
    }

    override (nullable ASTSymbol | fail Error) parseType(Parser parser, LexicalContext lexicalContext)
    {
        return .parseType(parser, lexicalContext);
    }

    override ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, Loc loc)
    {
        return new ASTBinaryOp(op, left, right, loc);
    }

    override ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, Loc loc)
    {
        return new ASTIndexAccess(base, index, loc);
    }

    override ASTSymbol astMember(ASTSymbol base, string member, Loc loc)
    {
        return new ASTMember(base, member, loc);
    }

    override ASTSymbol astReference(ASTSymbol value, Loc loc)
    {
        return new ASTReference(value, loc);
    }

    override ASTSymbol astDereference(ASTSymbol value, Loc loc)
    {
        return new ASTDereference(value, loc);
    }

    override ASTSymbol astIntLiteral(int value, Loc loc)
    {
        return new ASTIntLiteral(value, loc);
    }

    override ASTSymbol astLongLiteral(long value, Loc loc)
    {
        return new ASTLongLiteral(value, loc);
    }

    override ASTSymbol astStringLiteral(string text, Loc loc)
    {
        return new ASTStringLiteral(text, loc);
    }

    override ASTSymbol astArrayLiteralTypeHint(nullable ASTSymbol typeHint, ASTSymbol[] values, Loc loc)
    {
        auto elements = [ASTArrayLiteralElement(value, loc) for value in values];
        return new ASTArrayLiteral(typeHint, elements);
    }

    override ASTSymbol astTupleLiteral(ASTSymbol[] entries, Loc loc)
    {
        return new ASTTupleExpr(loc, entries);
    }

    override ASTSymbol astIota(ASTSymbol from, ASTSymbol to, Loc loc) {
        return new ASTIota(from, to, loc);
    }

    override ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, Loc loc)
    {
        return new ASTArraySlice(array, lower, upper, loc);
    }

    override ASTSymbol astVoidLiteral(Loc loc)
    {
        return new ASTVoidExpression(loc);
    }

    override ASTSymbol astIdentifier(string name, Loc loc)
    {
        return new ASTIdentifier(name, false, loc);
    }

    override ASTSymbol astNegation(ASTSymbol value, Loc loc)
    {
        return new ASTNegation(value, loc);
    }

    override ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, Loc loc)
    {
        return new ASTCall(target, [ASTArgument(sym, "") for sym in args], loc);
    }

    override ASTSymbol astNewExpression(ASTSymbol type, (ASTSymbol[] | ASTArgument[]) args, Loc loc) {
        auto arguments = args.case(
            ASTArgument[] a: a,
            ASTSymbol[] s: [ASTArgument(sym, "") for sym in s]);
        return new ASTNewExpression(type, arguments, loc);
    }

    override ASTSymbol astDestroy(ASTSymbol target, Loc loc)
    {
        return new ASTDestroy(target, loc);
    }

    override ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, Loc loc)
    {
        return new ASTStatementExpression(statements, expr, loc);
    }

    override ASTSymbol astCast(ASTSymbol target, ASTSymbol value, Loc loc)
    {
        return new ASTCastExpr(target, value, loc);
    }

    override ASTStatement astExpressionStmt(ASTSymbol expr, Loc loc)
    {
        return new ASTExprStatement(expr, loc);
    }

    override ASTStatement astScope(ASTStatement[] statements, Loc loc)
    {
        return new ASTScopeStatement(statements, loc);
    }

    override ASTStatement astSequence(ASTStatement[] statements, Loc loc)
    {
        return new ASTSequenceStatement(statements, loc);
    }

    override ASTStatement astIf((ASTSymbol | ASTStatement) test, ASTStatement then, nullable ASTStatement else_, Loc loc)
    {
        test.case {
            ASTSymbol sym: return new ASTIfStatement(sym, then, else_, loc);
            ASTStatement stmt: {
                if (auto vardecl = stmt.instanceOf(ASTVarDeclStatement))
                    return new ASTIfStatement(vardecl, then, else_, loc);
                else if (auto extractdecl = stmt.instanceOf(ASTVarExtractDeclStatement))
                    return new ASTIfStatement(extractdecl, then, else_, loc);
                else assert(false);
            }
        }
    }

    override ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, Loc loc)
    {
        return new ASTForLoop(init, test, step, body_, loc);
    }

    override ASTStatement astExtForLoop(
        ASTSymbol source, ExtForVarDecl var1, (ExtForVarDecl | :none) var2, ASTStatement body_, Loc loc)
    {
        return new ASTExtForLoop(source, var1, var2, body_, loc);
    }

    override ASTStatement astAssign(ASTSymbol target, ASTSymbol source, Loc loc)
    {
        return new ASTAssignStatement(target, source, loc);
    }

    override ASTStatement astDeclareVar(
        string name, bool mutable, bool uninitialized, nullable ASTSymbol initial, Loc loc)
    {
        return new ASTVarDeclStatement(name, mutable, true, uninitialized=uninitialized, null, initial, loc);
    }

    override ASTStatement astDeclareTypedVar(
        string name, bool mutable, bool uninitialized, ASTSymbol type, nullable ASTSymbol initial, Loc loc)
    {
        return new ASTVarDeclStatement(name, mutable, false, uninitialized=uninitialized, type, initial, loc);
    }

    override ASTStatement astDeclareVarExtract(
        string name, bool mutable, bool infer, nullable ASTSymbol type, ASTSymbol source, Loc loc)
    {
        return new ASTVarExtractDeclStatement(name, mutable, infer, type, source, loc);
    }

    override ASTStatement astReturn(ASTSymbol value, Loc loc)
    {
        return new ASTReturnStatement(value, loc);
    }

    override ASTSymbol astArray(ASTSymbol elementType, Loc loc)
    {
        return new ASTArray(elementType, loc);
    }

    override ASTSymbol astBasicType(string name, Loc loc)
    {
        return new ASTBasicType(name, loc);
    }

    override ASTSymbol astTypeOf(ASTSymbol value, Loc loc)
    {
        return new ASTTypeof(value, loc);
    }

    override ASTSymbol astPointer(ASTSymbol target, Loc loc)
    {
        return new ASTPointer(target, loc);
    }

    override ASTSymbol astNullable(ASTSymbol next, bool nullify, Loc loc)
    {
        return new ASTNullable(loc, next, nullify);
    }

    override ASTDeclaration astImport(ASTImportStatement import_, ASTModuleBase module_, Loc loc)
    {
        return new ASTImport(import_, module_.instanceOf(ASTModule).notNull);
    }

    override ASTModuleBase resolveImport(string pak, ASTImportStatement import_, Loc loc)
    {
        .resolveImport(this, pak, import_, this.helper, this.modParseConfig).case {
            ASTModule mod: return mod;
            Error error: assert(false);
        }
    }

    // expressions and statements
    override nullable Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        return .implicitConvertTo(context, from, to);
    }

    override Expression intLiteral(int value) { return new IntLiteral(value); }

    override Expression boolLiteral(bool value) { return new BoolLiteral(value); }

    override Expression voidLiteral() { return new VoidExpression; }

    override Expression stringLiteral(string value) { return new StringLiteral(value); }

    override Reference stackFrame(Type type) {
        return new StackFrame(type);
    }

    override (nullable Expression | fail Error) plainCall(Context context, Symbol sym, Expression[] args, Loc loc,
        bool isImplCall)
    {
        return .plainCall(context, sym, args, loc, isImplCall);
    }

    override (nullable Expression | fail Error) call(Context context, ASTSymbol target, ASTArgument[] args, Loc loc,
        bool isImplCall)
    {
        if (isImplCall && !target.instanceOf(ASTSymbolHelper).symbol.previewCanCallImplicit)
            return null;
        return .call(context, target, args, loc, isImplCall);
    }

    override Expression mkCall(Symbol target, Expression[] args, Loc loc) {
        if (auto decl = target.instanceOf(FunctionDeclaration))
            return new Call(decl, args, loc);
        assert(false);
    }

    override (Expression | fail Error) binaryOp(string op, Context context, Expression left, Expression right, Loc loc)
    {
        if (op == "~")
        {
            return arrayCat(context, left, right, loc);
        }
        return new BinaryOp(op, left, right, loc);
    }

    override (Expression | fail Error) truthy(Context context, Expression value, Loc loc)
    {
        return .truthy(context, value, loc);
    }

    override Expression castTo(Type target, Expression source)
    {
        return new CastExpr(target, source);
    }

    override Expression wrap(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        return new WrapExpression(before, value, after);
    }

    // wrap, allowing references
    override Expression wrapRef(nullable Statement before, Expression value, nullable Statement after)
    {
        if (!before && !after) return value;
        if (auto valueRef = value.instanceOf(Reference))
            return new WrapReference(before, valueRef, after);
        return new WrapExpression(before, value, after);
    }

    override (Expression | fail Error) consume(
        Context context, Expression expr, (Expression | fail Error) delegate(Expression) dg)
    {
        if (expr.info.ownership != Ownership.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporary(type, Ownership.owned);
        auto assign = new InitializeTemporaryStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = retfail dg(temp);
        return wrap(assign, result, cleanup);
    }

    override Statement consumeStmt(Context context, Expression expr, Statement delegate(Expression) dg)
    {
        if (expr.info.ownership != Ownership.gifted)
        {
            return dg(expr);
        }
        auto type = expr.type;
        auto temp = new PairedTemporary(type, Ownership.owned);
        auto assign = new InitializeTemporaryStatement(temp, expr);
        auto cleanup = type.endLifetime(context, temp);
        auto result = dg(temp);
        return sequence(assign, sequence(result, cleanup));
    }

    override (nullable Expression | fail Error) consumeTemporary(
        Context context, bool allowRefReturn, bool mayUnwind, Expression expr,
        (nullable Expression | fail Error) delegate(Reference) dg)
    {
        auto type = expr.type;
        // "owned" by consumeTemporary()
        auto temp = new PairedTemporary(type, Ownership.owned);
        // TODO this is trash, remove auto picking null
        auto result <- dg(temp);
        auto result <- result;

        mut bool doCleanup;
        if (expr.info.ownership == Ownership.gifted) doCleanup = true;

        mut Statement assign = new InitializeTemporaryStatement(temp, expr);
        // if `dg()` may not unwind, it doesn't matter that expr is borrowed
        // since we never hit the unwind cleanup on our "owned" temp.
        if (mayUnwind && expr.info.ownership == Ownership.borrowed) {
            auto copyInto = retfail type.copyInto(context, temp, expr);
            if (copyInto) {
                assign = sequence(new UninitializeTemporaryStatement(temp), copyInto);
                doCleanup = true;
            }
        }
        mut nullable Statement cleanup;
        if (doCleanup) {
            cleanup = type.endLifetime(context, temp);
        }
        if (allowRefReturn)
            return wrapRef(assign, result, cleanup);
        return wrap(assign, result, cleanup);
    }

    override (nullable Statement | fail Error) consumeTemporaryStmt(Context context, Expression expr,
        (nullable Statement | fail Error) delegate(Reference) dg)
    {
        auto type = expr.type;
        /**
         * Gifted expr -> owned temporary (so cleanup on return)
         * Everything else -> non-owned non-gifted temporary (so no cleanup on return or use)
         */
        mut uninitialized Ownership tempOwnership;
        if (expr.info.ownership == Ownership.gifted)
            tempOwnership = Ownership.owned;
        else
            tempOwnership = Ownership.borrowed;

        auto temp = new PairedTemporary(type, tempOwnership);
        // trash!
        auto result <- dg(temp);
        auto result <- result;

        Statement assign = new InitializeTemporaryStatement(temp, expr);
        mut nullable Statement cleanup;
        if (expr.info.ownership == Ownership.gifted) {
            cleanup = type.endLifetime(context, temp);
        }
        return .sequence(.sequence(assign, result), cleanup);
    }

    override (nullable Symbol | fail Error) accessMember(Context context, Symbol base, string member, Loc loc, bool allowUndefined)
    {
        return .accessMember(context, base, member, loc, allowUndefined);
    }

    override (nullable Symbol | fail Error) accessMemberWithLifetime(
        Context context, Symbol base, string member, Loc loc, bool allowUndefined)
    {
        return retfail .accessMemberWithLifetime(context, base, member, loc, allowUndefined);
    }

    override Reference structMemberReference(Reference base, int index) {
        return new StructMemberReference(base, index);
    }

    override (nullable Symbol | fail Error) lookup(Context context, Loc loc, string name)
    {
        auto frame = new ReferenceExpression(new StackFrame(new Void));

        return context.namespace.lookup(name, context, loc, frame);
    }

    override Reference dereference(Expression value)
    {
        return new Dereference(value);
    }

    override Expression reference(Reference ref_)
    {
        return new ReferenceExpression(ref_);
    }

    override Expression pointerOffset(Expression pointer, Expression offset)
    {
        return new PointerOffset(pointer, offset);
    }

    override Statement assignStatement(Reference target, Expression value)
    {
        return new AssignStatement(target, value);
    }

    override Statement sequence(Statement left, nullable Statement right)
    {
        return .sequence(left, right);
    }

    override Statement sequenceStatement(Statement[] stmts)
    {
        return new SequenceStatement(stmts);
    }

    override Statement ifStatement(Expression test, Statement then, nullable Statement else_)
    {
        return new IfStatement(test, then, else_);
    }

    override Statement loopStatement(
        Context context, Statement initializer, Expression test, Statement body_, Statement step)
    {
        return new Loop(context.getLabel, initializer, test, body_, step);
    }

    override Statement returnStatement(Expression value) {
        return new ReturnStatement(value);
    }

    override Statement exprStatement(Expression test)
    {
        return new ExprStatement(test);
    }

    override (Statement | fail Error) unwindScope(Context context, Namespace target, Statement next)
    {
        return .unwindScope(context, target, next);
    }

    override Namespace symbolAlias(nullable Namespace parent, string name, Symbol value)
    {
        return new SymbolAlias(parent, name, value);
    }

    override DeclarationHolder variableDeclaration(nullable Namespace parent, string name, Type type, ExprInfo info, bool hidden)
    {
        return new VariableDeclaration(parent, name, type, info, hidden);
    }

    override (Statement | fail Error) move(Context context, Reference target, Expression source)
    {
        return .move(context, target, source);
    }

    override (nullable Expression | fail Error) exprWithScratchspace(
        Type type, bool temporary, (nullable Statement | fail Error) delegate(Reference) callback)
    {
        mut uninitialized Ownership tempOwnership;
        if (temporary) tempOwnership = Ownership.gifted;
        else tempOwnership = Ownership.owned;

        auto temp = new PairedTemporary(type, tempOwnership);
        auto initialize = new UninitializeTemporaryStatement(temp);
        // trash!!
        auto stmt <- callback(temp);
        auto stmt <- stmt;
        return wrap(sequence(initialize, stmt), temp, null);
    }

    override (nullable Statement | fail Error) stmtWithTemporary(
        Expression value, (nullable Statement | fail Error) delegate(Reference) callback)
    {
        mut uninitialized Ownership tempOwnership;
        if (value.info.ownership == Ownership.gifted) tempOwnership = Ownership.gifted;
        else tempOwnership = Ownership.owned;

        auto temp = new PairedTemporary(value.type, tempOwnership);
        auto start = new InitializeTemporaryStatement(temp, value);
        // trash!!!
        auto stmt <- callback(temp);
        auto stmt <- stmt;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | fail Error) exprWithTemporary(
        Expression value, (nullable Expression | fail Error) delegate(Reference) callback)
    {
        // TODO: the way gifted works here is almost certainly wrong,
        // cause the Reference can be read multiple times - that's
        // what it's for.
        mut uninitialized Ownership tempOwnership;
        if (value.info.ownership == Ownership.gifted) tempOwnership = Ownership.gifted;
        else tempOwnership = Ownership.owned;

        auto temp = new PairedTemporary(value.type, tempOwnership);
        auto start = new InitializeTemporaryStatement(temp, value);
        // garbage!
        auto expr <- callback(temp);
        auto expr <- expr;
        return new StatementExpression(start, expr, false);
    }

    override (nullable Statement | fail Error) stmtWithTemporaryExpr(
        Expression value, (nullable Statement | fail Error) delegate(Expression) callback)
    {
        // TODO: does endLifetime *really* need to take a Reference?
        // cause that's the only reason we need to stmtWithTemporary here.
        if (value.info.ownership == Ownership.gifted) {
            (nullable Statement | fail Error) do_(Reference ref_) {
                return callback(ref_);
            }
            return stmtWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.ownership);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        // utterly disgusting!!
        auto stmt <- callback(temp);
        auto stmt <- stmt;
        return new SequenceStatement([start, stmt]);
    }

    override (nullable Expression | fail Error) exprWithTemporaryExpr(
        Expression value, (nullable Expression | fail Error) delegate(Expression) callback)
    {
        // see above
        if (value.info.ownership == Ownership.gifted) {
            (nullable Expression | fail Error) do_(Reference ref_) {
                return callback(ref_);
            }
            return exprWithTemporary(value, &do_);
        }
        auto temp = new PairedTemporaryExpr(value.type, value.info.ownership);
        auto start = new InitializeTemporaryExprStatement(temp, value);
        // running out of invective!!
        auto expr <- callback(temp);
        auto expr <- expr;
        return new StatementExpression(start, expr, false);
    }

    override Expression referenceFunction(FunctionDeclaration decl)
    {
        return new FunctionReference(decl);
    }

    override Expression statementExpression(Statement statement, Expression expression)
    {
        return new StatementExpression(statement, expression, false);
    }

    override (void | fail Error) addDefaultImports(Context context, ModuleBase module_)
    {
        (Module | fail Error) compile(ASTModule astMod) {
            auto context = makeContext(this, context.platform, null, astMod.macroState);
            return .compileModule(context, astMod, addDefaultImports=false);
        }
        auto defaultMods = [retfail compile(mod) for mod in this.defaultImports];
        [module_.addImport(mod, public_=false, []) for mod in defaultMods];
    }

    override ModuleBase createModule(string name, string mangle, Loc loc, nullable ModuleBase parent) {
        mut nullable Module parentMod = null;
        if (parent) parentMod = parent.instanceOf(Module);
        return new Module(loc, name, mangle, parentMod);
    }

    override FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Parameter[] params, ASTStatement delegate() makeBody)
    {
        // TODO in Function
        mut string mangledName = name ~ "_" ~ ret.mangle;
        for (param in params) {
            mangledName ~= "_" ~ param.type.mangle;
        }
        with (this.mutex.locked) {
            for (entry in cachedRuntimeFunctions) {
                if (entry.fun.name == mangledName && entry.platformIdent == context.platform.ident) {
                    auto usingMod = findParent!Module(context.namespace);
                    usingMod.addImport(entry.rtMod, public_=false, []);
                    return entry.fun;
                }
            }
        }

        Parameter parameter(string name, Type type) {
            return Parameter(false, name, false, type);
        }

        auto fun = new Function(__HERE__, mangledName, ret, params, makeBody(), context.macroState, false);
        auto pak = new Package("rt_" ~ mangledName, "", []);
        auto rtMod = new Module(__HERE__, name, mangleModuleName(name, pak, 0), null);
        rtMod.register("free", Protection.public_, once new FunctionDeclaration(
            "free", new Void, [parameter("", new Pointer(new Void))]));
        rtMod.register("print", Protection.public_, once new FunctionDeclaration(
            "print", new Void, [parameter("", new Array(new Character))]));
        rtMod.register("neat_runtime_alloc", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_alloc", new Pointer(new Void), [parameter("", context.nativeWordType)]));
        rtMod.register("neat_runtime_refcount_inc", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_refcount_inc", new Void, [
                parameter("label", new Array(new Character)),
                parameter("ptr", new Pointer(new Void))]));
        rtMod.register("neat_runtime_refcount_dec", Protection.public_, once new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                parameter("label", new Array(new Character)),
                parameter("ptr", new Pointer(new Void))]));

        fun.parent = rtMod;
        rtMod.track(fun);
        addDefaultImports(context, rtMod).case {
            void: {}
            Error err: assert(false);
        }
        auto usingMod = findParent!Module(context.namespace);
        usingMod.addImport(rtMod, public_=false, []);

        with (this.mutex.locked) {
            cachedRuntimeFunctions ~= CachedRuntimeFunction(fun, rtMod, context.platform.ident);
        }
        // run AFTER module was added to cache, to break dependency loop for recursive types
        rtMod.compile(context).case {
            void: {}
            Error err: assert(false);
        }

        return fun;
    }

    override Type nativeWordType(Platform platform)
    {
        BackendType type = platform.nativeWordType;
        if (type.instanceOf(BackendIntType)) return new Integer;
        if (type.instanceOf(BackendLongType)) return new Long;
        assert(false);
    }

    override Type struct_(string name, StructMemberDeclaration[] members, Loc loc, string manglePrefix)
    {
        return new Struct(name, members, loc, manglePrefix);
    }

    override bool isClassType(Type type) {
        return type.instanceOf(ClassType) || type.instanceOf(IntfType);
    }

    // called when expr is discarded (usually via ignored return value)
    override void discardErrorCheck(Expression expr, Loc loc) {
        if (auto either = expr.type.instanceOf(Either)) {
            if ([any type.fail for type in either.types]) {
                loc.fail("silently discarding failure type");
            }
        }
    }
}

struct CachedRuntimeFunction
{
    FunctionDeclaration fun;

    Module rtMod;

    string platformIdent;
}
