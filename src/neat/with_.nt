module neat.with_;

macro import neat.macros.retfail;

import helpers;
import neat.base;
import neat.parser;
import neat.parser_base;

class WithNamespace : DeclarationHolder, Unwindable
{
    // This can't work!
    // When you do with() { void nested() { accessWithMember; } }, then the
    // lookup will try to access a nonlocal register.
    // We need to localize the reference in the stackframe,
    // by declaring it as an anonymous variable.
    // edit 12-28-021: don't we have a thing for looking up delayed-resolved values now?
    // LatentSymbol/LateSymbol or sth?
    // But I think it still doesn't work cause the temporary won't show up in the stackframe,
    // so we still need to go over a temporary variable.
    Reference temporary;

    Loc loc;

    this(this.parent, this.temporary, this.loc) { this.isContextScope = parent.isContextScope; }

    override (nullable Statement | fail Error) unwind(Context context) {
        if (auto exit = retfail temporary.type.accessMember(
                this.loc, context, temporary, "onExit", Protection.private_)) {
            return context.compiler.exprStatement(retfail exit.beExpressionImplCall(context, this.loc));
        }
        return null;
    }

    override Reference accessDecl(CompilerBase compiler)
    {
        return temporary;
    }

    override (nullable Symbol | fail Error) lookup(string name, Context context, Loc loc, nullable Expression frame)
    {
        auto member <- context.compiler.accessMemberWithLifetime(context, temporary, name, loc, true);
        if (member) return member;
        if (this.parent) return this.parent.lookup(name, context, loc, frame);
        return null;
    }
}

class ASTWithStatement : ASTStatement
{
    ASTSymbol expr;

    ASTStatement stmt;

    Loc loc;

    this(this.expr, this.stmt, this.loc) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        Expression expr = retfail beExpression3(context, retfail this.expr.compile(context), this.loc);

        (nullable Statement | fail Error) do_(Reference temp)
        {
            mut nullable Statement prefix, suffix;
            if (auto enter = retfail temp.type.accessMember(
                this.loc, context, temp, "onEnter", Protection.private_)) {
                prefix = context.compiler.exprStatement(retfail enter.beExpressionImplCall(context, this.loc));
            }
            if (auto exit = retfail temp.type.accessMember(
                this.loc, context, temp, "onExit", Protection.private_)) {
                suffix = context.compiler.exprStatement(retfail exit.beExpressionImplCall(context, this.loc));
            }

            auto subContext = context.withNamespace(new WithNamespace(context.namespace, temp, this.loc));
            auto subStmtPair = retfail this.stmt.compile(subContext);
            auto stmt = subStmtPair.statement;

            return context.compiler.(that.sequence(that.sequence2(prefix, stmt), suffix));
        }
         auto stmt = (retfail context.compiler.consumeTemporaryStmt(context, expr, &do_)).notNull;

        return StatementCompileResult(stmt, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        print("TODO: quote(ASTWithStatement)");
        assert(false);
    }
}

(nullable ASTStatement | fail Error) parseWithStatement(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!acceptIdentifier(parser, "with"))
    {
        return null;
    }
    parser.expect("(");
    auto subExpr <- lexicalContext.compiler.parseExpression(parser, lexicalContext);
    parser.assert_(!!subExpr, "with expression expected");
    parser.expect(")");
    auto body_ <- lexicalContext.compiler.parseStatement(parser, lexicalContext);

    return new ASTWithStatement(subExpr.notNull, body_, loc);
}
