module neat.with_;

import helpers;
import neat.base;
import neat.parser;
import neat.parser_base;

class WithNamespace : DeclarationHolder, Unwindable
{
    // This can't work!
    // When you do with() { void nested() { accessWithMember; } }, then the
    // lookup will try to access a nonlocal register.
    // We need to localize the reference in the stackframe,
    // by declaring it as an anonymous variable.
    // edit 12-28-021: don't we have a thing for looking up delayed-resolved values now?
    // LatentSymbol/LateSymbol or sth?
    // But I think it still doesn't work cause the temporary won't show up in the stackframe,
    // so we still need to go over a temporary variable.
    Reference temporary;

    bool freeOnExit_;

    LocRange locRange;

    this(this.parent, this.freeOnExit_, this.temporary, this.locRange) { this.isContextScope = parent.isContextScope; }

    override bool freeOnExit() { return this.freeOnExit_; }

    override (nullable Statement | fail Error) unwind(Context context) {
        if (auto exit = temporary.type.accessMember(
                context, temporary, "onExit", Protection.private_, this.locRange)?) {
            return context.compiler.exprStatement(exit.beExpressionImplCall(context, this.locRange)?);
        }
        return null;
    }

    override Reference accessDecl(CompilerBase compiler)
    {
        return temporary;
    }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        auto member = context.compiler.accessMemberWithLifetime(context, temporary, name, locRange, true)?;
        if (member) return member;
        if (this.parent) return this.parent.lookup(name, context, locRange);
        return null;
    }
}

class ASTWithStatement : ASTStatement
{
    ASTSymbol expr;

    ASTStatement stmt;

    this(this.expr, this.stmt, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        Expression expr = this.expr.compile(context)?.beExpressionImplCall(context, this.expr.locRange)?;

        bool freeOnExit = expr.info.lifetime == Lifetime.gifted;

        (nullable Statement | fail Error) do_(Reference temp)
        {
            mut nullable Statement prefix, suffix;
            if (auto enter = temp.type.accessMember(
                context, temp, "onEnter", Protection.private_, this.locRange)?) {
                prefix = context.compiler.exprStatement(enter.beExpressionImplCall(context, this.locRange)?);
            }
            if (auto exit = temp.type.accessMember(
                context, temp, "onExit", Protection.private_, this.locRange)?) {
                suffix = context.compiler.exprStatement(exit.beExpressionImplCall(context, this.locRange)?);
            }

            auto subContext = context.withNamespace(new WithNamespace(context.namespace, freeOnExit, temp, this.locRange));
            auto subStmtPair = this.stmt.compile(subContext)?;
            auto stmt = subStmtPair.statement;

            return context.compiler.(that.sequence(that.sequence2(prefix, stmt), suffix));
        }
        auto stmt = context.compiler.consumeTemporaryStmt(context, expr, &do_)?.notNull;

        return StatementCompileResult(stmt, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        print("TODO: quote(ASTWithStatement)");
        assert(false);
    }
}

(nullable ASTStatement | fail Error) parseWithStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!acceptIdentifier(parser, "with")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    parser.expect("(")?;
    auto subExpr = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
    parser.assert_(!!subExpr, "with expression expected")?;
    parser.expect(")")?;
    auto locRange = parser.to(from);
    auto body_ = lexicalContext.compiler.parseStatement(parser, lexicalContext)?;

    return new ASTWithStatement(subExpr.notNull, body_, locRange);
}
