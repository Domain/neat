module neat.parser;

import helpers;
import neat.base;
public import neat.parser_base;

bool isAlpha(int ch) {
    // TODO support full unicode
    if ((ch >= cast(int) "a"[0] && ch <= cast(int) "z"[0])
        || (ch >= cast(int) "A"[0] && ch <= cast(int) "Z"[0]))
        return true;
    if (ch < 0x80)
        return false;
    // greek letters
    if (ch >= 0x0391 && ch <= 0x03c9)
        return true;
    return false;
}

bool isDigit(int ch) {
    return ch >= cast(int) "0"[0] && ch <= cast(int) "9"[0];
}

(:failure | :success, int value | fail Error) parseNumber(Parser parser)
{
    parser.begin;
    mut bool negative = parser.accept("-")?;
    if (parser.accept("-")?)
        negative = true;
    parser.strip?;
    if (parser.accept("0x")?)
    {
        return parseHexNumber(parser, negative);
    }
    if (parser.accept("0b")?)
    {
        return parseBinaryNumber(parser, negative);
    }
    if (parser.hard_eof || !isDigit(parser.text[0]))
    {
        parser.revert;
        return :failure;
    }
    mut string number;
    while (!parser.hard_eof && (parser.text[0].isDigit || parser.text[0] == "_"[0]))
    {
        if (parser.text[0] != "_"[0])
            number ~= parser.text[0];
        parser.dropOneCharNonNewline(1);
    }
    parser.commit;
    mut int i = atoi(number);
    if (negative) i = -i;
    return (:success, i);
}

(:failure | :success, int value) parseHexNumber(Parser parser, bool negative)
{
    if (parser.hard_eof || !isHexDigit(parser.text[0 .. 1]))
    {
        parser.revert;
        return :failure;
    }
    mut int result;
    while (!parser.hard_eof && (parser.text[0 .. 1].isHexDigit || parser.text[0] == "_"[0]))
    {
        auto ch = parser.text[0 .. 1];
        mut int digit;
        if (isDigit(ch[0])) digit = atoi(ch);
        else if (ch == "a" || ch == "A") digit = 10;
        else if (ch == "b" || ch == "B") digit = 11;
        else if (ch == "c" || ch == "C") digit = 12;
        else if (ch == "d" || ch == "D") digit = 13;
        else if (ch == "e" || ch == "E") digit = 14;
        else if (ch == "f" || ch == "F") digit = 15;
        else if (ch == "_") {
            parser.dropOneCharNonNewline(1);
            continue;
        } else assert(false);
        result = result * 16 + digit;
        parser.dropOneCharNonNewline(1);
    }
    parser.commit;
    if (negative) result = -result;
    return (:success, result);
}

bool isHexDigit(string digit)
{
    if (isDigit(digit[0])) return true;
    if (digit == "a" || digit == "A") return true;
    if (digit == "b" || digit == "B") return true;
    if (digit == "c" || digit == "C") return true;
    if (digit == "d" || digit == "D") return true;
    if (digit == "e" || digit == "E") return true;
    if (digit == "f" || digit == "F") return true;
    return false;
}

(:failure | :success, int value) parseBinaryNumber(Parser parser, bool negative)
{
    bool isBinaryDigit(string d) {
        return d == "0" || d == "1";
    }
    if (parser.hard_eof || !parser.text[0 .. 1].isBinaryDigit)
    {
        parser.revert;
        return :failure;
    }
    mut int result;
    while (!parser.hard_eof && (parser.text[0 .. 1].isBinaryDigit || parser.text[0] == "_"[0]))
    {
        auto ch = parser.text[0 .. 1];
        // mut int digit = if (ch == "0") 0; else 1;
        mut int digit;
        if (ch == "0") digit = 0;
        else if (ch == "1") digit = 1;
        else if (ch == "_") {
            parser.dropOneCharNonNewline(1);
            continue;
        } else assert(false);
        result = result * 2 + digit;
        parser.dropOneCharNonNewline(1);
    }
    parser.commit;
    if (negative) result = -result;
    return (:success, result);
}

(:failure | :success, float value | :success, double value | fail Error) parseFloat(Parser parser)
with (parser.transaction)
{
    bool negative = parser.accept("-")?;
    parser.strip?;
    mut string number;
    while (!parser.hard_eof && isDigit(parser.text[0]))
    {
        number ~= parser.text[0];
        parser.dropOneCharNonNewline(1);
    }
    if (parser.accept(".")?) {}
    else return :failure;
    number ~= ".";
    // 2.foo
    if (parser.hard_eof || !isDigit(parser.text[0])) return :failure;
    while (!parser.hard_eof && isDigit(parser.text[0]))
    {
        number ~= parser.text[0];
        parser.dropOneCharNonNewline(1);
    }
    commit;
    mut double d = atof(number);
    if (negative) d = -d;
    if (!parser.hard_eof && parser.text[0] == "f"[0]) {
        parser.dropOneCharNonNewline(1);
        return (:success, cast(float) d);
    }
    return (:success, d);
}

bool isAlnum(int ch)
{
    return isAlpha(ch) || isDigit(ch);
}

(string | fail Error) parseIdentifier(Parser parser)
with (parser.transaction)
{
    parser.strip?;
    mut string identifier = "";
    string startText = parser.text;
    {
        if (parser.hard_eof) {
            return "";
        }
        string unichar = parser.peekUniChar;
        int codepoint = unichar.utf8Decode;
        if (!isAlpha(codepoint)
            && codepoint != cast(int) "_"[0] && codepoint != cast(int) "\$"[0])
        {
            return "";
        }
        identifier = startText[0 .. unichar.length];
        parser.dropOneCharNonNewline(unichar.length);
    }

    while (!parser.hard_eof) {
        string unichar = parser.peekUniChar;
        int codepoint = unichar.utf8Decode;
        if (!isAlnum(codepoint)
            && codepoint != cast(int) "_"[0])
            break;
        parser.dropOneCharNonNewline(unichar.length);
        identifier = startText[0 .. identifier.length + unichar.length];
    }
    commit;
    return identifier;
}

bool isKeyword(string identifier) {
    return identifier == "mut" || identifier == "auto";
}

(bool | fail Error) acceptIdentifier(Parser parser, string identifier)
with (parser.transaction)
{
    string nextIdent = parseIdentifier(parser)?;

    if (nextIdent != identifier)
    {
        return false;
    }
    commit;
    return true;
}
