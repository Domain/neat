module neat.function_;

macro import neat.macros.listcomprehension;
macro import neat.macros.once;

import backend.base;
import helpers;
import neat.base;
import neat.hash;
import neat.parser;
import neat.parser_base;
import neat.types;

class Function : FunctionDeclaration
{
    ASTStatement statement;

    MacroState macroState;

    nullable Namespace parent;

    bool hasThisArg;

    LocRange locRange;

    this(this.name, this.ret, this.params, this.statement, this.macroState, this.hasThisArg, this.locRange)
    {
        this.contextType = null;
        this.parent = null;
    }

    override string mangle()
    {
        if (this.name == "main") return "_main"; // globally unique
        auto paramMangle = "$(this.params.length)_"
            ~ [join with "_" param.type.mangle for param in this.params];
        return this.parent.mangle() ~ "_" ~ this.name ~ "_" ~ this.ret.mangle ~ "_" ~ paramMangle;
    }

    override string repr()
    {
        mut string repr = this.name;
        if (hasThisArg) {
            repr = this.contextType.repr ~ "::" ~ repr;
        }
        // TODO
        // if (auto mod = this.parent.instanceOf(Module)) repr = mod.name ~ "." ~ repr;
        return repr;
    }

    override void declare(Generator generator)
    {
        string mangle = this.mangle;
        if (generator.mod.declared(mangle)) return;

        Type voidp = once new Pointer(new Void);

        mut auto paramTypes = [param.type.emit(generator.platform) for param in this.params];
        if (this.contextType)
            paramTypes = [voidp.emit(generator.platform)] ~ paramTypes;

        generator.mod.declare(
            mangle,
            this.ret.emit(generator.platform),
            paramTypes,
            variadic=false
        );
    }

    CompiledFunction mkCompiledFunction(
        Function fun, Statement compiledStatement, FunctionScope stackframe, Statement[] argAssignments)
    {
        return new CompiledFunction(fun, compiledStatement, stackframe, argAssignments);
    }

    (CompiledFunction | fail Error) compile(Context context)
    {
        auto compiler = context.compiler;
        auto stackframe = new FunctionScope(
            compiler, this.ret, this.contextType, this.parent.notNull, this.mangle, this.locRange);
        mut Namespace scope_ = stackframe;
        mut int extra = 0;
        if (this.contextType)
            extra = 1;

        auto argAssignments = new Statement[](this.params.length + extra);

        mut nullable VariableDeclaration thisDecl;
        if (auto contextType = this.contextType)
        {
            // unnamed variable because of "first field in stackframe is 'this'" logic
            mut string framePtrName;
            if (this.hasThisArg) framePtrName = "this";
            thisDecl = new VariableDeclaration(
                scope_, framePtrName, contextType,
                mut=false, borrowed=true, hidden=framePtrName == "");

            Type voidp = once new Pointer(new Void);

            scope_ = thisDecl;

            argAssignments[0] = compiler.assignStatement(
                thisDecl.accessDecl(compiler),
                new PointerCast(contextType, new ArgExpr(0, voidp)));
        }

        auto framePtr = compiler.reference(compiler.stackFrame(new Void));
        mut auto context = makeContext(compiler, context.platform, scope_, this.macroState, context.modulePostProcessor)
            .withFramePointer(framePtr);

        for (int i, param in this.params) {
            auto argExpr = new ArgExpr(extra + i, param.type);

            if (param.isThisAssignment) {
                this.locRange.assert(!!thisDecl, "no this. args outside class")?;

                auto target = compiler.accessMemberWithLifetime(
                        context, thisDecl.accessDecl(context.compiler), param.name, this.locRange, false)?
                    .instanceOf(Reference);
                this.locRange.assert2(!!target, "not a reference: ", param.name)?;
                auto target = target.notNull;

                if (auto copy = param.type.copyInto(context, target, argExpr)?)
                    argAssignments[extra + i] = copy;
                else argAssignments[extra + i] = compiler.assignStatement(target, argExpr);
            } else {
                if (param.mutable) {
                    // we're mutable, but functions borrow the caller args.
                    // So despite being lexical, we copy them.
                    auto argDecl = new VariableDeclaration(
                        scope_, param.name, param.type, mut=true, borrowed=false, false);
                    auto target = argDecl.accessDecl(context.compiler);

                    if (auto assign = param.type.copyInto(context, target, argExpr)?)
                        argAssignments[extra + i] = assign;
                    else argAssignments[extra + i] = compiler.assignStatement(target, argExpr);
                    scope_ = argDecl;
                } else {
                    auto argDecl = new VariableDeclaration(
                        scope_, param.name, param.type, mut=false, borrowed=true, false);

                    argAssignments[extra + i] = compiler.assignStatement(argDecl.accessDecl(context.compiler), argExpr);
                    scope_ = argDecl;
                }
            }
        }

        context = context.withNamespace(scope_);

        auto pair = this.statement.compile(context)?;
        auto compiledStatement = compiler.unwindScope(pair.context, stackframe, pair.statement)?;

        return mkCompiledFunction(this, compiledStatement, stackframe, argAssignments);
    }
}

class CompiledFunction : FinishedSymbol
{
    Function fun;

    Statement compiledStatement;

    FunctionScope stackframe;

    Statement[] argAssignments;

    this(this.fun, this.compiledStatement, this.stackframe, this.argAssignments) { }

    override void emit(Generator generator)
    {
        if (!generator.once(this.fun.mangle)) { print("double-emit " ~ this.fun.mangle); assert(false); }
        // print("emit " ~ this.fun.mangle);

        assert(!generator.fun);
        Type voidp = once new Pointer(new Void);

        mut auto paramTypes = [param.type.emit(generator.platform) for param in this.fun.params];
        if (this.fun.contextType)
            paramTypes = [voidp.emit(generator.platform)] ~ paramTypes;

        generator.fun = generator.mod.define(
            this.fun.mangle,
            this.fun.repr,
            this.fun.ret.emit(generator.platform),
            paramTypes,
            this.fun.locRange.toBackendLoc
        );

        generator.frameReg = generator.fun.staticAlloca(this.stackframe.structType.emit(generator.platform));

        [assignment.emit(generator) for assignment in this.argAssignments];
        this.compiledStatement.emit(generator);

        generator.fun.ret(generator.fun.voidLiteral);
        generator.fun.done;
        generator.fun = null;
        generator.frameReg = -1;
    }

    override void hash(Hash hash) {
        hash.adds("fndef");
        hash.adds(fun.mangle);
        fun.ret.hash(hash);
        if (fun.contextType) fun.contextType.hash(hash);
        else hash.adds("null");
        hash.addl(fun.params.length);
        [({ hash.adds(param.name); param.type.hash(hash); }) for param in fun.params];
        this.compiledStatement.hash(hash);
    }
}

// variable without stackframe
class LatentVariable
{
    string name;

    Type stackFrameType;

    int offset;

    bool mut;

    bool borrowed;

    ExprInfo info;

    this(this.name, this.stackFrameType, this.offset, this.mut, this.borrowed) {
        assert (!mut || !borrowed);
        if (mut) this.info = ExprInfo(Lifetime.ephemeral);
        else this.info = ExprInfo(Lifetime.lexical);
    }
}

class FunctionScope : FunctionScopeBase
{
    CompilerBase compiler;

    nullable Type extra;

    StructMemberDeclaration[] variables;

    string mangle_;

    LocRange locRange;

    Type structType;

    this(this.compiler, this.ret, this.extra, this.parent, this.mangle_, this.locRange) {
        // TODO dedicated stackframe type so we don't need to keep recreating struct type instances
        this.structType = compiler.struct_("", this.variables, this.locRange, this.mangle_);
        this.isContextScope = true;
    }

    LatentVariable declare(string name, Type type, bool mut, bool borrowed)
    {
        // borrowed == "no cleanup on scope exit".
        // This is not safe in conjunction with mut (cleanup on reassign).
        assert(!borrowed || !mut);

        this.variables ~= new StructMemberDeclaration(name, Protection.public_, type);
        this.structType = this.compiler.struct_("", this.variables, this.locRange, this.mangle_);

        return new LatentVariable(name, this.structType, cast(int) this.variables.length - 1,
                                  mut=mut, borrowed=borrowed);
    }

    override string mangle() { return this.mangle_; }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        assert(!!this.parent);

        mut nullable Expression nextFramePointer = null;
        if (this.extra && context.framePointer) {
            // first field in stackframe must be parent
            // TODO better?
            auto framePtr = new PointerCast(once new Pointer(new Pointer(new Void)), context.framePointer.notNull);
            nextFramePointer = context.compiler.dereference(framePtr);
        }

        return this.parent.lookup(name, context.withFramePointer(nextFramePointer), locRange);
    }
}

/**
 * Used to allow referencing the types of parameters from the return type,
 * for instance in typeof().
 */
class ReturnTypeNamespace : Namespace
{
    Parameter[] params;

    this(this.parent, this.params) { }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange) {
        for (param in this.params) {
            if (param.name == name) {
                import neat.expr : NullExpr;

                return new NullExpr(param.type);
            }
        }
        if (this.parent) return this.parent.lookup(name, context, locRange);
        return null;
    }
}

class VariableDeclaration : DeclarationHolder
{
    LatentVariable variable;

    bool hidden;

    this(this.parent, string name, Type type, bool mut, bool borrowed, this.hidden)
    {
        this.variable = findParent!FunctionScope(this).declare(name, type, mut=mut, borrowed=borrowed);
        this.isContextScope = true;
    }

    override bool freeOnExit() {
        return !variable.borrowed;
    }

    override Reference accessDecl(CompilerBase compiler)
    {
        Expression frame = compiler.reference(new StackFrame(variable.stackFrameType));
        return access(compiler, frame);
    }

    Reference access(CompilerBase compiler, Expression frame)
    {
        Type stackFrameType = variable.stackFrameType;
        auto frame = new PointerCast(new Pointer(stackFrameType), frame);
        auto reference = compiler.structMemberReference(compiler.dereference(frame), variable.offset);
        return new InfoReference(reference, variable.mut, variable.info);
    }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        // Frame may be null for struct nested in function.
        if (auto frame = context.framePointer) {
            if (this.variable.name == name) {
                return access(context.compiler, frame);
            }
            // soft destructuring
            if (!hidden && this.variable.name == "") {
                auto unnamedVar = access(context.compiler, frame);
                auto target = context.compiler.accessMemberWithLifetime(
                        context, unnamedVar, name, locRange, true)?;
                if (target) return target;
            }
        }
        if (this.parent) return this.parent.lookup(name, context, locRange);
        return null;
    }
}

class StackFrame : Reference
{
    Type targetType;

    // why not mutable? Variable access will override the reference - at that point, mut should be enabled as required.
    // If you somehow manage to get a raw reference to this class, by no means should you be able to write it!
    this(this.targetType) {
        this.type = this.targetType;
        this.mutable = false;
        this.info = ExprInfo(Lifetime.permanent);
    }

    override int emit(Generator generator)
    {
        assert(false);
    }

    override int emitLocation(Generator generator)
    {
        return generator.frameReg;
    }

    override void hash(Hash hash) { hash.adds("StackFrame"); targetType.hash(hash); }

    override string repr() { return "__frame"; }
}

class InfoReference : Reference
{
    Reference base;

    this(this.base, this.mutable, this.info) { this.type = base.type; }

    override int emit(Generator output) { return base.emit(output); }
    override int emitLocation(Generator output) { return base.emitLocation(output); }
    // TODO hash ExprInfo
    override void hash(Hash hash) { hash.adds("InfoReference"); base.hash(hash); }
    override string repr() { return "InfoReference($(base.repr): $(info.repr))"; }
}

class ArgExpr : Expression
{
    int index;

    this(this.index, this.type) { this.info = ExprInfo(Lifetime.lexical); }

    override int emit(Generator output)
    {
        return output.fun.arg(this.index);
    }

    override void hash(Hash hash) { hash.adds("ArgExpr"); hash.addl(index); }
}

class FunctionReference : FunctionReferenceBase
{
    FunctionDeclaration fun;

    this(this.fun) {
        mut auto params = this.fun.params;
        if (this.fun.contextType) params = [Parameter.fromType(once new Pointer(new Void))] ~ params;

        this.type = new FunctionPointer(this.fun.ret, params);
        this.info = ExprInfo(Lifetime.permanent);
    }

    override FunctionDeclaration getFunction() { return fun; }

    override int emit(Generator output)
    {
        this.fun.declare(output);

        return output.fun.getFuncPtr(this.fun.mangle);
    }

    override void hash(Hash hash) { hash.adds("FunctionReference"); hash.adds(fun.mangle); }
}

class NestedFunction : LateSymbol
{
    Function fun;

    this(this.fun, this.baseExpr) { }

    override Expression resolve(Context context, Expression baseExpr) {
        return new FunctionReference(this.fun);
    }

    override Expression patchContext(Context context, Expression baseExpr) {
        return new PointerCast(once new Pointer(new Void), baseExpr);
    }
}

class LatentNestedFunction : LatentSymbol
{
    Function fun;

    this(this.fun) { }

    override Symbol resolve(Context context) {
        return new NestedFunction(this.fun, context.framePointer.notNull);
    }
}

class ASTFunction : ASTSymbol
{
    string name;

    ASTSymbol ret;

    ASTParameter[] params;

    bool isDeclaration;

    ASTStatement statement;

    MacroState macroState;

    this(this.name, this.ret, this.params, this.isDeclaration, this.locRange, this.statement, this.macroState) { }

    override (Symbol | fail Error) compile(Context context)
    {
        auto params = [
            Parameter(false, param.name, param.mutable, param.type.compile(context)?.beType2(param.locRange)?)
            for param in this.params];

        // It's nice to be able to reference the function
        // parameters in a typeof() in the return type.
        auto returnTypeNamespace = new ReturnTypeNamespace(context.namespace, params);
        auto returnTypeContext = context.withNamespace(returnTypeNamespace);

        if (this.isDeclaration)
        {
            // FIXME retLocRange
            return new FunctionDeclaration(
                this.name, this.ret.compile(returnTypeContext)?.beType2(this.locRange)?, params);
        }

        auto module_ = findParent!ModuleBase(context.namespace);

        auto fun = new Function(
            this.name,
            this.ret.compile(returnTypeContext)?.beType2(this.locRange)?,
            params,
            this.statement, this.macroState, false, this.locRange);

        if (auto functionScope = findParent!FunctionScope(context.namespace)) {
            auto structType = functionScope.structType;
            auto voidp = once new Pointer(new Void);
            auto latent = new LatentNestedFunction(fun);

            fun.contextType = new Pointer(structType);

            auto namespace = new SymbolAlias(context.namespace, fun.name, latent);

            fun.parent = namespace;

            module_.track(fun);

            return latent;
        }

        fun.parent = context.namespace;
        return fun;
    }

    override string repr() { return "repr(ASTFunction)"; }
}

(nullable ASTFunction | fail Error) parseFunction(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    nullable ASTSymbol ret = lexicalContext.compiler.parseType(parser, lexicalContext)?;
    if (!ret)
    {
        parser.revert;
        return null;
    }
    string name = parser.parseIdentifier?;
    // avoid 'mut typeof(expr)' from matching as a function
    // TODO reserved identifier list
    auto locRange = parser.to(from);
    if (!name.length || name == "typeof" || !parser.accept("(")?)
    {
        parser.revert;
        return null;
    }
    parser.commit;
    // FIXME
    // auto params = parseIdentifierList(parser, lexicalContext, variadics=false).params;
    auto params = parseIdentifierList(parser, lexicalContext, variadics=false)?;
    ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext)?;
    return new ASTFunction(name, ret.notNull, params.params, false, locRange, stmt, lexicalContext.macroState);
}

(ASTParameter[] params, bool variadic | fail Error) parseIdentifierList(
    Parser parser, LexicalContext lexicalContext, bool variadics)
{
    mut ASTParameter[] params;
    mut bool variadic = false;
    while (!parser.accept(")")?)
    {
        if (params.length) {
            if (!parser.accept(",")?) {
                return parser.fail("',' or ')' expected");
            }
        }
        auto from = parser.from?;
        if (variadics) {
            parser.begin;
            if (parser.accept("...")? && parser.accept(")")?) {
                parser.commit;
                variadic = true;
                break;
            }
            parser.revert;
        }

        mut bool mutable;
        if (parser.acceptIdentifier("mut")?) mutable = true;
        nullable ASTSymbol paramType = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        if (!paramType) {
            return parser.fail("type expected");
        }
        string paramName = parser.parseIdentifier?;
        params ~= ASTParameter(paramName, mutable, paramType.notNull, parser.to(from));
    }
    return (params, variadic);
}

((ASTParameter | ASTThisAssignment)[] | fail Error) parseParamList(Parser parser, LexicalContext lexicalContext)
{
    mut (ASTParameter | ASTThisAssignment)[] params;
    while (!parser.accept(")")?)
    {
        if (params.length > 0)
        {
            if (!parser.accept(",")?)
            {
                return parser.fail("',' or ')' expected");
            }
        }
        auto from = parser.from?;
        if (parser.accept("this.")?)
        {
            string argname = parseIdentifier(parser)?;
            params ~= ASTThisAssignment(argname, parser.to(from));
        }
        else
        {
            mut bool mutable;
            if (parser.acceptIdentifier("mut")?) mutable = true;
            nullable ASTSymbol argtype = lexicalContext.compiler.parseType(parser, lexicalContext)?;
            parser.assert_(!!argtype, "argument type expected")?;
            string argname = parseIdentifier(parser)?;
            parser.assert_(argname.length > 0, "argument name expected")?;
            params ~= ASTParameter(name=argname, mutable, argtype.notNull, parser.to(from));
        }
    }
    return params;
}
