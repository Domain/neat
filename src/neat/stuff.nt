// TODO distribute into more appropriate modules
module neat.stuff;

macro import neat.macros.hash;
macro import neat.macros.listcomprehension;
macro import neat.macros.once;
macro import neat.macros.quasiquoting;

import backend.base;
import helpers;
import neat.array;
import neat.base;
import neat.class_;
import neat.decl;
import neat.either;
import neat.enums;
import neat.expr;
import neat.formatstring;
import neat.function_;
import neat.hash;
import neat.hashmap;
import neat.parser;
import neat.pragmas;
import neat.parser_base;
import neat.statements;
import neat.struct_;
import neat.templ;
import neat.traits;
import neat.tuples;
import neat.types;
import neat.unittest_;
import neat.vectors;
import neat.with_;
import std.thread;

// TODO clear all this up
class DefineClassIntf : FinishedSymbol
{
    (Class | Intf) obj;

    this(this.obj) { }

    override void emit(Generator generator)
    {
        obj.case {
            Class class_: class_.define(generator);
            Intf intf: intf.define(generator);
        }
    }

    override void hash(Hash hash)
    {
        this.obj.case {
            Class class_: {
                // FIXME nested function mangling
                void mangle1(typeof(class_.vtable[0]) entry) {
                    entry.case {
                        ClassMethod method: hash.adds(method.mangle);
                        (:baseOffset, size_t offs): hash.addl(offs);
                    }
                }
                // only the actual vtable symbol, the methods are also hashed separately
                [mangle1(method) for method in class_.vtable];
            }
            Intf intf: {
                void mangle2(typeof(intf.vtable[0]) entry) {
                    entry.case {
                        IntfMethod method: hash.adds(method.mangle);
                        (:baseOffset): hash.adds("baseOffset");
                    }
                }
                // only the actual vtable symbol, the methods are also hashed separately
                [mangle2(method) for method in intf.vtable];
            }
        }
    }
}

(nullable ASTSymbol | fail Error) parseType(Parser parser, LexicalContext lexicalContext)
{
    nullable ASTSymbol current = parser.parseLeafType(lexicalContext)?;
    if (!current) return null;
    mut ASTSymbol current = current.notNull;
    while (true)
    {
        auto from = parser.from?;
        if (parser.accept("*")?)
        {
            current = new ASTPointer(current, parser.to(from));
            continue;
        }
        with (parser.transaction) {
            string identifier = parser.parseIdentifier?;
            if (identifier == "function" || identifier == "delegate") {
                parser.expect("(")?;
                mut ASTSymbol[] args;
                while (!parser.accept(")")?) {
                    if (args.length) {
                        if (!parser.accept(",")?)
                            return parser.fail("',' or ')' expected");
                    }
                    auto argType = parser.parseType(lexicalContext)?;

                    args ~= argType.notNull;
                }
                commit;
                if (identifier == "function")
                    current = new ASTFunctionPointer(current, args, parser.to(from));
                else
                    current = new ASTNestedFunctionPointer(current, args, parser.to(from));
                continue;
            }
        }
        with (parser.transaction) {
            if (parser.accept("[")?) {
                if (parser.accept("]")?) {
                    commit;

                    current = new ASTArray(current, parser.to(from));
                    continue;
                }
                // hashmap? might be assignment intro
                auto keyType = parser.parseType(lexicalContext)?;
                if (!keyType || !parser.accept("]")?) {
                    return null;
                }
                commit;
                current = new ASTHashMap(key=keyType.notNull, value=current, parser.to(from));
                continue;
            }
            if (parser.accept("[")? && parser.accept("]")?)
            {
            }
        }
        // what about templates that don't contain types? instead of duplicating this,
        // there should be a function to parse an ast symbol and that symbol should
        // be able to compile to a Type (Symbol).
        // But for now, templates only have types.
        // (this will also be needed to have things like Foo.Bar for nested types.)
        with (parser.transaction) {
            auto instanceFrom = parser.from?;
            // TODO better way to exclude all the negated operators
            if (parser.accept("!")? && !parser.accept("=")? && !acceptIdentifier(parser, "is")?)
            {
                mut ASTSymbol[] templateArgs;
                (void | fail Error) getTemplateArg() {
                    auto templateArg = parser.parseType(lexicalContext)?;
                    parser.assert_(!!templateArg, "template argument expected")?;
                    templateArgs ~= templateArg.notNull;
                }

                if (parser.accept("(")?) {
                    // ( [a [, a]*]? )
                    if (!parser.accept(")")?) {
                        getTemplateArg?;
                        while (!parser.accept(")")?) {
                            parser.expect(",")?;
                            getTemplateArg?;
                        }
                    }
                } else {
                    getTemplateArg?;
                }
                commit;
                current = new ASTTemplateInstance(current, templateArgs, parser.to(from));
                continue;
            }
        }
        return current;
    }
}

/**
 * Tuples:
 * - (int, float): int and float
 * - (int | float): int or float
 * - (int, int | int): (int and int) or int
 */
(nullable ASTSymbol | fail Error) parseTupleType(Parser parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    parser.begin;
    auto from = parser.from?;
    if (!parser.accept("(")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    mut ASTEitherDeclEntry[] declEntries;
    mut (string name, LocRange locRange, ASTSymbol sym)[] members;
    mut bool fail = false;
    if (parser.accept("fail")?) fail = true;
    void flush() {
        assert(members.length > 0);

        if (members.length == 1 && members[0].name == "") {
            declEntries ~= ASTEitherDeclEntry(members[0].locRange, fail, members[0].sym);
        } else {
            declEntries ~= ASTEitherDeclEntry(
                parser.to(from),
                fail,
                new ASTTupleType([(a.name, a.sym) for a in members], parser.to(from)));
        }
        members = [];
        fail = false;
    }
    while (!parser.accept(")")?)
    {
        if (members.length) {
            mut bool tuplesep, eithersep;
            if (parser.accept(",")?) tuplesep = true;
            else if (parser.accept("|")?) eithersep = true;
            else {
                // be a bit lenient for (bla bla)
                if (members.length == 1) {
                    return null;
                }
                return parser.to(from).fail("tuple: ',' or '|' expected");
            }
            if (eithersep) {
                flush;
                if (parser.accept("fail")?) fail = true;
            }
        }
        auto from = parser.from?;
        auto type = parser.parseType(lexicalContext)?;
        if (!type) {
            // (bla bla) still
            if (members.length <= 1) {
                return null;
            }
            return parser.to(from).fail("tuple: type expected");
        }
        string name = parser.parseIdentifier?;
        members ~= (name, parser.to(from), type.notNull);
    }
    flush;
    commit;
    if (declEntries.length == 1) return declEntries[0].symbol;
    return new ASTEitherDecl(declEntries);
}

(nullable ASTSymbol | fail Error) parseLeafType(Parser parser, LexicalContext lexicalContext)
{
    import std.string : startsWith;

    auto from = parser.from?;
    if (parser.acceptIdentifier("nullable")?) {
        auto locRange = parser.to(from);
        auto next = parseLeafType(parser, lexicalContext)?;
        return new ASTNullable(next.notNull, true, locRange);
    }
    if (parser.acceptIdentifier("nonnullable")?) {
        auto locRange = parser.to(from);
        auto next = parseLeafType(parser, lexicalContext)?;
        return new ASTNullable(next.notNull, false, locRange);
    }

    {
        auto typeMacroArgs = new TypeMacroArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(typeMacroArgs);
        if (ASTSymbol ret = typeMacroArgs.astType) return ret;
    }

    // must be before any () parsing for types we may add.
    if (auto symbol = parser.parseTupleType(lexicalContext)?) return symbol;

    with (parser.transaction) {
        if (parser.acceptIdentifier("Vector")? && parser.accept("(")?) {
            auto element = lexicalContext.compiler.parseType(parser, lexicalContext)?;
            parser.assert_(!!element, "element type expected")?;
            parser.expect(",")?;
            auto count = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
            parser.assert_(count && count.instanceOf(ASTIntLiteral), "integer expected")?;
            parser.expect(")")?;
            commit;
            return new ASTVectorType(element.notNull, count.instanceOf(ASTIntLiteral).value, parser.to(from));
        }

        if (parser.accept("typeof")?)
        {
            parser.expect("(")?;
            auto expr = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
            if (!expr) return parser.fail("expression expected");
            parser.expect(")")?;
            commit;
            return new ASTTypeof(expr.notNull, parser.to(from));
        }

        if (parser.accept(":")?) {
            string symbolIdentifier = parser.parseIdentifier?;
            if (symbolIdentifier != "") {
                commit;
                return new ASTSymbolIdentifier(symbolIdentifier, __RANGE__);
            }
        }
    }
    with (parser.transaction) {
        string identifier = parser.parseIdentifier?;

        if (identifier == "" || identifier.isKeyword)
        {
            return null;
        }
        commit;

        auto loc = __RANGE__;
        if (identifier == "long")
            return once new ASTBasicType("long", loc);
        if (identifier == "int")
            return once new ASTBasicType("int", loc);
        if (identifier == "short")
            return once new ASTBasicType("short", loc);
        if (identifier == "char")
            return once new ASTBasicType("char", loc);
        if (identifier == "ubyte")
            return once new ASTBasicType("ubyte", loc);
        if (identifier == "bool")
            return once new ASTBasicType("bool", loc);
        if (identifier == "void")
            return once new ASTBasicType("void", loc);
        if (identifier == "float")
            return once new ASTBasicType("float", loc);
        if (identifier == "double")
            return once new ASTBasicType("double", loc);

        return lexicalContext.compiler.astIdentifier(identifier, parser.to(from));
    }
}

class FuncPtrCall : Expression
{
    Expression funcPtr;

    Expression[] args;

    LocRange locRange;

    this(this.funcPtr, this.args, this.locRange) {
        this.type = this.funcPtr.type.instanceOf(FunctionPointer).ret;
        // we take over the returned value
        this.info = ExprInfo(false, Ownership.gifted);
    }

    override int emit(Generator output)
    {
        FunctionPointer type = this.funcPtr.type.instanceOf(FunctionPointer).notNull;

        if (type.params.length != this.args.length) {
            print("expected $(type.params.length) args, not $(this.args.length)");
            print("(this is a compiler error, that should have been caught beforehand)");
            assert(false);
        }

        int[] regs = new int[](this.args.length);
        for (i, arg in this.args)
        {
            regs[i] = arg.emit(output);
        }
        return output.fun.callFuncPtr(
            type.emit(output.platform), this.funcPtr.emit(output), regs);
    }

    override void hash(Hash hash) {
        hash.adds("FuncPtrCall");
        funcPtr.hash(hash);
        hash.addl(args.length);
        [arg.hash(hash) for arg in args];
    }
}

class DelegateExpr : Expression
{
    Expression funcPtr;

    Expression thisPtr;

    this(this.funcPtr, this.thisPtr) {
        FunctionPointer type = this.funcPtr.type.instanceOf(FunctionPointer).notNull;

        // drop thisptr - implicit!
        assert(type.params.length >= 1);
        // TODO this smells.
        this.type = new NestedFunctionPointer(type.ret, [a.type for a in type.params[1 .. $]]);
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emit(Generator output)
    {
        int thisReg = this.thisPtr.emit(output);
        int funcReg = this.funcPtr.emit(output);
        auto voidp = output.platform.voidp;
        auto thisType = this.type.emit(output.platform);
        int nullReg = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), voidp);
        return output.fun.structLiteral(thisType, [nullReg, thisReg, funcReg]);
    }

    override void hash(Hash hash) { hash.adds("DelegateExpr"); this.funcPtr.hash(hash); this.thisPtr.hash(hash); }
}

class DelegateDataPtr : Expression
{
    Expression dg;

    this(this.dg) {
        this.type = once new Pointer(new Void);
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emit(Generator output)
    {
        int reg = this.dg.emit(output);

        return output.fun.field(this.dg.type.emit(output.platform), reg, 1);
    }

    override void hash(Hash hash) { hash.adds("DelegateDataPtr"); this.dg.hash(hash); }
}

class DelegateFuncPtr : Expression
{
    Expression dg;

    this(this.dg) {
        auto nestfp = this.dg.type.instanceOf(NestedFunctionPointer);
        assert(!!nestfp);
        auto params = [Parameter.fromType(once new Pointer(new Void))]
            ~ [Parameter.fromType(a) for a in nestfp.params];
        this.type = new FunctionPointer(nestfp.ret, params);
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emit(Generator output)
    {
        int reg = this.dg.emit(output);

        return output.fun.field(this.dg.type.emit(output.platform), reg, 2);
    }

    override void hash(Hash hash) { hash.adds("DelegateFuncPtr"); this.dg.hash(hash); }
}

/**
 * "Plain" call without lifetime handling.
 */
(nullable Expression | fail Error) plainCall(Context context, Symbol target,
    mut Expression[] args, LocRange locRange, bool isImplCall)
{
    if (auto fundecl = target.instanceOf(FunctionDeclaration))
    {
        // skip variadic args
        args = [
            expectImplicitConvertTo(context, arg, fundecl.params[i].type, locRange)?
            for i, arg in args[0 .. fundecl.params.length]] ~ args[fundecl.params.length .. $];
        return new Call(fundecl, args, locRange);
    }
    if (ClassMethodPtr method = target.instanceOf(ClassMethodPtr))
    {
        if (auto funcptr = method.funcPtr.type.instanceOf(FunctionPointer)) {
            // this ptr
            if (args.length != funcptr.params.length - 1)
                return locRange.fail("wrong number of arguments: expected $(funcptr.params.length - 1) but got $(args.length)");
            args = [expectImplicitConvertTo(context, arg, funcptr.params[i+1].type, locRange)? for i, arg in args];
        } else {
            return locRange.fail("function reference or funcptr expected? but is '$(method.funcPtr.type.repr)'");
        }
        (nullable Expression | fail Error) doPtr(Expression thisPtr) {
            auto voidp = once new Pointer(new Void);
            mut Expression[] combinedArgs;
            combinedArgs ~= new PointerCast(voidp, thisPtr);
            combinedArgs ~= args;
            return new FuncPtrCall(method.funcPtr, combinedArgs, locRange);
        }
        (nullable Expression | fail Error) doRef(Reference thisValue) {
            return doPtr(context.compiler.reference(thisValue));
        }
        if (method.valueIsPtr) {
            return context.compiler.exprWithTemporaryExpr(method.thisValue, &doPtr);
        } else if (auto ref_ = method.thisValue.instanceOf(Reference)) {
            auto ptr = context.compiler.reference(ref_);
            return context.compiler.exprWithTemporaryExpr(ptr, &doPtr);
        } else {
            return context.compiler.exprWithTemporary(method.thisValue, &doRef);
        }
    }
    if (isImplCall) return null;
    nullable Expression expr = target.instanceOf(Expression);
    // TODO
    // auto funcptr = expr?.type.instanceOf(FunctionPointer);
    mut nullable FunctionPointer funcptr;
    if (expr) funcptr = expr.type.instanceOf(FunctionPointer);
    if (expr && funcptr)
    {
        args = [expectImplicitConvertTo(context, arg, funcptr.params[i].type, locRange)? for i, arg in args];
        return new FuncPtrCall(expr.notNull, args, locRange);
    }
    mut nullable NestedFunctionPointer nestedfuncptr;
    if (expr) nestedfuncptr = expr.type.instanceOf(NestedFunctionPointer);
    if (expr && nestedfuncptr)
    {
        auto expr = expr.notNull;
        args = [expectImplicitConvertTo(context, arg, nestedfuncptr.params[i], locRange)? for i, arg in args];
        // TODO cache delegate
        auto funcPtr = new DelegateFuncPtr(expr);
        auto thisPtr = new DelegateDataPtr(expr);
        mut Expression[] combinedArgs;
        combinedArgs ~= thisPtr;
        combinedArgs ~= args;
        return new FuncPtrCall(funcPtr, combinedArgs, locRange);
    }
    return locRange.fail("unknown call target");
}

class WrapExpression : Expression
{
    nullable Statement pre;
    Expression value;
    nullable Statement post;

    this(this.pre, this.value, this.post) {
        this.type = value.type;
        this.info = value.info;
    }

    override int emit(Generator generator)
    {
        if (pre) pre.emit(generator);
        int result = value.emit(generator);
        if (post) post.emit(generator);
        return result;
    }

    override void hash(Hash hash) {
        hash.adds("WrapExpression");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        value.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }

    override string repr() {
        if (pre && post) return "wrap($(pre.repr); $(value.repr); $(post.repr))";
        if (pre) return "wrap($(pre.repr); $(value.repr); -)";
        if (post) return "wrap(-; $(value.repr); $(post.repr))";
        return value.repr;
    }
}

/**
 * This type is a bit risky.
 * Because result is returned after post() is called,
 * `WrapReference` can leak the location of a value that
 * has no references. As such, it should only be used when
 * `reference` doesn't yield an address managed by `pre`/`post`.
 */
class WrapReference : Reference
{
    nullable Statement pre;
    Reference reference;
    nullable Statement post;

    this(this.pre, this.reference, this.post) {
        this.type = reference.type;
        this.info = reference.info;
    }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        if (pre) pre.emit(output);
        int result = reference.emitLocation(output);
        if (post) post.emit(output);
        return result;
    }

    override void hash(Hash hash) {
        hash.adds("WrapReference");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        reference.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }

    override string repr() {
        if (pre && post) return "wrap($(pre.repr); $(reference.repr); $(post.repr))";
        if (pre) return "wrap($(pre.repr); $(reference.repr); -)";
        if (post) return "wrap(-; $(reference.repr); $(post.repr))";
        return reference.repr;
    }
}

(nullable Expression | fail Error) call(Context context, ASTSymbol astTarget,
    ASTArgument[] astArgs, LocRange locRange, bool autoCall)
{
    if (!context.namespace) return null;
    if (!autoCall) {
        auto callMacroArgs = once new CallMacroArgs;
        callMacroArgs.set(astTarget, astArgs, context, locRange);
        context.macroState.applyMacro(callMacroArgs);
        if (auto transformed = callMacroArgs.transformed?) return transformed;

        /// Direct implementation of `foo.bar(baz)`.
        /// Reduces need for `LateSymbol`.
        if (auto memberAccess = astTarget.instanceOf(ASTMemberBase)) {
            auto base = memberAccess.base.compile(context)?;
            if (auto type = base.instanceOf(Type)) {
                auto protection = type.protectionAt(context.namespace.notNull);
                if (auto ret = type.callMember(
                        context, null, memberAccess.member, astArgs, protection, memberAccess.locRange)?)
                    return ret;
            } else if (auto baseExpr = base.isExpressionImplCall(context, locRange)?) {
                auto protection = baseExpr.type.protectionAt(context.namespace.notNull);
                if (auto ret = baseExpr.type.callMember(
                        context, baseExpr, memberAccess.member, astArgs, protection, memberAccess.locRange)?)
                    return ret;
            }
        }
    }

    mut auto target = astTarget.compile(context)?;

    if (!autoCall) {
        if (auto type_ = target.instanceOf(Type)) {
            if (auto ret = type_.call(context, locRange, astArgs)?)
                return ret;
        }
        if (auto expr = target.instanceOf(Expression)) {
            if (auto ret = expr.type.callExpr(context, locRange, expr, astArgs)?)
                return ret;
        }
    }

    if (auto fundecl = target.instanceOf(FunctionDeclaration)) {
        validateCall(fundecl.params, astArgs, fundecl.name, variadic=fundecl.variadic, locRange)?;
    }
    if (auto method = target.instanceOf(ClassMethodPtr)) {
        if (auto funcptr = method.funcPtr.type.instanceOf(FunctionPointer)) {
            // skip "this"
            validateCall(funcptr.params[1 .. $], astArgs, method.name, variadic=false, locRange)?;
        }
    }

    auto args = [
        arg.sym.compile(context)?.beExpressionImplCall(context, locRange)?
        for arg in astArgs];

    if (auto templ = target.instanceOf(ScopeBoundTemplateDecl)) {
        // Simplest conceivable IFTI
        auto types = [arg.type for arg in args];
        // Some types, like Lambda, generate different types every time they're compiled.
        auto repackagedArgs = [
            ASTArgument(new ASTSymbolHelper(arg), astArgs[i].name, astArgs[i].locRange)
            for i, arg in args];
        auto instance = templ.instantiate(context, locRange, types)?;

        return call(context, new ASTSymbolHelper(instance), repackagedArgs, locRange, autoCall);
    }

    mut nullable Statement pre, post;
    Expression[] args_ = new Expression[](args.length);
    for (i in 0 .. args.length) {
        mut Expression arg = args[i];
        // we must free arg after the call, so make a copy
        if (arg.info.ownership == Ownership.gifted) {
            auto temp = new PairedTemporary(arg.type, Ownership.owned);
            // no copyInto() because we're taking ownership.
            auto set = new InitializeTemporaryStatement(temp, arg);
            if (auto destructor = arg.type.endLifetime(context, temp)) {
                pre = sequence2(pre, set);
                post = sequence(destructor, post);
                arg = temp;
            }
        }
        args_[i] = arg;
    }
    auto args = args_;

    if (auto lateSym = target.instanceOf(LateSymbol)) {
        // completely bypass plainCall with a FuncPtrCall
        (nullable Expression | fail Error) do1(Expression baseExpr) {
            auto funcPtr = lateSym.resolve(context, baseExpr);
            mut Expression[] args = args;

            if (auto funcPtr = funcPtr.type.instanceOf(FunctionPointer)) {
                validateCall(funcPtr.params[1 .. $], astArgs, "function pointer", variadic=false, locRange)?;
                args = [expectImplicitConvertTo(context, arg, funcPtr.params[i+1].type, locRange)? for i, arg in args];
            } else {
                return locRange.fail("function reference or funcptr expected? but is '$(funcPtr.type.repr)'");
            }
            auto voidp = once new Pointer(new Void);
            mut Expression[] combinedArgs;
            combinedArgs ~= lateSym.patchContext(context, new PointerCast(voidp, baseExpr));
            combinedArgs ~= args;
            return new FuncPtrCall(funcPtr, combinedArgs, locRange);
        }
        (Expression | fail Error) do2(Expression baseExpr)
        {
            return context.compiler.exprWithTemporaryExpr(baseExpr, &do1)?.notNull;
        }
        auto fpCall = context.compiler.consume(context, lateSym.baseExpr, &do2)?;

        return new WrapExpression(pre, fpCall, post);
    }

    nullable ClassMethodPtr method = target.instanceOf(ClassMethodPtr);
    if (method && method.thisValue.info.ownership == Ownership.gifted) { // foo().bar()
        mut nullable Statement setRef;
        void doRef(Reference tempThis) {
            if (Statement cleanupThis = method.thisValue.type.endLifetime(context, tempThis)) {
                if (Statement setRef = setRef) pre = sequence2(pre, setRef);
                post = sequence(cleanupThis, post);
                target = new ClassMethodPtr(method.funcPtr, tempThis, method.valueIsPtr, method.name);
            }
        }
        if (auto ref_ = method.thisValue.instanceOf(Reference)) doRef(ref_);
        else {
            // create reference for endLifetime call
            auto tempThis = new PairedTemporary(method.thisValue.type, Ownership.gifted);
            setRef = new InitializeTemporaryStatement(tempThis, method.thisValue);
            doRef(tempThis);
        }
    }
    if (auto callResult = plainCall(context, target, args, locRange, autoCall)?)
        return new WrapExpression(pre, callResult, post);
    return null;
}

/**
 * The sort of thing that can be implicitly called.
 * Shortcuts the call() logic to speed up `isExpressionImplCall`.
 */
bool previewCanCallImplicit(Symbol target) {
    return target.instanceOf(FunctionDeclaration)
        || target.instanceOf(ClassMethodPtr)
        || target.instanceOf(LateSymbol);
}

class ASTCall : ASTSymbol
{
    ASTSymbol target;

    ASTArgument[] args;

    this(this.target, this.args, this.locRange) { }

    override (Expression | fail Error) compile(Context context)
    {
        // FIXME this goes better in call()
        if (auto astMemberAccess = this.target.instanceOf(ASTMember))
        {
            /**
             * UFCS:
             * Syntax is foo.bar(baz).
             * Check if "foo" has a property "bar".
             * If not, call bar(foo, baz) instead.
             */
            if (auto base = astMemberAccess.base.compile(context)?.isExpressionImplCall(context, this.locRange)?) {
                auto member = accessMember(
                    context, base, astMemberAccess.member, astMemberAccess.locRange, allowUndefined=true)?;
                if (!member) {
                    // if `foo` has no `bar` but there is a `bar` symbol:
                    if (auto callable = context.namespace.lookup(astMemberAccess.member, context, this.locRange)?) {
                        // rewrite foo.bar(baz) to bar(foo, baz)
                        auto target = new ASTIdentifier(astMemberAccess.member, false, astMemberAccess.locRange);
                        auto args = [ASTArgument(astMemberAccess.base, "", astMemberAccess.locRange)] ~ this.args;
                        return (new ASTCall(target, args, this.locRange)).compile(context);
                    }
                }
            }
        }

        return call(context, this.target, this.args, this.locRange, false)?.notNull;
    }

    override ASTSymbol quote(Quoter quoter) {
        auto args = [arg.sym.quote(quoter) for arg in this.args];
        return quoter.compilerCall("astCall", [
            this.target.quote(quoter),
            quoter.compiler.astArrayLiteral(args, this.locRange)
        ], this.locRange);
    }

    override string repr() {
        return this.target.repr ~ "(" ~ [join with ", " a.sym.repr for a in this.args] ~ ")";
    }
}

(ASTArgument[] | fail Error) parseArgumentList(Parser parser, LexicalContext lexicalContext)
{
    mut ASTArgument[] args;
    while (!parser.accept(")")?)
    {
        if (args.length > 0)
            parser.expect(",")?;
        // foo(a, b, c, )
        if (parser.accept(")")?) break;

        auto from = parser.from?;
        mut string name;
        with (parser.transaction) {
            string n = parser.parseIdentifier?;
            if (n.length > 0 && parser.acceptButNot2("=", "==", "=>")?) {
                commit;
                name = n;
            }
        }
        nullable ASTSymbol arg = parser.parseExpression(lexicalContext)?;
        parser.to(from).assert(!!arg, "expression expected")?;
        args ~= ASTArgument(arg.notNull, name, parser.to(from));
    }
    return args;
}

(nullable ASTCall | fail Error) parseCall(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
with (parser.transaction)
{
    auto from = parser.from?;
    if (!parser.accept("(")?)
        return null;
    mut ASTArgument[] args = parser.parseArgumentList(lexicalContext)?;
    commit;
    return new ASTCall(base, args, parser.to(from));
}

class ASTIndexAccess : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol index;

    this(this.base, this.index, this.locRange) { }

    override (Expression | fail Error) compile(Context context)
    {
        auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        bool saveIndexValue = base.info.ownership == Ownership.gifted;

        (nullable Expression | fail Error) do_(Reference base) {
            mut uninitialized Expression indexExpr;
            mut uninitialized Expression ptrBase;

            auto type = base.type;
            if (auto array_ = type.instanceOf(Array)) {
                auto context = context.withNamespace(
                    context.compiler.exprAlias(context.namespace, "__array", base));

                indexExpr = this.index.compile(context)?.beExpressionImplCall(context, this.locRange)?;
                // TODO bounds check
                ptrBase = new ArrayPointer(array_.elementType, base);
            } else if (type.instanceOf(Pointer)) {
                indexExpr = this.index.compile(context)?.beExpressionImplCall(context, this.locRange)?;
                ptrBase = base;
            } else {
                indexExpr = this.index.compile(context)?.beExpressionImplCall(context, this.locRange)?;
                if (auto result = type.index(context, base, indexExpr, this.locRange)?) {
                    return result;
                } else {
                    return this.locRange.fail("index access requires pointer, array or hashmap");
                }
            }

            indexExpr = expectImplicitConvertTo(context, indexExpr, context.nativeWordType, this.locRange)?;

            assert(indexExpr.type.same(context.nativeWordType));
            auto deref = new Dereference(new PointerOffset(ptrBase, indexExpr));
            if (saveIndexValue)
            {
                // This is a very silly idiom.
                auto temp = new PairedTemporary(deref.type, Ownership.gifted);
                auto init = new UninitializeTemporaryStatement(temp);
                (Statement | fail Error) copyDeref() {
                    if (auto stmt = deref.type.copyInto(context, temp, deref)?)
                        return stmt;
                    return new AssignStatement(temp, deref);
                }
                return context.compiler.wrap(sequence(init, copyDeref?), temp, null);
            }
            return deref;
        }
        return context.compiler.consumeTemporary(
                context, allowRefReturn=!saveIndexValue, mayUnwind=false, base, &do_)
            ?.notNull;
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astIndex", [base.quote(quoter), index.quote(quoter)], locRange);
    }
}

class ASTArraySlice : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lower;

    ASTSymbol upper;

    this(this.array, this.lower, this.upper, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        Type sizeT = context.nativeWordType;
        auto array = this.array.compile(context)?.beExpressionImplCall(context, this.locRange)?;

        (nullable Expression | fail Error) do_(Reference array)
        {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "__array", array));

            return new ArraySlice(
                array,
                expectImplicitConvertTo(
                    context,
                    this.lower.compile(context)?.beExpressionImplCall(context, this.locRange)?,
                    sizeT, this.locRange)?,
                expectImplicitConvertTo(
                    context,
                    this.upper.compile(context)?.beExpressionImplCall(context, this.locRange)?,
                    sizeT, this.locRange)?,
                this.locRange);
        }
        return context.compiler.consumeTemporary(
                context, false, false, array, &do_)?.notNull;
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astArraySlice", [
            this.array.quote(quoter),
            this.lower.quote(quoter),
            this.upper.quote(quoter)], locRange);
    }
}

(nullable ASTSymbol | fail Error) parseIndex(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
with (parser.transaction)
{
    auto from = parser.from?;
    if (!parser.accept("[")?)
        return null;
    nullable ASTSymbol index = parseExpression(parser, lexicalContext)?;
    parser.to(from).assert(!!index, "index expected")?;
    auto index = index.notNull;
    parser.expect("]")?;
    commit;
    if (auto iota = index.instanceOf(ASTIota)) {
        return new ASTArraySlice(base, iota.from, iota.to, parser.to(from));
    }
    return new ASTIndexAccess(base, index, parser.to(from));
}

(nullable Symbol | fail Error) accessMemberWithLifetime(
    Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
{
    if (base.instanceOf(Type))
    {
        return accessMember(context, base, member, locRange, allowUndefined);
    }
    if (auto super_ = base.instanceOf(Super))
    {
        return super_.lookup(context, member, locRange);
    }
    Expression baseExpr = base.beExpressionImplCall(context, locRange)?;
    Type baseType = baseExpr.type;

    if (baseType.instanceOf(Pointer)) {
        // cannot trace lifetimes through pointers (TODO?)
        return accessMember(context, base, member, locRange, allowUndefined);
    }

    // speculative lookup :-(
    // TODO exprWithTemporary that handles symbol returns
    auto ret = accessMember(context, baseExpr, member, locRange, allowUndefined)?;
    if (!ret || !ret.instanceOf(Expression)) return ret;
    /**
     * - temporize lhs
     * - copyInto member
     * - destroy lhs
     */
    (nullable Expression | fail Error) do_(Reference baseExpr) {
        auto ret = accessMember(
                context, baseExpr, member, locRange, allowUndefined)?
            .instanceOf(Expression)
            .notNull;
        auto tempRet = new PairedTemporary(ret.type, Ownership.gifted); // temporary since we copyInto
        auto initTemp = new UninitializeTemporaryStatement(tempRet);
        (Statement | fail Error) copyTemp() {
            if (auto stmt = ret.type.copyInto(context, tempRet, ret)?)
                return stmt;
            return new AssignStatement(tempRet, ret);
        }

        nullable Statement endLifetime = baseType.endLifetime(context, baseExpr);

        return new WrapExpression(sequence(initTemp, copyTemp?), tempRet, endLifetime);
    }
    // SHIT
    // we need a reference on the lhs for assignments
    // that's fine if it's a struct, but for a class? always force nontemporary, because it's contained in the
    // class lifetime?
    // TODO handle member access of temporaries
    // for instance with an ExprReturnType analogous to StatementReturnType, that gathers temp destructors

    // if lhs is nontemp, just use StructReference
    if (baseExpr.info.ownership != Ownership.gifted) {
        return accessMember(context, baseExpr, member, locRange, allowUndefined)?
            .instanceOf(Expression);
    }
    return context.compiler.exprWithTemporary(baseExpr, &do_);
}

(nullable Symbol | fail Error) accessMember(
    Context context, Symbol base, string member, LocRange locRange, bool allowUndefined)
{
    if (!context.namespace) return null;
    if (auto type = base.instanceOf(Type)) {
        auto protection = type.protectionAt(context.namespace.notNull);
        return type.accessMember(context, null, member, protection, locRange);
    }

    locRange.assert(!!base.instanceOf(Expression), "expected expression for member access")?;
    mut Expression baseExpr = base.beExpressionImplCall(context, locRange)?;

    while (baseExpr.type.instanceOf(Pointer)) {
        baseExpr = new Dereference(baseExpr);
    }

    auto protection = baseExpr.type.protectionAt(context.namespace.notNull);
    if (auto field = baseExpr.type.accessMember(context, baseExpr, member, protection, locRange)?)
        return field;

    if (allowUndefined) return null;
    return locRange.fail("$(baseExpr.type.repr): no such field '$member'");
}

class ASTMember : ASTMemberBase
{
    override (Symbol | fail Error) compile(Context context)
    {
        // UFCS part two
        // support `foo.bar` as implicit `bar(foo)` if `foo` has no member `bar`
        // TODO merge with ASTCall UFCS code (they should be the same)
        if (auto base = this.base.compile(context)?.isExpressionImplCall(context, this.locRange)?) {
            auto member = accessMember(context, base, this.member, this.locRange, allowUndefined=true)?;
            if (!member) {
                auto callable = context.namespace.lookup(this.member, context, this.locRange)?;
                // if `foo` has no `bar` but there is a `bar` symbol:
                if (callable) {
                    auto target = new ASTIdentifier(this.member, false, this.locRange);
                    // bar(foo)
                    auto args = [ASTArgument(this.base, "", this.locRange)];
                    return (new ASTCall(target, args, this.locRange)).compile(context);
                }
            }
        }

        if (auto ret = accessMemberWithLifetime(
            context, this.base.compile(context)?, this.member, this.locRange, false)?)
        {
            return ret;
        }
        return this.locRange.fail("Member '$(this.member)' not found");
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astMember", [
            this.base.quote(quoter),
            quoter.compiler.astStringLiteral(this.member, locRange)], locRange);
    }
}

(nullable ASTMember | fail Error) parseMember(Parser parser, ASTSymbol base)
{
    parser.begin;
    // don't accept '..' or '.(': conflicting syntax
    if (parser.accept("..")? || parser.accept(".(")? || !parser.accept(".")?)
    {
        parser.revert;
        return null;
    }
    auto from = parser.from?;
    string name = parser.parseIdentifier?;
    parser.assert_(name.length > 0, "member expected")?;
    parser.commit;
    return new ASTMember(base, name, parser.to(from));
}

class ParenPropertyNamespace : Namespace
{
    Expression frame;

    Symbol value;

    this(this.parent, this.frame, this.value) { this.isContextScope = parent.isContextScope; }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        if (name == "that") {
            if (auto latent = this.value.instanceOf(LatentSymbol)) {
                return latent.resolve(context);
            }
            return value;
        }
        if (auto ret = accessMemberWithLifetime(
            context.withFramePointer(this.frame), value, name, locRange, allowUndefined=true)?)
        {
            return ret;
        }

        if (this.parent) return this.parent.lookup(name, context, locRange);
        return null;
    }
}

class ASTParenPropertyExpression : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol prop;

    this(this.base, this.prop, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto baseExpr = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        (Expression | fail Error) do2(Expression baseExpr) {
            (nullable Expression | fail Error) do1(Expression baseExpr) {
                assert(!!context.framePointer);
                auto context = context.withNamespace(
                    new ParenPropertyNamespace(context.namespace, context.framePointer.notNull, baseExpr));
                return this.prop.compile(context)?.beExpressionImplCall(context, this.locRange);
            }
            if (auto ret = context.compiler.exprWithTemporaryExpr(baseExpr, &do1)?) return ret;
            assert(false);
        }
        return context.compiler.consume(context, baseExpr, &do2);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTParenPropertyExpression", __RANGE__), [
                this.base.quote(quoter),
                this.prop.quote(quoter),
                quoter.quoteLocRange(this.locRange)], __RANGE__);
    }

    override string repr() {
        return "$(this.base.repr).($(this.prop.repr))";
    }
}

(nullable ASTParenPropertyExpression | fail Error) parseParenPropertyExpression(
    Parser parser, LexicalContext lexicalContext, ASTSymbol base
) {
    parser.begin;
    if (parser.accept("..")? || !parser.accept(".")? || !parser.accept("(")?) // don't accept '..'
    {
        parser.revert;
        return null;
    }
    auto from = parser.from?;
    auto sym = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
    if (!sym) return parser.fail("expression expected");
    auto sym = sym.notNull;
    if (!parser.accept(")")?) return parser.fail("closing parenthesis expected");
    parser.commit;
    return new ASTParenPropertyExpression(base, sym, parser.to(from));
}

class ASTPropagateFailureExpr : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto base = this.base.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        auto either = base.type.instanceOf(Either);
        context.assert2(!!either, this.locRange, "base of '?' must be sumtype")?;
        mut ASTEitherCaseExprCase[] cases;
        for (k, v in either.types) {
            cases ~= ASTEitherCaseExprCase(
                __RANGE__,
                new ASTSymbolHelper(v.type),
                "a",
                return_=v.fail,
                expr=new ASTIdentifier("a", false, __RANGE__)
            );
        }
        auto caseExpr = new ASTEitherCaseExpr(__RANGE__, new ASTSymbolHelper(base), cases);
        context.pushErrorLoc(this.locRange);
        auto ret = caseExpr.compile(context);
        context.popErrorLoc;
        return ret;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTPropagateFailureExpr'!"); assert(false); }

    override string repr() { return this.base.repr ~ "?"; }
}

(nullable ASTSymbol | fail Error) parsePropagate(Parser parser, LexicalContext context, ASTSymbol left)
{
    auto from = parser.from?;
    parser.begin;
    if (!parser.accept("?")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    return new ASTPropagateFailureExpr(left, parser.to(from));
}

(ASTSymbol | fail Error) parseProperties(Parser parser, LexicalContext lexicalContext, mut ASTSymbol current)
{
    while (true)
    {
        if (ASTSymbol instanceOf = parser.parseInstanceOf(lexicalContext, current)?)
        {
            current = instanceOf;
            continue;
        }
        auto macroArgs = new ParsePropertyArgs(parser, lexicalContext, current);

        auto startLevel = parser.level;
        lexicalContext.macroState.applyMacro(macroArgs);
        parser.loc.hardCheck(parser.level == startLevel, "macro parse rule imbalance");

        if (ASTSymbol result = macroArgs.result?)
        {
            current = result;
            continue;
        }

        if (ASTSymbol caseExpr = parser.parseEitherCaseExpr(lexicalContext, current)?)
        {
            current = caseExpr;
            continue;
        }
        if (ASTSymbol call = parser.parseCall(lexicalContext, current)?)
        {
            current = call;
            continue;
        }
        if (ASTSymbol propagateExpr = parser.parsePropagate(lexicalContext, current)?)
        {
            current = propagateExpr;
            continue;
        }
        if (ASTSymbol prop = parser.parseParenPropertyExpression(lexicalContext, current)?)
        {
            current = prop;
            continue;
        }
        if (ASTSymbol memberAccess = parser.parseMember(current)?)
        {
            current = memberAccess;
            continue;
        }
        if (ASTSymbol indexAccess = parser.parseIndex(lexicalContext, current)?)
        {
            current = indexAccess;
            continue;
        }
        if (ASTSymbol templateInstance = parser.parseTemplateInstantiation(lexicalContext, current)?)
        {
            current = templateInstance;
            continue;
        }
        return current;
    }
}

class ASTDereference : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new Dereference(this.base.compile(context)?.beExpression(this.locRange)?);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall(
            "astDereference", [this.base.quote(quoter)], locRange);
    }
}

class ASTReference : ASTSymbol
{
    ASTSymbol base;

    this(this.base, this.locRange) { }

    override (Expression | fail Error) compile(Context context)
    {
        auto base = this.base.compile(context)?;
        // &function
        if (Function fun = base.instanceOf(Function))
            return new FunctionReference(fun);
        if (LateSymbol lateSym = base.instanceOf(LateSymbol)) {
            (nullable Expression | fail Error) do1(Expression baseExpr) {
                auto funcPtr = lateSym.resolve(context, baseExpr);
                auto voidp = once new Pointer(new Void);
                auto contextPtr = lateSym.patchContext(context, new PointerCast(voidp, baseExpr));
                return new DelegateExpr(funcPtr, contextPtr);
            }
            (Expression | fail Error) do2(Expression baseExpr)
            {
                return context.compiler.exprWithTemporaryExpr(baseExpr, &do1)?.notNull;
            }
            return context.compiler.consume(context, lateSym.baseExpr, &do2);
        }
        if (auto nestfn = base.instanceOf(ClassMethodPtr)) {
            (nullable Expression | fail Error) doExpr(Expression thisPtr) {
                return new DelegateExpr(nestfn.funcPtr, thisPtr);
            }
            (nullable Expression | fail Error) doRef(Reference thisValue) {
                return doExpr(context.compiler.reference(thisValue));
            }
            if (nestfn.valueIsPtr) {
                return context.compiler.exprWithTemporaryExpr(nestfn.thisValue, &doExpr)?.notNull;
            } else {
                return context.compiler.exprWithTemporary(nestfn.thisValue, &doRef)?.notNull;
            }
        }
        Expression baseExpression = base.beExpression(this.locRange)?;

        locRange.assert(!!baseExpression.instanceOf(Reference), "&expr: expr not a reference")?;

        return new ReferenceExpression(baseExpression.instanceOf(Reference).notNull);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall(
            "astReference", [this.base.quote(quoter)], locRange);
    }
}

class Lambda : Type
{
    TemplateDecl decl;

    string repr_;

    this(this.decl, this.repr_) {
        this.zeroInitializable = true;
    }

    override BackendType emit(Platform platform) {
        return once (new Pointer(new Void)).emit(platform);
    }

    override (nullable Expression | fail Error) callExpr(
        Context context, LocRange locRange, Expression base, ASTArgument[] args)
    {
        // Reconstruct a ScopeBoundTemplateDecl using `base`
        auto scopeTempl = new ScopeBoundTemplateDecl(this.decl, base);
        // Instantiate with `args`' types
        Expression[] argExprs = [
            arg.sym.compile(context)?.beExpressionImplCall(context, locRange)? for arg in args];
        auto instance = scopeTempl.instantiate(context, locRange, [arg.type for arg in argExprs])?;
        // call(`args`)
        return .call(context, new ASTSymbolHelper(instance), args, locRange, autoCall=true);
    }

    override bool same(Type other) {
        if (auto otherLambda = other.instanceOf(Lambda)) {
            return this.decl.same(otherLambda.decl);
        }
        return false;
    }

    override string mangle() {
        return "__lambda";
    }

    override string repr() {
        return "typeof($(this.repr_))";
    }

    override void hash(Hash hash) {
        hash.adds("lambda");
        hash.adds(this.decl.mangle);
    }
}

class LambdaExpr : Expression
{
    ScopeBoundTemplateDecl templ;

    string repr_;

    this(this.templ, this.repr_) {
        this.type = new Lambda(this.templ.latent, this.repr_);
        this.info = this.templ.frame.info;
    }

    override int emit(Generator output) {
        int reg = this.templ.frame.emit(output);

        return output.fun.bitcast(reg, this.type.emit(output.platform));
    }
    override string repr() {
        return this.repr_;
    }
    override void hash(Hash hash) {
        hash.adds("lambdaexpr");
        hash.adds(this.templ.latent.mangle);
        this.templ.frame.hash(hash);
    }
}

class ASTLambdaExpr : ASTSymbol
{
    string paramName;

    ASTSymbol value;

    MacroState macroState;

    this(this.paramName, this.value, this.macroState, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        /**
         * ({
         *     template lambda__(T) {
         *          typeof(({ mut uninitialized T $paramName; $value; })) lambda__(T $paramName) {
         *              return $value;
         *          }
         *      }
         *      __lambda(lambda__);
         * })
         */
        ASTStatement declareUninitializedT = new ASTVarDeclStatement(
            this.paramName, mutable=true, infer=false, uninitialized=true,
            type=new ASTIdentifier("T", false, __RANGE__), initial=null, __RANGE__);
        auto typeofProbe = new ASTStatementExpression([declareUninitializedT], value, __RANGE__);
        auto typeofLambda = new ASTTypeof(typeofProbe, __RANGE__);
        auto returnLambdaExpr = new ASTReturnStatement(value, __RANGE__);
        // Hax: Every compilation is unique!
        string lambdaName = "__lambda_$(this.locRange.from.row)_$(context.getLabel)";
        auto lambdaFun = new ASTFunction(
            lambdaName, typeofLambda, [
                ASTParameter(paramName, mutable=false, new ASTIdentifier("T", false, __RANGE__), __RANGE__)],
            isDeclaration=false, __RANGE__, statement=returnLambdaExpr, this.macroState);
        auto astTemplateDecl = new ASTTemplateDecl(lambdaName, ["T"], lambdaFun);
        auto templateDecl = new ScopeBoundTemplateDecl(
            new TemplateDecl(context.namespace, astTemplateDecl),
            context.framePointer);
        string repr = "$paramName => $(this.value.repr)";

        return new LambdaExpr(templateDecl, repr);
    }
}

(nullable ASTSymbol | fail Error) parseLambdaExpression(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    auto arg = parser.parseIdentifier?;
    if (!arg.length || !parser.accept("=>")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    auto expr = parser.parseExpression(lexicalContext)?;
    parser.to(from).assert(!!expr, "lambda expression expected")?;
    return new ASTLambdaExpr(arg, expr.notNull, lexicalContext.macroState, parser.to(from));
}

(nullable ASTSymbol | fail Error) parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
{
    auto from = parser.from?;
    if (parser.accept("*")?)
    {
        nullable ASTSymbol next = parseExpressionLeaf(parser, lexicalContext)?;

        return new ASTDereference(next.notNull, parser.to(from));
    }
    if (parser.accept("&")?)
    {
        nullable ASTSymbol next = parseExpressionLeaf(parser, lexicalContext)?;

        return new ASTReference(next.notNull, parser.to(from));
    }
    if (parser.acceptIdentifier("new")?)
    {
        auto type = parser.parseType(lexicalContext)?;
        if (!type) {
            return parser.fail("type expected");
        }
        mut ASTArgument[] args;
        if (parser.accept("(")?)
        {
            args = parseArgumentList(parser, lexicalContext)?;
        }

        return new ASTNewExpression(type.notNull, args, parser.to(from));
    }
    if (parser.acceptIdentifier("sizeof")?)
    {
        parser.expect("(")?;
        parser.begin;
        mut nullable ASTSymbol sym = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        if (!sym || !parser.accept(")")?) {
            parser.revert;
            parser.begin;
            sym = lexicalContext.compiler.parseExpression(parser, lexicalContext)?;
            if (!sym) return parser.fail("expression expected");
            parser.expect(")")?;
        }
        parser.commit;

        return new ASTSizeOf(sym.notNull);
    }
    if (parser.acceptIdentifier("cast")?)
    {
        parser.expect("(")?;
        nullable ASTSymbol target = parser.parseType(lexicalContext)?;
        if (!target) {
            return parser.fail("type expected");
        }
        parser.expect(")")?;
        nullable ASTSymbol value = parseExpressionLeaf(parser, lexicalContext)?;

        return new ASTCastExpr(target.notNull, value.notNull, parser.to(from));
    }
    if (auto trait = parser.parseTrait(lexicalContext)?) {
        return trait;
    }
    if (auto borrow = parser.parseBorrow(lexicalContext)?) {
        return borrow;
    }
    if (auto lambda = parser.parseLambdaExpression(lexicalContext)?) {
        return lambda;
    }
    if (auto tuple = parser.parseTupleExpression(lexicalContext)?)
    {
        return tuple;
    }
    if (parser.accept("!")?)
    {
        nullable ASTSymbol next = parser.parseExpressionLeaf(lexicalContext)?;

        return new ASTNegation(next.notNull, parser.to(from));
    }
    if (parser.acceptButNot("-", "--")?)
    {
        nullable ASTSymbol next = parser.parseExpressionLeaf(lexicalContext)?;

        parser.to(from).assert(!!next, "expression expected for negation")?;
        return new ASTBinaryOp("-", new ASTIntLiteral(0, parser.to(from)), next.notNull, parser.to(from));
    }
    if (ASTSymbol expr = parser.parseExpressionIncDec(lexicalContext)?)
        return parseProperties(parser, lexicalContext, expr);
    return null;
}

(ASTSymbol | fail Error) parseStringLiteral(
    Parser parser, LexicalContext lexicalContext, string endMarker, LocRange from)
{
    mut string current;
    mut ASTSymbol[] parts;
    void flush() {
        if (current != "") parts ~= new ASTStringLiteral(current, parser.to(from));
        current = "";
    }
    while (parser.text.length < endMarker.length || parser.text[0 .. endMarker.length] != endMarker)
    {
        if (parser.text.length == 0) {
            return parser.fail("expected end of string, got end of file");
        }
        string ch = parser.text[0 .. 1];
        parser.drop(1);
        if (ch == "\\") {
            string ctl = parser.text[0 .. 1];
            parser.dropOneCharNonNewline(1);
            if (ctl == "r") {
                current ~= "\r";
            } else if (ctl == "\$") {
                current ~= "\$";
            } else if (ctl == "n") {
                current ~= "\n";
            } else if (ctl == "t") {
                current ~= "\t";
            } else if (ctl == "\"") {
                current ~= "\"";
            } else if (ctl == "\\") {
                current ~= "\\";
            } else if (ctl == "0") {
                current ~= "\x00"; // TODO \0
            } else if (ctl == "x") {
                char ch1 = parser.text[0], ch2 = parser.text[1];
                int decodeHex(char ch) {
                    if (ch >= "0"[0] && ch <= "9"[0])
                        return cast(int) (ch - "0"[0]);
                    if (ch >= "a"[0] && ch <= "F"[0])
                        return cast(int) ch + 10 - cast(int) "a"[0];
                    if (ch >= "A"[0] && ch <= "F"[0])
                        return cast(int) ch + 10 - cast(int) "A"[0];
                    print("Unknown hex digit '" ~ ch ~ "'");
                    assert(false);
                }
                char ord = cast(char) (decodeHex(ch1) * 16 + decodeHex(ch2));
                current ~= ord;
                parser.drop(2);
            } else {
                print("Unknown control sequence \\$ctl");
                assert(false);
            }
        } else if (ch == "\$") {
            flush;
            if (parser.accept("(")?) {
                auto litFrom = parser.from?;
                nullable ASTSymbol expr = parser.parseExpression(lexicalContext)?;
                parser.to(litFrom).assert(!!expr, "Expression expected.")?;
                parser.expect(")")?;
                parts ~= expr.notNull;
            } else {
                auto varFrom = parser.from?;
                auto var = parser.parseIdentifier?;
                parser.to(varFrom).assert(var != "", "Identifier expected.")?;
                parts ~= new ASTIdentifier(var, moduleLevel=false, parser.to(varFrom));
            }
        } else {
            current ~= ch;
        }
    }
    if (!parser.accept(endMarker)?)
    {
        return parser.fail("this should never happen");
    }
    flush;
    if (parts.length == 0) return new ASTStringLiteral("", parser.to(from));
    if (parts.length == 1) {
        if (auto literal = parts[0].instanceOf(ASTStringLiteral))
            return literal;
    }

    return new ASTFormatString(parts, parser.to(from));
}

(nullable ASTBorrow | fail Error) parseBorrow(Parser parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    auto from = parser.from?;
    if (!parser.accept("__borrow")?)
        return null;
    parser.expect("(")?;
    auto fromSource = parser.from?;
    auto source = parser.parseExpression(lexicalContext)?;
    parser.to(fromSource).assert(!!source, "expression expected")?;
    parser.expect(")")?;
    commit;
    return new ASTBorrow(source.notNull, parser.to(from));
}

/**
 * Even though the lifetime logic does not support this, sometimes it's
 * useful to be able to borrow an expression anyways.
 * (for instance, for (a in array) borrows a from array.
 */
class ASTBorrow : ASTSymbol
{
    ASTSymbol source;

    this(this.source, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto source = this.source.compile(context)?.beExpression(this.locRange)?;
        return new OverrideLifetimeExpr(source, ExprInfo(mutable=false, Ownership.borrowed));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTBorrow", __RANGE__), [
                this.source.quote(quoter),
                quoter.quoteLocRange(this.locRange)], __RANGE__);
    }
}

// i++, i--, ++i, --i
class ASTPrePostIncDec : ASTSymbol
{
    ASTSymbol target;

    ((:pre | :post) when, (:inc | :dec) what) op;

    this(this.op, this.target, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        auto target = target.compile(context)?.beExpressionImplCall(context, locRange)?;
        locRange.assert5(
            !!target.instanceOf(Reference),
            "cannot ", op.when.case((:pre): "pre", (:post): "post"), "-",
            op.what.case((:inc): "inc", (:dec): "dec"), "rement non-reference target")?;
        (nullable Expression | fail Error) do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ref_", context.compiler.dereference(refptr)));

            return op.when.case(
                (:pre): op.what.case(
                    (:inc): context.compiler.$expr ({ ref_ += 1; ref_; }),
                    (:dec): context.compiler.$expr ({ ref_ -= 1; ref_; })
                ),
                (:post): op.what.case(
                    (:inc): context.compiler.$expr ({ auto ret = ref_; ref_ += 1; ret; }),
                    (:dec): context.compiler.$expr ({ auto ret = ref_; ref_ -= 1; ret; })))
                .compile(context)?.beExpression(__RANGE__)?;
        }
        auto refptr = context.compiler.reference(target.instanceOf(Reference).notNull);
        return context.compiler.exprWithTemporaryExpr(refptr, &do_)?.notNull;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTPreOp'!"); assert(false); }
    override string repr() {
        auto opText = op.what.case((:inc): "++", (:dec): "--");
        return op.when.case((:pre): opText ~ target.repr, (:post): target.repr ~ opText);
    }
}

(nullable ASTSymbol | fail Error) parseExpressionIncDec(Parser parser, LexicalContext lexicalContext)
with (parser.transaction)
{
    mut (:inc | :dec | :none) pre = :none, post = :none;
    auto from1 = parser.from?;
    if (parser.accept("++")?) pre = :inc;
    else if (parser.accept("--")?) pre = :dec;
    nullable ASTSymbol ret = parseExpressionBase(parser, lexicalContext)?;
    if (!ret) return null;
    mut auto ret = ret.notNull;
    commit;
    auto from2 = parser.from?;
    if (parser.accept("++")?) post = :inc;
    else if (parser.accept("--")?) post = :dec;
    pre.case {
        (:inc): ret = new ASTPrePostIncDec((:pre, :inc), ret, parser.to(from1));
        (:dec): ret = new ASTPrePostIncDec((:pre, :dec), ret, parser.to(from1));
        (:none): {}
    }
    post.case {
        (:inc): ret = new ASTPrePostIncDec((:post, :inc), ret, parser.to(from2));
        (:dec): ret = new ASTPrePostIncDec((:post, :dec), ret, parser.to(from2));
        (:none): {}
    }
    return ret;
}

// the AST of a LocRange literal recreating the passed loc.
ASTSymbol locRangeExpr(LocRange locRange, LexicalContext lexicalContext)
{
    with (lexicalContext.compiler)
        return astCall(
            astIdentifier("LocRange", __RANGE__), [
                astStringLiteral(locRange.filename, __RANGE__),
                astTupleLiteral([
                    astIntLiteral(locRange.from.row, __RANGE__),
                    astIntLiteral(locRange.from.column, __RANGE__)], __RANGE__),
                astTupleLiteral([
                    astIntLiteral(locRange.to.row, __RANGE__),
                    astIntLiteral(locRange.to.column, __RANGE__)], __RANGE__),
            ], __RANGE__);
}

(nullable ASTSymbol | fail Error) parseExpressionBase(Parser parser, LexicalContext lexicalContext)
{
    {
        auto args = new ParseExpressionBaseArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (ASTSymbol ret = args.symbol?) return ret;
    }
    if (auto destroy_ = parseDestroy(parser, lexicalContext)?) return destroy_;
    parser.begin;
    parser.strip?;
    auto loc = parser.loc;
    auto from = parser.from?;
    if (parser.accept(".")?) {
        // .name is module level
        string name = parser.parseIdentifier?;
        if (name.length) {
            parser.commit;
            return new ASTIdentifier(name, true, parser.to(from));
        }
    }
    parser.revert;
    string name = parser.parseIdentifier?;
    if (name.length)
    {
        if (name == "__RANGE__") return locRangeExpr(parser.to(from), lexicalContext);
        if (name == "\$") return new ASTArrayLength(parser.to(from));
        if (name == "super") return new ASTSuper(parser.to(from));
        return new ASTIdentifier(name, false, parser.to(from));
    }
    {
        parser.begin;
        if (parser.accept(":")?) {
            string symbolIdentifier = parser.parseIdentifier?;
            if (symbolIdentifier != "") {
                parser.commit;
                return new ASTSymbolIdentifier(symbolIdentifier, parser.to(from));
            }
        }
        parser.revert;
    }
    parseFloat(parser).case {
        Error err: return err;
        (:failure): {}
        (:success, double d):
            return new ASTDoubleLiteral(d);
        (:success, float f):
            return new ASTFloatLiteral(f);
    }
    parseNumber(parser).case {
        Error err: return err;
        (:failure): {}
        (:success, int i):
            return new ASTIntLiteral(i, parser.to(from));
    }
    if (parser.accept("\"")?)
    {
        return parseStringLiteral(parser, lexicalContext, "\"", from);
    }
    if (auto statementExpr = parseStatementExpr(parser, lexicalContext)?)
        return statementExpr;
    if (parser.accept("(")?)
    {
        nullable ASTSymbol result = parseExpression(parser, lexicalContext)?;

        parser.expect(")")?;
        return result.notNull;
    }
    if (auto result = parseArrayLiteral(parser, lexicalContext)?)
        return result;
    return null;
    /*return parser.fail("Base expression expected.");*/
}

(ASTSymbol | fail Error) parseBitAnd(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from?;
        if (parser.acceptButNot("&", "&&")?)
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("&", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | fail Error) parseBitXor(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from?;
        if (parser.accept("^")?)
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("^", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | fail Error) parseBitOr(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin;
        auto from = parser.from?;
        if (parser.acceptButNot("|", "||")?)
        {
            parser.commit;
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("|", left, right, parser.to(from));
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

(ASTSymbol | fail Error) parseBitShift(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from?;
        if (parser.accept("<<")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("<<", left, right, parser.to(from));
        }
        else if (parser.accept(">>>")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp(">>>", left, right, parser.to(from));
        }
        else if (parser.accept(">>")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp(">>", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | fail Error) parseAddSubCat(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from?;
        if (parser.acceptButNot("+", "++")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("+", left, right, parser.to(from));
        }
        else if (parser.acceptButNot("-", "--")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("-", left, right, parser.to(from));
        }
        else if (parser.accept("~")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("~", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | fail Error) parseMulDiv(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from?;
        if (parser.accept("*")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("*", left, right, parser.to(from));
        }
        else if (parser.accept("/")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("/", left, right, parser.to(from));
        }
        else if (parser.accept("%")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("%", left, right, parser.to(from));
        }
        else return left;
    }
}

(ASTSymbol | fail Error) parseBoolAnd(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from?;
        if (parser.accept("&&")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("&&", left, right, parser.to(from));
        } else return left;
    }
}

(ASTSymbol | fail Error) parseBoolOr(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int myLevel)
{
    while (true)
    {
        auto from = parser.from?;
        if (parser.accept("||")?)
        {
            ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

            left = new ASTBinaryOp("||", left, right, parser.to(from));
        } else return left;
    }
}

// a .. b
class ASTIota : ASTSymbol
{
    ASTSymbol from;

    ASTSymbol to;

    this(this.from, this.to, this.locRange) { }

    override (Expression | fail Error) compile(Context context)
    {
        auto iotaValue = context.compiler.$expr ({ import package(compiler).std.range.iota : Iota; Iota($from, $to); });

        return iotaValue.compile(context)?.beExpression(__RANGE__)?;
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astIota", [
            from.quote(quoter),
            to.quote(quoter)], locRange);
    }
}

(ASTSymbol | fail Error) parseIota(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    auto from = parser.from?;
    if (parser.accept("..")?)
    {
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTIota(left, right, parser.to(from));
    }
    return left;
}

(ASTSymbol | fail Error) parseComparison(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    auto from = parser.from?;
    if (parser.accept("==")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("==", left, right, locRange);
    }
    if (parser.accept("!=")?) // same as !(a == b)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTNegation(new ASTBinaryOp("==", left, right, locRange), locRange);
    }
    if (parser.accept("is")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("is", left, right, locRange);
    }
    if (parser.accept("!is")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTNegation(new ASTBinaryOp("is", left, right, locRange), locRange);
    }
    if (parser.accept(">=")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp(">=", left, right, locRange);
    }
    if (parser.acceptButNot(">", ">>")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp(">", left, right, locRange);
    }
    if (parser.accept("<=")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("<=", left, right, locRange);
    }
    if (parser.acceptButNot("<", "<<")?)
    {
        auto locRange = parser.to(from);
        ASTSymbol right = expectArithmetic(parser, lexicalContext, myLevel + 1)?;

        return new ASTBinaryOp("<", left, right, locRange);
    }
    return left;
}

(ASTSymbol | fail Error) parseArithmetic(Parser parser, LexicalContext lexicalContext, mut ASTSymbol left, int level)
{
    if (level <= 9) left = parseBitAnd(parser, lexicalContext, left, 9)?;
    if (level <= 8) left = parseBitXor(parser, lexicalContext, left, 8)?;
    if (level <= 7) left = parseBitOr(parser, lexicalContext, left, 7)?;
    if (level <= 6) left = parseMulDiv(parser, lexicalContext, left, 6)?;
    if (level <= 5) left = parseAddSubCat(parser, lexicalContext, left, 5)?;
    if (level <= 4) left = parseBitShift(parser, lexicalContext, left, 4)?;
    if (level <= 3) left = parseIota(parser, lexicalContext, left, 3)?;
    if (level <= 2) left = parseComparison(parser, lexicalContext, left, 2)?;
    if (level <= 1) left = parseBoolAnd(parser, lexicalContext, left, 1)?;
    if (level <= 0) left = parseBoolOr(parser, lexicalContext, left, 0)?;
    return left;
}

(ASTSymbol | fail Error) expectArithmetic(Parser parser, LexicalContext lexicalContext, int level)
{
    auto leaf = parseExpressionLeaf(parser, lexicalContext)?;
    parser.assert_(!!leaf, "Expression leaf expected")?;

    return parseArithmetic(parser, lexicalContext, leaf.notNull, level);
}

(nullable ASTSymbol | fail Error) parseExpression(Parser parser, LexicalContext lexicalContext)
{
    if (auto leaf = parseExpressionLeaf(parser, lexicalContext)?)
        return parseArithmetic(parser, lexicalContext, leaf, 0);
    return null;
}

class ASTReturnStatement : ASTStatement
{
    ASTSymbol value;

    this(this.value, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        mut Expression expr = this.value.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        Type ret = findParent!FunctionScope(context.namespace).ret;
        expr = expectImplicitConvertTo(context, expr, ret, this.locRange)?;

        /**
         * - alloca
         *   - copyInto the value
         *   - or assign the value (if it's a temporary and we can steal its reference)
         * - unwind stack
         * - ret the alloca
         */
        auto temp = new PairedTemporary(ret, Ownership.owned);
        auto init = new UninitializeTemporaryStatement(temp);
        (Statement | fail Error) escapeValueStmt()
        {
            if (expr.info.ownership == Ownership.gifted || expr.info.ownership == Ownership.global)
                return new AssignStatement(temp, expr);
            if (auto copyInto = ret.copyInto(context, temp, expr)?)
                return copyInto;
            return new AssignStatement(temp, expr);
        }
        mut Statement returnStmt = sequence(init, escapeValueStmt?);
        returnStmt = unwindScope(context, findParent!FunctionScope(context.namespace), returnStmt)?;
        returnStmt = sequence(returnStmt, new ReturnStatement(temp));
        // no need for stack cleanup after a return.

        return StatementCompileResult(returnStmt, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astReturn", [value.quote(quoter)], locRange);
    }
}

// the return expression of "return;"
class ASTVoidExpression : ASTSymbol
{
    this(this.locRange) { }

    override (Expression | fail Error) compile(Context context) { return once new VoidExpression; }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol[] args;
        return quoter.compilerCall("astVoidLiteral", args, locRange);
    }
}

class VoidExpression : Expression
{
    this() { this.type = once new Void; this.info = ExprInfo(false, Ownership.owned); }
    override int emit(Generator generator)
    {
        return generator.fun.voidLiteral;
    }
    override void hash(Hash hash) { hash.adds("VoidExpression"); }
}

(nullable ASTReturnStatement | fail Error) parseReturn(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    string identifier = parser.parseIdentifier?;
    if (identifier != "return")
    {
        parser.revert;
        return null;
    }
    mut uninitialized ASTSymbol expr;
    if (parser.accept(";")?) // return;
    {
        expr = new ASTVoidExpression(parser.to(from));
    }
    else
    {
        expr = parseExpression(parser, lexicalContext)?.notNull;
        parser.expect(";")?;
    }
    parser.commit;
    return new ASTReturnStatement(expr, parser.to(from));
}

(Statement | fail Error) unwindScope(Context context, nullable Namespace target, Statement body_)
{
    mut Statement result = body_;
    mut nullable Namespace current = context.namespace;
    while (current && current !is target) {
        if (auto unwindable = current.instanceOf(Unwindable)) {
            result = sequence(result, unwindable.unwind(context)?);
        }
        if (auto declHolder = current.instanceOf(DeclarationHolder)) {
            auto var = declHolder.accessDecl(context.compiler);
            if (var.info.ownership == Ownership.owned) {
                auto type = var.type;
                if (auto destroy = type.endLifetime(context, var)) {
                    result = sequence(result, destroy);
                }
            }
        }
        current = current.parent;
    }
    return result;
}

(Expression | fail Error) pickEither(
    Context context, Either either, Expression source, Type extractType, LocRange locRange)
{
    mut ASTEitherCaseExprCase[] cases;
    for (k, v in either.types) {
        // return out all types that aren't the extract type
        bool return_ = !v.type.same(extractType);
        cases ~= ASTEitherCaseExprCase(
            __RANGE__,
            new ASTSymbolHelper(v.type),
            "a",
            return_=return_,
            expr=new ASTIdentifier("a", false, __RANGE__));
    }

    auto case_ = new ASTEitherCaseExpr(__RANGE__, new ASTSymbolHelper(source), cases);

    context.pushErrorLoc(locRange);
    auto ret = case_.compile(context);
    context.popErrorLoc;
    return ret;
}

private Type typeWithoutFail(Either source)
{
    if ([count a in source.types where !a.fail] == 1) {
        return [first a.type for a in source.types where !a.fail];
    }
    return new Either([a for a in source.types where !a.fail]);
}

class InfoExpression : Expression
{
    Expression base;

    this(this.base, this.info) { this.type = base.type; }

    override int emit(Generator output) { return base.emit(output); }
    // TODO hash ExprInfo
    override void hash(Hash hash) { hash.adds("InfoExpression"); base.hash(hash); }
}

Type makeNotNullable(Type type) {
    if (auto classType = type.instanceOf(ClassType))
        return classType.makeNotNullable;
    else if (auto intfType = type.instanceOf(IntfType))
        return intfType.makeNotNullable;
    else assert(false);
}

class ASTIfStatement : ASTStatement
{
    (ASTSymbol | ASTVarDeclStatement | ASTVarExtractDeclStatement) test;

    ASTStatement then;

    nullable ASTStatement else_;

    this(this.test, this.then, this.else_, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        mut nullable Statement prelude; // var decl statement
        mut nullable Expression test;
        mut nullable Statement epilog; // either decl value assignment
        mut auto testSucceedsContext = context;
        this.test.case {
            ASTSymbol symbol: {
                // TODO pick assignment
                test = symbol.compile(context)?.beExpressionImplCall(context, this.locRange)?;
            }
            ASTVarDeclStatement vardecl: {
                auto initial = vardecl.initial.compile(context)?.beExpressionImplCall(context, vardecl.locRange)?;

                // `if (Foo var = some nullable Foo)`:
                //   - cache `some`, test for nullness, then declare Foo var.
                if (initial.type.zeroInitializable && context.compiler.isClassType(initial.type)) {
                    Type notNullableType = initial.type.makeNotNullable;

                    auto tempInitial = new PairedTemporary(initial.type, initial.info.ownership);
                    auto initTemp = new InitializeTemporaryStatement(tempInitial, initial);

                    prelude = initTemp;
                    // don't worry about memory management - if it's non-null, we'll stick it in a variable,
                    // and that'll take care of refcounting for us.
                    test = new InfoExpression(tempInitial, ExprInfo(false, Ownership.global));

                    auto actualVarDecl = new ASTVarDeclStatement(
                        vardecl.name, mutable=vardecl.mutable, infer=false, uninitialized=false,
                        type=new ASTSymbolHelper(notNullableType),
                        initial=new ASTSymbolHelper(new PointerCast(notNullableType, tempInitial)),
                        vardecl.locRange);
                    auto pair = actualVarDecl.compile(context)?;
                    epilog = pair.statement;
                    testSucceedsContext = pair.context;
                } else {
                    auto pair = vardecl.compile(context)?;
                    prelude = pair.statement;
                    testSucceedsContext = pair.context;
                    auto var = testSucceedsContext.namespace.lookup(
                            vardecl.name, context, this.locRange)?
                        .notNull
                        .beExpression(this.locRange)?;
                    // TODO lookup() that handles the stackframe thing
                    test = var.beExpressionImplCall(context, this.locRange)?;
                }
            }
            ASTVarExtractDeclStatement extractdecl: {
                return extractdecl.locRange.fail(
                    "This syntax is disabled at the moment until I figure out what to use it for.");
                // if (auto var <- expr) where expr is (nullable T, fail)
                // validate source is Either
                // TODO extract interface
                auto source = extractdecl.source.compile(context)?
                    .beExpressionImplCall(context, extractdecl.locRange)?;
                auto sourceType = source.type.instanceOf(Either);
                extractdecl.locRange.assert(!!sourceType, "source of <- decl must be sumtype, not $(source.type.repr)")?;
                auto sourceType = sourceType.notNull;
                // FIXME check lifetime here
                auto tempSource = new PairedTemporary(source.type, source.info.ownership);
                auto initTemp = new InitializeTemporaryStatement(tempSource, source);
                // check expected type
                auto remainingType = typeWithoutFail(sourceType);
                mut Type testedType = remainingType;
                if (remainingType.zeroInitializable && context.compiler.isClassType(remainingType)) {
                    testedType = remainingType.makeNotNullable;
                }
                if (!extractdecl.infer) {
                    auto declType = extractdecl.type.compile(context)?.beType2(extractdecl.locRange)?;
                    extractdecl.locRange.assert(
                        declType.same(testedType),
                        "expected $(declType.repr), but got $(testedType.repr)")?;
                }

                auto value = pickEither(context, sourceType, tempSource, remainingType, extractdecl.locRange)?;
                prelude = initTemp;
                test = new InfoExpression(value, ExprInfo(false, Ownership.global));

                auto actualVarDecl = new ASTVarDeclStatement(
                    extractdecl.name, mutable=extractdecl.mutable, infer=false, uninitialized=false,
                    type=new ASTSymbolHelper(testedType),
                    initial=new ASTSymbolHelper(new PointerCast(testedType, value)),
                    extractdecl.locRange);
                auto pair = actualVarDecl.compile(context)?;
                epilog = pair.statement;
                testSucceedsContext = pair.context;
            }
        }
        auto thenPair = this.then.compile(testSucceedsContext)?;
        Statement then = unwindScope(thenPair.context, context.namespace, thenPair.statement)?;
        mut nullable Statement else_;
        if (this.else_) {
            auto elsePair = this.else_.compile(context)?;
            else_ = unwindScope(elsePair.context, context.namespace, elsePair.statement)?;
        }

        auto test = truthy(context, test.notNull, this.locRange)?;
        auto ifStmt = new IfStatement(test, sequence2(epilog, then), else_);

        return StatementCompileResult(sequence2(prelude, ifStmt), context);
    }

    override ASTSymbol quote(Quoter quoter) {
        if (!else_) {
            return quoter.compilerCall("astIf", [
                test.case(
                    ASTSymbol symbol: symbol.quote(quoter),
                    ASTVarDeclStatement stmt: stmt.quote(quoter),
                    ASTVarExtractDeclStatement stmt: stmt.quote(quoter)),
                then.quote(quoter),
                quoter.compiler.astIdentifier("null", locRange)], locRange);
        }
        return quoter.compilerCall("astIf", [
            test.case(
                ASTSymbol symbol: symbol.quote(quoter),
                ASTVarDeclStatement stmt: stmt.quote(quoter),
                ASTVarExtractDeclStatement stmt: stmt.quote(quoter)),
            then.quote(quoter),
            else_.quote(quoter)], locRange);
    }
}

(nullable ASTIfStatement | fail Error) parseIf(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    string identifier = parser.parseIdentifier?;
    if (identifier != "if")
    {
        parser.revert;
        return null;
    }
    mut uninitialized (ASTSymbol | ASTVarDeclStatement | ASTVarExtractDeclStatement) test;
    auto locRange = parser.to(from);
    parser.expect("(")?;
    auto vardecl = parseVarDecl(parser, lexicalContext, requireInitializer=true)?;
    if (auto vardecl = vardecl)
        test = vardecl;
    else {
        auto varextractdecl = parseVarExtractDecl(parser, lexicalContext)?;
        if (auto varextractdecl = varextractdecl) test = varextractdecl;
        else {
            test = parseExpression(parser, lexicalContext)?.notNull;
        }
    }
    parser.expect(")")?;
    ASTStatement thenStmt = parseStatement(parser, lexicalContext)?;
    mut nullable ASTStatement elseStatement;
    if (parser.accept("else")?)
    {
        elseStatement = parseStatement(parser, lexicalContext)?;
    }
    parser.commit;
    return new ASTIfStatement(test, thenStmt, elseStatement, locRange);
}

(nullable ASTStatement | fail Error) parseBreakCont(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    string identifier = parser.parseIdentifier?;
    if (identifier == "break")
    {
        parser.expect(";")?;
        parser.commit;
        return new ASTBreakStatement(parser.to(from));
    }
    if (identifier == "continue")
    {
        parser.expect(";")?;
        parser.commit;
        return new ASTContinueStatement(parser.to(from));
    }
    parser.revert;
    return null;
}

class ASTScopeStatement : ASTStatement
{
    ASTStatement[] statements;

    this(this.statements, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto statements = new Statement[](this.statements.length);
        mut auto subContext = context;
        for (i, statement in this.statements) {
            auto pair = statement.compile(subContext)?;

            subContext = pair.context;
            statements[i] = pair.statement;
        }
        return StatementCompileResult(
            unwindScope(subContext, context.namespace, new SequenceStatement(statements))?,
            context); // scope ends here
    }

    override ASTSymbol quote(Quoter quoter) {
        auto statements = [statement.quote(quoter) for statement in this.statements];
        return quoter.compilerCall(
            "astScope", [
                quoter.compiler.astArrayLiteralTypeHint(
                    quoter.compiler.astIdentifier("ASTStatement", __RANGE__),
                    statements,
                    this.locRange)], this.locRange);
    }
}

// just a bunch of statements after each other
// (used for int a, b)
class ASTSequenceStatement : ASTStatement
{
    ASTStatement[] statements;

    this(this.statements, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto statements = new Statement[](this.statements.length);
        mut auto subContext = context;
        for (i, statement in this.statements) {
            auto pair = statement.compile(subContext)?;

            subContext = pair.context;
            statements[i] = pair.statement;
        }
        // not a scope!
        return StatementCompileResult(new SequenceStatement(statements), subContext);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto statements = [arg.quote(quoter) for arg in this.statements];
        return quoter.compilerCall(
            "astSequence", [quoter.compiler.astArrayLiteral(statements, this.locRange)], this.locRange);
    }
}

(nullable ASTScopeStatement | fail Error) parseScope(Parser parser, LexicalContext lexicalContext)
{
    auto from = parser.from?;
    if (!parser.accept("{")?)
    {
        return null;
    }
    mut ASTStatement[] statements;
    while (!parser.accept("}")?)
    {
        auto locStmt = parser.loc;
        auto startLevel = parser.level;
        ASTStatement stmt = parseStatement(parser, lexicalContext)?;
        locStmt.hardCheck(parser.level == startLevel, "statement parse rule imbalance");

        statements ~= stmt;
    }
    return new ASTScopeStatement(statements, parser.to(from));
}

(nullable ASTAssignStatement | fail Error) parseAssignment(
    Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    nullable ASTSymbol lhs = parseExpressionLeaf(parser, lexicalContext)?;
    if (!lhs) {
        parser.revert;
        return null;
    }
    auto from = parser.from?;
    mut string operator;
    if (parser.accept("=")?) { }
    else if (parser.accept("+=")?) operator = "+";
    else if (parser.accept("-=")?) operator = "-";
    else if (parser.accept("*=")?) operator = "*";
    else if (parser.accept("/=")?) operator = "/";
    else if (parser.accept("~=")?) operator = "~";
    else if (parser.accept("&=")?) operator = "&";
    else if (parser.accept("|=")?) operator = "|";
    else if (parser.accept("^=")?) operator = "^";
    else {
        parser.revert;
        return null;
    }
    nullable ASTSymbol expr = parseExpression(parser, lexicalContext)?;
    if (!expr) {
        return parser.fail("expression expected");
    }
    mut ASTSymbol expr = expr.notNull;
    parser.commit;
    if (operator.length) {
        // TODO separate AST construct - avoid double compiling lhs?
        expr = new ASTBinaryOp(operator, lhs.notNull, expr, parser.to(from));
    }
    return new ASTAssignStatement(lhs.notNull, expr, parser.to(from));
}

class ASTAssignStatement : ASTStatement
{
    ASTSymbol target;

    ASTSymbol value;

    this(this.target, this.value, this.locRange) {}

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        mut Expression value = this.value.compile(context)?.beExpressionImplCall(context, this.locRange)?;

        // `a[b] = c` special handling
        if (auto astIndex = target.instanceOf(ASTIndexAccess))
        {
            auto base = astIndex.base.compile(context)?.beExpressionImplCall(context, astIndex.locRange)?;
            auto index = astIndex.index.compile(context)?.beExpressionImplCall(context, astIndex.locRange)?;
            if (auto assignment = base.type.indexAssignment(context, base, index, value, this.locRange)?)
                return StatementCompileResult(assignment, context);
        }

        auto compiler = context.compiler;

        Symbol target = this.target.compile(context)?;
        nullable Reference targetref = target.instanceOf(Reference);
        this.locRange.assert(!!targetref, "target of assignment must be a reference")?;
        this.locRange.assert(targetref.info.mutable, "target of assignment must be mutable")?;
        auto targetref = targetref.notNull;
        // Broadly, this check is the reason that 'borrowed' exists.
        // FIXME hasDestructor
        bool hasDtor = !!targetref.type.endLifetime(context, targetref);
        this.locRange.assert(
            targetref.info.ownership != Ownership.borrowed || !hasDtor,
            "cannot reassign to borrowed value with destructor")?;
        auto type = targetref.type;
        value = expectImplicitConvertTo(context, value, type, this.locRange)?;

        /**
         * Order is important here.
         *
         * 1. temporize the RHS. (NO copy ctor!)
         * 2. temporize the old LHS.
         * 3. overwrite the LHS with the temporized RHS. (copy here)
         * 4. destroy the old LHS value.
         *
         * Why this order? Evaluating the RHS might change the LHS address
         * (consider: *f() = *g() - in that case, g() is more likely to
         * invalidate f() than the other way around).
         * Also, the RHS may just *be* the LHS, as in "s = s;"
         * Hence we need to temporize the RHS.
         * The address of LHS is temporized so that the destructor call
         * doesn't lead to a double evaluation.
         * The old LHS value is rescued so that more complex versions of
         * "s = s" don't leave the references in "s" abandoned between
         * endLifetime and moveInto. In other words, since s_2 may depend on s_1,
         * their lifetimes need to overlap.
         *
         * But man, what an ugly-ass dataflow...
         */

        (nullable Statement | fail Error) do1(Expression tmpValue) {
            (nullable Statement | fail Error) do2(Expression tmpLhsPtr) {
                auto tmpLhs = compiler.dereference(tmpLhsPtr);

                (nullable Statement | fail Error) do3(Reference oldLhs) {
                    auto reassign = compiler.move(context, tmpLhs, tmpValue)?;
                    auto cleanup = oldLhs.type.endLifetime(context, oldLhs);

                    return sequence(reassign, cleanup);
                }
                return compiler.stmtWithTemporary(tmpLhs, &do3);
            }
            return compiler.stmtWithTemporaryExpr(compiler.reference(targetref), &do2);
        }
        return StatementCompileResult(
            compiler.stmtWithTemporaryExpr(value, &do1)?.notNull,
            context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astAssign", [target.quote(quoter), value.quote(quoter)], locRange);
    }
}

(nullable ASTAssignStatement | fail Error) parseAssignStatement(
    Parser parser, LexicalContext lexicalContext)
{
    if (auto ret = parseAssignment(parser, lexicalContext)?)
    {
        parser.expect(";")?;
        return ret;
    }
    return null;
}

class ASTVarDeclStatement : ASTStatement
{
    string name;

    bool mutable;

    bool infer;

    bool uninitialized;

    nullable ASTSymbol type;

    nullable ASTSymbol initial;

    this(this.name, this.mutable, this.infer, this.uninitialized,
        this.type, this.initial, this.locRange)
    {
        assert(!uninitialized || mutable);
        assert(infer == !type);
        assert(!infer || initial);
        assert(!uninitialized || !initial);
    }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        mut nullable Type type;
        if (this.type) type = this.type.compile(context)?.beType2(this.locRange)?;
        if (this.initial)
        {
            mut auto initial = this.initial.compile(context)?.beExpressionImplCall(context, this.locRange)?;
            if (this.infer) {
                assert(!type);
                type = initial.type;
            } else {
                assert(!!type);
                initial = expectImplicitConvertTo(context, initial, type.notNull, this.locRange)?;
            }
            auto type = type.notNull;

            // can we borrow the expression?
            // ie. does its lifetime dominate our lifetime?
            // for this, both we and it must have an uninterruptible, ie. non-mut lifetime.
            if (initial.info.ownership.(that == Ownership.owned || that == Ownership.borrowed)
                && !initial.info.mutable && !this.mutable)
            {
                // print("$(this.locRange.repr):$(initial.info.repr): borrowing $(initial.repr) for $(this.name)");
                // don't double-own the value, it's covered by its own ownership
                // we aren't mutable, so we can safely borrow the initializer.
                auto decl = new VariableDeclaration(
                    context.namespace, this.name, type, ExprInfo(false, Ownership.borrowed), false);
                auto assign = context.compiler.assignStatement(decl.accessDecl(context.compiler), initial);

                return StatementCompileResult(assign, context.withNamespace(decl));
            }

            // print("$(this.locRange.repr):$(initial.info.repr): moving $(initial.repr) for $(this.name)");
            // otherwise we'll hold a reference ourselves.
            auto decl = new VariableDeclaration(
                context.namespace, this.name, type, ExprInfo(mutable, Ownership.owned), false);

            return StatementCompileResult(
                move(context, decl.accessDecl(context.compiler), initial)?,
                context.withNamespace(decl));
        }
        else if (this.uninitialized)
        {
            auto type = type.notNull;
            auto decl = new VariableDeclaration(
                context.namespace, this.name, type, ExprInfo(mutable, Ownership.owned), hidden=false);

            // Still zero-init.
            return StatementCompileResult(
                new AssignStatement(decl.accessDecl(context.compiler), new NullExpr(type)),
                context.withNamespace(decl));
        }
        else
        {
            auto type = type.notNull;
            if (!type.zeroInitializable) {
                return this.locRange.fail(
                    "Cannot declare $(this.name) without initializer: $(type.repr) is not zero-initializable");
            }
            auto decl = new VariableDeclaration(
                context.namespace, this.name, type, ExprInfo(mutable, Ownership.owned), hidden=false);

            return StatementCompileResult(
                new AssignStatement(decl.accessDecl(context.compiler), new NullExpr(type)),
                context.withNamespace(decl));
        }
    }

    override ASTSymbol quote(Quoter quoter) {
        mut uninitialized ASTSymbol varName;
        // auto $foo = 5;
        // -> compiler.astDeclareVar(foo, compiler.astIntLiteral(5))
        if (this.name[0 .. 1] == "\$") {
            varName = quoter.compiler.astIdentifier(this.name[1 .. $], this.locRange);
        } else {
            varName = quoter.compiler.astStringLiteral(this.name, this.locRange);
        }
        if (this.infer) {
            return quoter.compilerCall("astDeclareVar", [
                varName,
                quoter.compiler.astBoolLiteral(this.mutable, this.locRange),
                quoter.compiler.astBoolLiteral(this.uninitialized, this.locRange),
                this.initial.quote(quoter)], this.locRange);
        }
        if (this.initial) {
            return quoter.compilerCall("astDeclareTypedVar", [
                varName,
                quoter.compiler.astBoolLiteral(this.mutable, this.locRange),
                quoter.compiler.astBoolLiteral(this.uninitialized, this.locRange),
                this.type.quote(quoter),
                this.initial.quote(quoter)], this.locRange);
        }
        return quoter.compilerCall("astDeclareTypedVar", [
            varName,
            quoter.compiler.astBoolLiteral(this.mutable, this.locRange),
            quoter.compiler.astBoolLiteral(this.uninitialized, this.locRange),
            this.type.quote(quoter),
            quoter.compiler.astIdentifier("null", this.locRange)], this.locRange);
    }
}

(nullable ASTVarDeclStatement | fail Error) parseVarInitialization(
    Parser parser, LexicalContext lexicalContext, bool infer, bool mutable, bool uninitialized,
    nullable ASTSymbol type, string operator, bool requireInitializer)
{
    parser.begin;
    mut nullable ASTSymbol initial;
    auto from = parser.from?;
    mut string name;
    // <- is not as ambiguous as =
    if ((infer || operator == "<-") && parser.accept(operator)?)
    {
        initial = parseExpression(parser, lexicalContext)?;
        if (!initial) return parser.fail("variable initializer expected");
    }
    else
    {
        name = parser.parseIdentifier?;
        if (!name.length)
        {
            parser.revert;
            return null;
        }
        if (infer) {
            if (!parser.accept(operator)?)
            {
                parser.revert;
                return null;
            }
            initial = parseExpression(parser, lexicalContext)?;
            if (!initial) return parser.fail("variable initializer expected");
        }
        else if (parser.accept(operator)?) {
            initial = parseExpression(parser, lexicalContext)?;
            if (!initial) return parser.fail("variable initializer expected");
        } else {
            // FIXME this is very hacky
            if (operator == "=" && parser.accept("<-")?) {
                // recognize that we're failing to parse a <- instead of ==
                // FIXME check for both here instead of passing a parameter
                parser.revert;
                return null;
            }
        }
    }
    if (requireInitializer && !initial) {
        parser.revert;
        return null;
    }
    parser.commit;
    return new ASTVarDeclStatement(name, mutable, infer, uninitialized=uninitialized, type, initial, parser.to(from));
}

(nullable ASTVarDeclStatement | fail Error) parseVarDecl(
    Parser parser, LexicalContext lexicalContext, bool requireInitializer)
{
    parser.begin;
    mut bool infer = false;
    mut bool mutable = false;
    mut bool uninitialized = false;
    mut nullable ASTSymbol type;
    if (parser.acceptIdentifier("mut")?) mutable = true;
    if (parser.acceptIdentifier("uninitialized")?) uninitialized = true;
    if (acceptIdentifier(parser, "auto")?) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            if (mutable) infer = true;
            else {
                parser.revert;
                return null;
            }
        }
    }
    auto decl = parseVarInitialization(
        parser, lexicalContext, infer, mutable, uninitialized, type, "=", requireInitializer)?;
    if (!decl) {
        parser.revert;
        return null;
    }
    parser.commit;
    return decl;
}

// TODO merge with parseVarDecl
(nullable ASTStatement | fail Error) parseMultiVarDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    mut bool infer = false;
    mut bool mutable = false;
    mut bool uninitialized = false;
    mut nullable ASTSymbol type;
    if (parser.acceptIdentifier("mut")?) mutable = true;
    if (parser.acceptIdentifier("uninitialized")?) uninitialized = true;
    if (acceptIdentifier(parser, "auto")?) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            parser.revert;
            return null;
        }
    }
    mut ASTStatement[] decls;
    while (true) {
        if (decls.length) parser.expect(",")?;
        auto decl = parseVarInitialization(parser, lexicalContext, infer, mutable, uninitialized, type, "=", false)?;
        if (auto decl = decl) {
            decls ~= decl;
        } else {
            auto decl2 = parseVarInitialization(
                parser, lexicalContext, infer, mutable, uninitialized, type, "<-", false)?;
            if (auto decl2 = decl2)
            {
                decls ~= extractFromVarDecl(decl2);
            } else {
                parser.assert_(decls.length == 0, "couldn't parse continuing variable declaration")?;
                parser.revert;
                return null;
            }
        }
        if (parser.accept(";")?) break;
    }
    parser.commit;
    return new ASTSequenceStatement(decls, parser.to(from));
}

/**
 * auto a <- foo;
 * int i <- find(...);
 */
class ASTVarExtractDeclStatement : ASTStatement
{
    string name;

    bool mutable;

    bool infer;

    nullable ASTSymbol type;

    ASTSymbol source;

    this(this.name, this.mutable, this.infer, this.type, this.source, this.locRange)
    {
        assert(!!source);
        assert(infer == !type);
    }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        return this.locRange.fail(
            "This syntax is disabled at the moment until I figure out what to use it for.");
        auto source = this.source.compile(context)?.beExpressionImplCall(context, this.locRange)?;
        nullable Either sourceType = source.type.instanceOf(Either);
        if (!sourceType) {
            // either can also turn nullables into non-nullables
            // TODO do we really want that? really?
            if (context.compiler.isClassType(source.type) && source.type.zeroInitializable) {
                return compileObjectDenullFallback(context, source);
            }
        }
        context.assert2(!!sourceType, this.locRange, "Source type for extract decl must be sumtype")?;
        auto sourceType = sourceType.notNull;

        mut uninitialized Type type;
        if (this.type) type = this.type.compile(context)?.beType2(this.locRange)?;
        else type = typeWithoutFail(sourceType);

        bool inTargetType(Type source) {
            if (auto either = type.instanceOf(Either))
                return [any a.type.same(source) for a in either.types];
            return type.same(source);
        }

        auto decl = new VariableDeclaration(
            context.namespace, this.name, type, ExprInfo(mutable=this.mutable, Ownership.owned), false);
        auto astType = new ASTSymbolHelper(type);

        mut ASTEitherCaseExprCase[] cases;
        for (i, entry in sourceType.types) {
            auto sourceMemberType = entry.type;
            bool return_ = !sourceMemberType.inTargetType;

            mut uninitialized ASTSymbol expr;
            if (return_) expr = context.compiler.$expr a;
            else expr = context.compiler.$expr ({ $astType x = a; x; });
            cases ~= ASTEitherCaseExprCase(
                locRange=this.locRange,
                type=new ASTSymbolHelper(sourceMemberType),
                identifier="a",
                return_=return_,
                expr=expr);
        }

        auto switch_ = new ASTEitherCaseExpr(this.locRange, this.source, cases);
        auto switchExpr = switch_.compile(context)?.beExpression(__RANGE__)?;

        return StatementCompileResult(
            move(context, decl.accessDecl(context.compiler), switchExpr)?,
            context.withNamespace(decl));
    }

    (StatementCompileResult | fail Error) compileObjectDenullFallback(Context context, Expression source) {
        mut uninitialized Type type;
        if (this.type) type = this.type.compile(context)?.beType2(this.locRange)?;
        else type = source.type.makeNotNullable;
        assert(type.same(source.type.makeNotNullable));

        auto astSource = new ASTSymbolHelper(source);
        auto astType = new ASTSymbolHelper(type);
        auto initial = context.compiler.$expr ({
            mut uninitialized $astType result;
            if (auto a = $astSource) result = a;
            else return null;
            result;
        });
        auto decl = new VariableDeclaration(
            context.namespace, this.name, type, ExprInfo(mutable=this.mutable, Ownership.owned), false);

        context.pushErrorLoc(this.locRange);
        auto ret = StatementCompileResult(
            move(context, decl.accessDecl(context.compiler), initial.compile(context)?.beExpression(initial.locRange)?)?,
            context.withNamespace(decl));
        context.popErrorLoc;
        return ret;
    }

    override ASTSymbol quote(Quoter quoter) {
        mut uninitialized ASTSymbol varName;
        // auto $foo <- expr;
        // -> compiler.astDeclareVarExtract(foo, ...)
        if (this.name[0 .. 1] == "\$") {
            varName = quoter.compiler.astIdentifier(this.name[1 .. $], this.locRange);
        } else {
            varName = quoter.compiler.astStringLiteral(this.name, this.locRange);
        }
        ASTSymbol quoteNullable(nullable ASTSymbol sym)
        {
            if (auto sym = sym) return sym.quote(quoter);
            return quoter.compiler.astIdentifier("null", __RANGE__);
        }
        return quoter.compilerCall("astDeclareVarExtract", [
            varName,
            quoter.compiler.astBoolLiteral(this.mutable, this.locRange),
            quoter.compiler.astBoolLiteral(this.infer, this.locRange),
            quoteNullable(this.type),
            this.source.quote(quoter)], this.locRange);
    }

    /*
    FIXME: static in class
    static ASTVarExtractDeclStatement fromVarDecl(ASTVarDeclStatement decl)
    {
        return new ASTVarExtractDeclStatement(
            name=decl.name, auto_=decl.infer, type=decl.type,
            source=decl.initial, locRange=decl.locRange);
    }
    */
}

ASTVarExtractDeclStatement extractFromVarDecl(ASTVarDeclStatement decl)
{
    return new ASTVarExtractDeclStatement(
        name=decl.name, mutable=decl.mutable, infer=decl.infer, type=decl.type,
        source=decl.initial.notNull, locRange=decl.locRange);
}

(nullable ASTVarExtractDeclStatement | fail Error) parseVarExtractDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    mut bool infer = false;
    mut bool mutable = false;
    mut nullable ASTSymbol type;
    // TODO
    // if (parser.acceptIdentifier("mut")?) mutable = true;
    if (acceptIdentifier(parser, "auto")?) {
        infer = true;
    } else {
        type = parser.parseType(lexicalContext)?;
        if (!type)
        {
            if (mutable) infer = true;
            else {
                parser.revert;
                return null;
            }
        }
    }
    auto decl = parseVarInitialization(
        parser, lexicalContext, infer, mutable, uninitialized=false, type, "<-", requireInitializer=true)?;
    if (!decl) {
        parser.revert;
        return null;
    }
    parser.commit;
    return extractFromVarDecl(decl.notNull);
}

class ASTNestedFunctionDeclStatement : ASTStatement
{
    ASTFunction fun;

    this(this.fun) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto fun = this.fun.compile(context)?;
        auto latent = fun.instanceOf(LatentNestedFunction);

        assert(!!latent);
        return StatementCompileResult(
            new NoopStatement,
            context.withNamespace(new SymbolAlias(
                context.namespace, latent.fun.name, latent)));
    }

    override ASTSymbol quote(Quoter quoter) {
        print("cannot quote 'ASTNestedFunctionDeclStatement'");
        assert(false);
    }
}

(nullable ASTNestedFunctionDeclStatement | fail Error) parseNestedFunctionDecl(
    Parser parser, LexicalContext lexicalContext)
{
    if (auto fun_ = parseFunction(parser, lexicalContext)?)
        return new ASTNestedFunctionDeclStatement(fun_);
    return null;
}

class ASTWhile : ASTStatement
{
    ASTSymbol cond;

    ASTStatement body_;

    this(this.cond, this.body_, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto label = context.getLabel;
        auto loopContext = context.withNamespace(new LabelLoopScope(label, context.namespace));
        auto condExpr = this.cond.compile(loopContext)?
            .beExpressionImplCall(context, this.locRange)?
            .truthy2(context, this.locRange)?;
        auto bodyPair = this.body_.compile(loopContext)?;
        auto bodyStmt = unwindScope(bodyPair.context, context.namespace, bodyPair.statement)?;

        return StatementCompileResult(
            new Loop(label, null, condExpr, bodyStmt, null),
            context);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTWhileStatement'"); assert(false); }
}

(nullable ASTWhile | fail Error) parseWhile(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!acceptIdentifier(parser, "while")?)
    {
        parser.revert;
        return null;
    }
    parser.expect("(")?;
    nullable ASTSymbol cond = parseExpression(parser, lexicalContext)?;
    parser.expect(")")?;
    parser.commit;
    ASTStatement body_ = parseStatement(parser, lexicalContext)?;

    return new ASTWhile(cond.notNull, body_, parser.to(from));
}

(nullable ASTExprStatement | fail Error) parseExprStatement(
    Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    nullable ASTSymbol value = parseExpression(parser, lexicalContext)?;
    if (!value)
    {
        parser.revert;
        return null;
    }
    auto value = value.notNull;
    parser.expect(";")?;
    parser.commit;
    return new ASTExprStatement(value, parser.to(from));
}

class ASTStatementExpression : ASTSymbol
{
    ASTStatement[] statements;

    ASTSymbol expr;

    this(this.statements, this.expr, this.locRange) {
        for (statement in this.statements)
            assert(!!statement);
        assert(!!expr);
    }

    override (Expression | fail Error) compile(Context context) {
        mut Context context = context;
        auto baseNamespace = context.namespace;
        auto statements = new Statement[](this.statements.length);
        for (i, statement in this.statements) {
            auto result = statement.compile(context)?;

            statements[i] = result.statement;
            context = result.context;
        }
        auto resultValue = this.expr.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto resultType = resultValue.type;

        // as ASTReturn
        auto temp = new PairedTemporary(resultType, Ownership.owned);
        auto init = new UninitializeTemporaryStatement(temp);

        (Statement | fail Error) assignEscapeValue() {
            if (resultValue.info.ownership == Ownership.gifted)
                return new AssignStatement(temp, resultValue);
            if (auto stmt = resultType.copyInto(context, temp, resultValue)?)
                return stmt;
            return new AssignStatement(temp, resultValue);
        }
        auto initAndCopy = sequence(init, assignEscapeValue?);

        auto sequence = new SequenceStatement(statements ~ initAndCopy);
        // unwind variables declared in the ({ })
        auto stmtExpr = unwindScope(context, baseNamespace, sequence)?;

        return new StatementExpression(stmtExpr, temp, true);
    }

    // TODO on CompilerBase?
    override ASTSymbol quote(Quoter quoter) {
        auto quotedStatements = new ASTSymbol[](this.statements.length);
        for (i, statement in this.statements)
            quotedStatements[i] = statement.quote(quoter);
        auto type = quoter.compiler.astIdentifier("ASTStatement", __RANGE__);
        return quoter.compilerCall("astStatementExpression", [
            quoter.compiler.astArrayLiteralTypeHint(type, quotedStatements, locRange),
            this.expr.quote(quoter)
        ], locRange);
    }
}

// ({ ...; ...; })
// value of last expression is value of statement expression
(nullable ASTStatementExpression | fail Error) parseStatementExpr(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!parser.accept("({")?) { parser.revert; return null; }
    parser.commit;
    mut ASTStatement[] statements;
    while (!parser.accept("})")?) {
        auto locStmt = parser.loc;
        auto startLevel = parser.level;
        statements ~= parseStatement(parser, lexicalContext)?;
        locStmt.hardCheck(parser.level == startLevel, "statement parse rule imbalance");
    }
    if (statements.length == 0) return parser.fail("expected at least one statement");

    if (auto exprStmt = statements[$ - 1].instanceOf(ASTExprStatement))
        return new ASTStatementExpression(statements[0 .. $ - 1], exprStmt.value, parser.to(from));

    return parser.fail("last statement in statement expression must be an expression");
}

class ASTForLoop : ASTStatement
{
    ASTStatement declareLoopVar;

    ASTSymbol condition;

    ASTStatement step;

    ASTStatement body_;

    this(this.declareLoopVar, this.condition, this.step, this.body_, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto declPair = this.declareLoopVar.compile(context)?;
        auto forScope = declPair.context;
        Expression condition = this.condition.compile(forScope)?.beExpressionImplCall(context, this.locRange)?;
        auto stepPair = this.step.compile(forScope)?;

        string label = context.getLabel;
        Namespace declScope = new LabelLoopScope(label, forScope.namespace);
        Context breakContScope = forScope.withNamespace(declScope);
        auto bodyPair = this.body_.compile(breakContScope)?;

        return StatementCompileResult(
            new Loop(label, declPair.statement, condition, bodyPair.statement, stepPair.statement),
            context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astForLoop", [
            declareLoopVar.quote(quoter),
            condition.quote(quoter),
            step.quote(quoter),
            body_.quote(quoter)], locRange);
    }
}

(nullable ASTForLoop | fail Error) parseFor(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!acceptIdentifier(parser, "for")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    parser.expect("(")?;
    nullable ASTVarDeclStatement varDecl = parseVarDecl(parser, lexicalContext, requireInitializer=false)?;
    if (!varDecl) {
        return parser.fail("loop declaration expected");
    }
    parser.expect(";")?;
    nullable ASTSymbol condition = parseExpression(parser, lexicalContext)?;
    parser.expect(";")?;
    nullable ASTAssignStatement step = parseAssignment(parser, lexicalContext)?;
    parser.expect(")")?;
    ASTStatement body_ = parseStatement(parser, lexicalContext)?;

    return new ASTForLoop(varDecl.notNull, condition.notNull, step.notNull, body_, parser.to(from));
}

class ASTStatementStatement : ASTStatement
{
    string variable;

    this(this.variable, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context) {
        return this.locRange.fail("\$stmt used outside quasiquote");
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astIdentifier(variable, locRange);
    }
}

/**
 * Parse a statement that indicates to the quoter that an ASTStatement variable should be inserted.
 */
(nullable ASTStatementStatement | fail Error) parseStatementStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!parser.accept("\$stmt")?) {
        parser.revert;
        return null;
    }
    parser.commit;
    auto variable = parser.parseIdentifier?;
    if (!variable.length) return parser.fail("ASTStatement variable expected");
    parser.expect(";")?;
    return new ASTStatementStatement(variable, parser.to(from));
}

(ExtForVarDecl | fail :fail | fail Error) parseExtForVarDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (parser.acceptIdentifier("auto")?) {
        auto identifier = parser.parseIdentifier?;
        if (!identifier.length) {
            parser.revert;
            return :fail;
        }
        parser.commit;
        // (auto i in 0..10)
        return (:auto_, parser.to(from), identifier);
    }
    {
        auto ident = parser.parseIdentifier?;
        parser.begin;
        // peek ahead
        if (parser.accept(",")? || parser.acceptIdentifier("in")? || parser.accept("<-")?) {
            // (i in 0..10)
            parser.revert; // revert peek
            parser.commit; // commit identifier
            return (:none, parser.to(from), ident);
        }
        parser.revert; // revert failed peek
        parser.revert; // revert identifier parse
        parser.begin;
    }
    // (int i in 0..10)
    auto type = parser.parseType(lexicalContext)?;
    if (!type) {
        parser.revert;
        return :fail;
    }
    auto type = type.notNull;
    auto ident = parser.parseIdentifier?;
    if (!ident.length) {
        parser.revert;
        return :fail;
    }
    parser.commit;
    return (type, parser.to(from), ident);
}

class ASTExtForLoop : ASTStatement
{
    ASTSymbol source;

    ExtForVarDecl var1;

    (ExtForVarDecl | :none) var2;

    ASTStatement body_;

    this(this.source, this.var1, this.var2, this.body_, this.locRange) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto source = this.source.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto compiler = context.compiler;
        auto astSource = new ASTSymbolHelper(source);

        if (source.type.instanceOf(Array)) {
            auto valueMatch = var2.case(ExtForVarDecl a: a, (:none): var1);
            string keyName = var2.case(ExtForVarDecl a: var1.name, (:none): "__loopvar");
            ASTSymbol keyIdent = compiler.astIdentifier(keyName, __RANGE__);
            ASTSymbol loopType = var2.case(
                ExtForVarDecl a: var1.type.case(
                    (:auto_): compiler.astIdentifier("size_t", __RANGE__),
                    (:none): compiler.astIdentifier("size_t", __RANGE__),
                    ASTSymbol type: type),
                (:none): compiler.astIdentifier("size_t", __RANGE__));

            string valueName = valueMatch.name;
            ASTStatement declIdentifier = valueMatch.type.case(
                (:auto_): compiler.$stmt auto $valueName = __borrow(__source[$keyIdent]); ,
                (:none): compiler.$stmt auto $valueName = __borrow(__source[$keyIdent]); ,
                ASTSymbol type: compiler.$stmt $type $valueName = __borrow(__source[$keyIdent]); );

            ASTStatement loop = compiler.$stmt {
                auto __source = $astSource;
                for (mut $loopType $keyName = 0; $keyIdent < __source.length; $keyIdent += 1) {
                    $stmt declIdentifier;
                    $stmt body_;
                }
            };
            return loop.compile(context);
        }
        if (var2 != :none) {
            // for (var1, var2 in
            string indexName = var1.name;
            auto index = compiler.astIdentifier(indexName, __RANGE__);
            ExtForVarDecl value() {
                var2.case {
                    ExtForVarDecl a: return a;
                    (:none): assert(false);
                }
            }
            auto valueName = value.name, valueType = value.type;

            ASTStatement declIdentifier = valueType.case(
                (:auto_): compiler.$stmt auto $valueName = __source.front; ,
                (:none): compiler.$stmt auto $valueName = __source.front; ,
                ASTSymbol type: compiler.$stmt $type $valueName = __source.front; );
            ASTStatement rangeLoop = compiler.$stmt {
                mut size_t $indexName = 0;
                for (mut auto __source = $astSource; !__source.empty; __source = __source.next) {
                    $stmt declIdentifier;
                    $stmt body_;
                    $index = $index + 1;
                }
            };
            return rangeLoop.compile(context);
        }
        string valueName = var1.name;

        ASTStatement declIdentifier = var1.type.case(
            (:auto_): compiler.$stmt auto $valueName = __source.front; ,
            (:none): compiler.$stmt auto $valueName = __source.front; ,
            ASTSymbol type: compiler.$stmt $type $valueName = __source.front; );
        ASTStatement rangeLoop = compiler.$stmt {
            for (mut auto __source = $astSource; !__source.empty; __source = __source.next) {
                $stmt declIdentifier;
                $stmt body_;
            }
        };
        context.pushErrorLoc(this.locRange);
        auto ret = rangeLoop.compile(context);
        context.popErrorLoc;
        return ret;
    }

    override ASTSymbol quote(Quoter quoter) {
        mut ASTSymbol[] args;
        args ~= source.quote(quoter);
        args ~= var1.quoteExtForVarDecl(quoter);
        args ~= var2.case(
            ExtForVarDecl decl: decl.quoteExtForVarDecl(quoter),
            (:none): new ASTSymbolIdentifier("none", __RANGE__));
        args ~= body_.quote(quoter);

        return quoter.compilerCall("astExtForLoop", args, locRange);
    }
}

// This is a placeholder for proper range semantics.
(nullable ASTStatement | fail Error) parseExtFor(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!acceptIdentifier(parser, "for")? || !parser.accept("(")?) {
        parser.revert;
        return null;
    }
    auto compiler = lexicalContext.compiler;
    // TODO: parseExtForVarDecl(...).discard((:fail): { parser.revert; return null; });
    auto match1 = parseExtForVarDecl(parser, lexicalContext);
    mut uninitialized ExtForVarDecl match1decl;
    match1.case {
        (:fail): {
            parser.revert;
            return null;
        }
        Error e: { parser.revert; return e; }
        ExtForVarDecl decl: {
            match1decl = decl;
        }
    }
    mut bool keyValueLoop = false;
    mut uninitialized ExtForVarDecl match2decl;
    if (parser.accept(",")?) {
        parseExtForVarDecl(parser, lexicalContext).case {
            (:fail): {
                parser.revert;
                return null;
            }
            Error e: { parser.revert; return e; }
            ExtForVarDecl decl: {
                match2decl = decl;
            }
        }
        keyValueLoop = true;
    }
    if (parser.accept("<-")?) {
        print("warn: $(parser.to(from).repr): use 'in'");
    } else if (!parser.acceptIdentifier("in")?) {
        parser.revert;
        return null;
    }
    auto source = parseExpression(parser, lexicalContext)?;
    if (!source) return parser.fail("expression expected");
    auto source = source.notNull;
    // array loop, for (i, k in array)
    parser.expect(")")?;
    auto body_ = parseStatement(parser, lexicalContext)?;
    parser.commit;

    if (keyValueLoop) {
        return new ASTExtForLoop(source, match1decl, match2decl, body_, parser.to(from));
    }
    return new ASTExtForLoop(source, match1decl, :none, body_, parser.to(from));
}

class ASTDestroy : ASTSymbol
{
    ASTSymbol target;

    this(this.target, this.locRange) { }

    override (Expression | fail Error) compile(Context context) {
        auto expr = this.target.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto stmt = destroy(context, expr);
        if (!stmt) return once new VoidExpression;
        return new StatementExpression(stmt, once new VoidExpression, false);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astDestroy", [target.quote(quoter)], locRange);
    }
}

// manually end lifetime of a value
(nullable ASTSymbol | fail Error) parseDestroy(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!acceptIdentifier(parser, "__destroy")?) {
        parser.revert;
        return null;
    }
    parser.expect("(")?;
    nullable ASTSymbol target = parseExpression(parser, lexicalContext)?;
    if (!target) return parser.fail("expression expected");
    parser.expect(")")?;
    parser.commit;

    return new ASTDestroy(target.notNull, parser.to(from));
}

class ASTStaticIfStatement : ASTStatement
{
    ASTSymbol cond;
    ASTStatement then;
    ASTStatement else_;
    this(this.cond ,this.then, this.else_, this.locRange) { }
    override (StatementCompileResult | fail Error) compile(Context context) {
        auto tern = staticTruthy(context, this.cond);

        tern.case {
            bool b: {
                if (b) return this.then.compile(context);
                else return this.else_.compile(context);
            }
            (:unknown): {
                return this.locRange.fail("cannot statically evaluate condition: "
                    ~ this.cond.repr);
            }
            Error err: return err;
        }
        assert(false);
    }
    override ASTSymbol quote(Quoter quoter) {
        print("TODO quote ASTStaticIfStatement");
        assert(false);
    }
}

(nullable ASTStaticIfStatement | fail Error) parseStaticIfStmt(
    Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    mut nullable ASTSymbol cond;
    if (parser.acceptIdentifier("static")? && parser.acceptIdentifier("if")?) {
        parser.commit;
        parser.expect("(")?;
        auto e = parser.parseExpression(lexicalContext)?;
        if (!e) {
            return parser.fail("static if condition expected");
        }
        cond = e;
        parser.expect(")")?;
    } else if (parser.acceptIdentifier("version")?) {
        parser.commit;
        parser.expect("(")?;
        string versionStr = parser.parseIdentifier?;
        parser.expect(")")?;
        auto versionSym = lexicalContext.compiler.astStringLiteral(versionStr, __RANGE__);
        cond = new ASTTrait("versionSet", [versionSym], __RANGE__);
    } else {
        parser.revert;
        return null;
    }

    mut ASTStatement[] then, else_;
    if (parser.accept("{")?) {
        while (!parser.accept("}")?) {
            then ~= parser.parseStatement(lexicalContext)?;
        }
    } else {
        then ~= parser.parseStatement(lexicalContext)?;
    }
    if (parser.accept("else")?) {
        if (parser.accept("{")?) {
            while (!parser.accept("}")?) {
                else_ ~= parser.parseStatement(lexicalContext)?;
            }
        } else {
            else_ ~= parser.parseStatement(lexicalContext)?;
        }
    }
    return new ASTStaticIfStatement(
        cond.notNull,
        new ASTSequenceStatement(then, __RANGE__),
        new ASTSequenceStatement(else_, __RANGE__),
        parser.to(from));
}

(nullable ASTDeclaration | fail Error) parseDeclaration(Parser parser, LexicalContext lexicalContext) {
    auto from = parser.from?;
    if (auto importStmt = parseImportStatement(parser, lexicalContext)?) {
        parser.to(from).assert(!importStmt.isMacroImport, "can't import macro in function")?;
        auto pool = lexicalContext.compiler.workPool;
        auto id = importStmt.repr(lexicalContext.pak.name);
        auto task = new ImportTask(lexicalContext, importStmt);
        auto import_ = new ASTImport(importStmt, (pool, id, task));

        pool.queue(id, task);
        return import_;
    }
    if (auto aliasDecl = parseAliasDecl(parser, lexicalContext)?) {
        return aliasDecl;
    }
    if (auto structDecl = parseStructDecl(parser, lexicalContext)?) {
        return structDecl;
    }
    if (auto templateDecl = parseTemplateDecl(parser, lexicalContext)?) {
        return templateDecl;
    }
    return null;
}

(ASTStatement | fail Error) parseStatement(Parser parser, LexicalContext lexicalContext)
{
    if (ASTStatement stmt = parseReturn(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseIf(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseBreakCont(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseWhile(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseExtFor(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseFor(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseScope(parser, lexicalContext)?)
        return stmt;
    // FIXME why did this work?!
    // if (ASTStatement decl = parseDeclaration(parser, lexicalContext))
    if (ASTDeclaration decl = parseDeclaration(parser, lexicalContext)?)
        return new ASTDeclarationStatement(decl);
    if (ASTStatement stmt = parseNestedFunctionDecl(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseStatementStatement(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseMultiVarDecl(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseAssignStatement(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseWithStatement(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseEitherCaseStmt(parser, lexicalContext)?)
        return stmt;
    if (ASTStatement stmt = parseStaticIfStmt(parser, lexicalContext)?)
        return stmt;
    {
        auto args = new ParseStatementArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (ASTStatement ret = args.statement?) return ret;
    }
    if (ASTStatement stmt = parseExprStatement(parser, lexicalContext)?)
        return stmt;
    return parser.fail("statement expected");
}

class ModuleEntry
{
    string name;

    Symbol value;

    this(this.name, this.value) { }
}

class ASTVersion
{
    string name;

    ASTModuleEntry[] then, else_;

    this(this.name, this.then, this.else_) { }
}

struct ASTModuleEntry
{
    Protection protection;

    (ASTImport | ASTSymbol | ASTExternFunction | ASTExternVariable
        | ASTDeclaration | ASTUnitTest
        | ASTPragma | ASTVersion
    ) symbol;
}

class ASTModule : ASTModuleBase
{
    string name;

    Package pak;

    MacroState macroState;

    // separated from this module with a divergent macro state
    // because we hit a macro declaration
    nullable ASTModule parent;

    int depth; // count from parent = null

    ASTModuleEntry[] entries;

    ASTDeclaration[string] symbolAliases;

    LocRange locRange;

    this(this.name, this.pak, this.macroState, this.locRange, this.parent) {
        if (this.parent) this.depth = this.parent.depth + 1;
        this.mangledName = mangleModuleName(this.name, this.pak, this.depth);
    }

    void addAliasDecl(string name, Protection protection, ASTSymbol target)
    {
        auto decl = new ASTAliasDecl(name, target);
        this.entries ~= ASTModuleEntry(protection, decl);
        assert(!this.symbolAliases.has(name));
        this.symbolAliases[name] = decl;
    }

    nullable ASTSymbol getSymbolAlias(string name) {
        if (this.symbolAliases.has(name)) {
            auto decl = this.symbolAliases[name];
            if (auto alias_ = decl.instanceOf(ASTAliasDecl)) {
                return alias_.target;
            }
        }
        return null;
    }
}

string mangleModuleName(string name, Package pak, int depth)
{
    // TODO non-nullable by default
    assert(!!pak);
    mut string mangledName;
    // mangledName = [(a == '.') ? '_' : a for a in name];
    for (i in 0 .. name.length) {
        if (name[i .. i + 1] == ".") mangledName ~= "_";
        else mangledName ~= name[i .. i + 1];
    }
    mut string patchedPakName;
    if (pak.name == "compiler") patchedPakName = "compiler$(itoa(__GENERATION__))";
    else patchedPakName = pak.name;

    string combined = "$(patchedPakName)_module_$mangledName";

    if (depth) return "$(combined)_d$depth";
    return combined;
}

struct Nothing { }

class NotYetResolvedSymbol : PendingSymbol
{
    Resolver resolver;

    int index;

    LocRange locRange;

    this(this.resolver, this.index, this.locRange) { }

    override (Symbol | fail Error) resolve() {
        auto entry = resolver.entries[index];
        if (auto resolution = entry.resolution?) {
            return resolution;
        }
        return locRange.fail("Dependency cycle while resolving $(entry.name).");
    }
}

struct ResolvingModuleEntry
{
    string name;

    Protection protection;

    bool resolving;

    (nullable Symbol | fail Error) resolution;

    (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStruct | ASTAliasDecl | ASTUnitTest | Nothing) symbol;
}

class Resolver
{
    ResolvingModuleEntry[] entries;

    this() { }

    void add(
        string name,
        Protection protection,
        (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStruct | ASTAliasDecl | ASTUnitTest) astSymbol)
    {
        this.entries ~= ResolvingModuleEntry(name, protection, false, null, astSymbol);
    }

    void register(string name, Protection protection, Symbol symbol)
    {
        int hit = cast(int) [first i for i, a in this.entries where a.name == name else -1];
        if (hit == -1) {
            entries ~= ResolvingModuleEntry(name, protection, resolving=false, symbol, Nothing());
            return;
        }
        entries[hit].resolution = symbol;
    }

    (nullable Symbol | fail Error) lookup(Context context, LocRange locRange, string name, Protection protection)
    {
        bool allowed(Protection entry) {
            if (protection == Protection.public_)
                return entry == Protection.public_;
            return true;
        }
        int hit = cast(int) [
            first i for i, a in this.entries
            where a.name == name && allowed(a.protection)
            else -1];
        if (hit == -1) return null;
        if (this.entries[hit].resolving) {
            return new NotYetResolvedSymbol(this, hit, locRange);
        }
        resolve(context, locRange, hit)?;

        mut nullable Symbol ret = this.entries[hit].resolution?;
        if (!ret) return null;
        if (auto latent = ret.instanceOf(LatentSymbol)) {
            // we're at global scope; no frame pointer will be applied.
            assert(!context.framePointer);
            ret = latent.resolve(context);
        }
        return ret;
    }

    (void | fail Error) resolve(Context context, LocRange locRange, int i)
    {
        if (this.entries[i].resolution.case(Error err: true, nullable Symbol sym: !sym)) {
            if (this.entries[i].resolving)
            {
                return locRange.fail("Dependency cycle while resolving $(this.entries[i].name).");
            }
            this.entries[i].resolving = true;
            this.entries[i].resolution = this.entries[i].symbol.case(
                // TODO compile function statement immediately too
                ASTFunction fun: fun.compile(context)
                    .case(
                        Symbol sym: sym.instanceOf(FunctionDeclaration).notNull,
                        Error err: err),
                ASTUnitTest ut: ut.compile(context),
                ASTClassDecl decl: decl.compile(context),
                ASTIntfDecl decl: decl.compile(context),
                ASTStruct struct_: struct_.compile(context),
                ASTAliasDecl decl: decl.target.compile(context),
                Nothing _: ({ assert(false); cast(Symbol) null; }));
            this.entries[i].resolving = false;
        }
    }

    (void | fail Error) resolveAll(Context context)
    {
        for (i in 0 .. this.entries.length) {
            resolve(context, __RANGE__, cast(int) i)?;
        }
    }
}

extern(C) size_t poly_hash_whole_string(string s);

class Module : ModuleBase
{
    // whenever macro state changes, we begin a new submodule
    // when this happens, this member references the previous module.
    nullable Module parentModule;

    Resolver resolver;

    (FinishedSymbol | Symbol)[] anonymousEntries;

    // filled in by compile()
    FinishedSymbol[] finishedSymbols;

    size_t hash; // hash of mangled name

    LocRange locRange;

    // Inert imports have no lookup effect, they solely define a module dependency
    (Module mod, (:inert|:private_|:public_) visibility, string[] symbols)[] imports;

    this(this.name, this.mangledName, this.locRange, this.parentModule) {
        this.isContextScope = false;
        this.resolver = new Resolver;
        this.hash = poly_hash_whole_string(mangledName);
    }

    void add(
        string name, Protection protection,
        (ASTFunction | ASTClassDecl | ASTIntfDecl | ASTStruct | ASTAliasDecl | ASTUnitTest) symbol)
    {
        this.resolver.add(name, protection, symbol);
    }

    override void track((Symbol | FinishedSymbol) symbol)
    {
        this.anonymousEntries ~= symbol;
    }

    void register(string name, Protection protection, Symbol symbol)
    {
        this.resolver.register(name, protection, symbol);
    }

    override void addImport(ModuleBase module_, bool public_, string[] symbols) {
        auto module_ = module_.instanceOf(Module).notNull;
        // TODO error?
        // TODO merge symbols?
        if ([any a.mod.mangledName == module_.mangledName for a in this.imports])
            return;
        if (public_)
            this.imports ~= (module_, :public_, symbols);
        else
            this.imports ~= (module_, :private_, symbols);
    }

    override void addModuleDependency(ModuleBase module_) {
        string[] empty;
        // TODO , [])
        this.imports ~= (module_.instanceOf(Module).notNull, :inert, empty);
    }

    override string mangle() { return this.mangledName; }

    void walkModules(bool delegate(Module) cb)
    {
        if (this.parentModule)
            this.parentModule.walkModules(cb);
        if (!cb(this)) return;
        [import_.mod.walkModules(cb) for import_ in imports];
    }

    override (void | fail Error) compile(Context context)
    {
        auto compiler = context.compiler, platform = context.platform;

        this.resolver.resolveAll(context)?;

        (void | fail Error) walkSymbols((void | fail Error) delegate((Symbol | FinishedSymbol)) dg) {
            for (entry in this.resolver.entries) {
                dg(entry.resolution?.notNull)?;
            }
            // must be a regular for loop so we can add entries during iteration
            for (mut int i = 0; i < this.anonymousEntries.length; i += 1) {
                dg(anonymousEntries[i])?;
            }
        }

        (void | fail Error) resolveClassIntf((Symbol | FinishedSymbol) sym) {
            sym.case {
                Symbol sym: {
                    if (auto classType = sym.instanceOf(ClassType)) {
                        classType.class_.resolve(context)?;
                    }
                    if (auto intfType = sym.instanceOf(IntfType)) {
                        intfType.intf.resolve(context)?;
                    }
                }
                FinishedSymbol sym: { }
            }
        }

        assert(finishedSymbols.length == 0);
        (void | fail Error) compileSymbol((Symbol | FinishedSymbol) symbol) {
            symbol.case {
                Symbol symbol: {
                    if (Function fun = symbol.instanceOf(Function)) {
                        finishedSymbols ~= fun.compile(compiler, platform)?;
                    }
                    if (IntfType intfType = symbol.instanceOf(IntfType)) {
                        finishedSymbols ~= new DefineClassIntf(intfType.intf);
                    }
                    if (ClassType classType = symbol.instanceOf(ClassType)) {
                        finishedSymbols ~= new DefineClassIntf(classType.class_);
                        for (method in classType.class_.methods)
                            finishedSymbols ~= method.compile(compiler, platform)?;
                    }
                    if (Struct struct_ = symbol.instanceOf(Struct)) {
                        for (method in struct_.methods)
                            finishedSymbols ~= method.instanceOf(StructMethod).compile(compiler, platform)?;
                    }
                }
                FinishedSymbol symbol:
                    finishedSymbols ~= symbol;
            }
        }

        /**
         * TODO
         * This is hacky as heck.
         * It's written by just poking things until it works.
         * Work out a saner way.
         */
        walkSymbols(&resolveClassIntf)?;
        walkSymbols(&compileSymbol)?;
    }

    void emit(Generator generator)
    {
        if (!generator.once(mangle))
            return;

        assert(!generator.fun);

        [symbol.emit(generator) for symbol in this.finishedSymbols];
    }

    // TODO merge import search with lookup()
    (nullable Symbol | fail Error) lookupPublic(Context context, LocRange locRange, string name)
    {
        // not counting imports (non-transitive)
        if (auto ret = this.resolver.lookup(context, locRange, name, Protection.public_)?) return ret;
        // transitive public import search
        for (import_ in this.imports) {
            // FIXME !=
            if (!import_.visibility.case((:inert): false, (:private_): false, (:public_): true))
                continue;
            // TODO yet another import class? struct? we've written this line three times now...
            auto importMod = import_.mod;
            assert(!!importMod);
            if (!import_.symbols.length || [any a == name for a in import_.symbols]) {
                if (Symbol entry = importMod.lookupPublic(context, locRange, name)?)
                    return entry;
            }
        }
        return null;
    }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        if (!!context.framePointer) {
            print("error: lookup with frame propagated to Module");
            assert(false);
        }

        this.resolver.lookup(context, locRange, name, Protection.private_).case {
            nullable Symbol sym: if (sym) return sym;
            Error error: assert(false);
        }
        for (import_ in this.imports) {
            // FIXME !=
            if (import_.visibility.case((:inert): true, (:private_): false, (:public_): false))
                continue;
            auto importMod = import_.mod;
            assert(!!importMod);
            if (!import_.symbols.length || [any a == name for a in import_.symbols]) {
                if (auto sym = importMod.lookupPublic(context, locRange, name)?) return sym;
            }
        }
        assert(!this.parent);
        if (this.parentModule)
            return this.parentModule.lookup(name, context, locRange);
        return null;
    }
}

abstract class ParserHelper
{
    abstract (void | fail Error) proxyCall(ASTModule astModule, string function_, MacroState macroState)
    {
        assert(false);
    }
}

class ExternCVariable : Expression
{
    string name;

    this(this.type, this.name) { this.info = ExprInfo(true, Ownership.global); }

    override int emit(Generator output) {
        return output.fun.globalVar(this.name, this.type.emit(output.platform));
    }
    override void hash(Hash hash) {
        hash.adds("ExternCVariable");
        this.type.hash(hash);
        hash.adds(this.name);
    }
}

class ASTExternVariable
{
    ASTSymbol type;

    string name;

    LocRange locRange;

    this(this.type, this.name, this.locRange) { }

    (ExternCVariable | fail Error) compile(Context context)
    {
        return new ExternCVariable(this.type.compile(context)?.beType2(locRange)?, this.name);
    }
}

class ASTExternFunction
{
    string name;

    ASTSymbol ret;

    ASTParameter[] params;

    bool variadic;

    LocRange retLocRange;

    this(this.name, this.ret, this.params, this.variadic, this.retLocRange) { }

    (FunctionDeclaration | fail Error) compile(Context context)
    {
        auto params = [
            Parameter(false, param.name, false, param.type.compile(context)?.beType2(param.locRange)?)
            for param in this.params];

        auto decl = new FunctionDeclaration(this.name, this.ret.compile(context)?.beType2(this.retLocRange)?, params);
        decl.variadic = this.variadic;

        return decl;
    }

    string repr() {
        string reprParam(ASTParameter param) {
            if (param.name.length == 0) return param.type.repr;
            return param.type.repr ~ " " ~ param.name;
        }
        return "extern(C) $(ret.repr) $name(" ~ [join with ", " reprParam(param) for param in params] ~ ")";
    }
}

(ASTExternFunction | ASTExternVariable | :none | fail Error) parseExtern(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    if (!parser.accept("extern")?)
    {
        parser.revert;
        return :none;
    }
    parser.commit;
    parser.expect("(")?;
    parser.expect("C")?;
    parser.expect(")")?;
    auto retFrom = parser.from?;
    auto type = parser.parseType(lexicalContext)?.notNull;
    auto retLocRange = parser.to(retFrom);
    string name = parser.parseIdentifier?;
    if (!name.length) return parser.fail("identifier expected");
    if (parser.accept("(")?) {
        auto params = parseIdentifierList(parser, lexicalContext, variadics=true)?;
        parser.expect(";")?;
        return new ASTExternFunction(name, type, params=params.params, variadic=params.variadic, retLocRange);
    } else {
        parser.accept(";")?;
        return new ASTExternVariable(type, name, parser.to(from));
    }
}

string moduleToFile(string module_)
{
    mut string modulePath;
    for (i in 0 .. module_.length) {
        if (module_[i .. i + 1] == ".") modulePath ~= "/";
        else modulePath ~= module_[i .. i + 1];
    }
    return modulePath ~ ".nt";
}

(string, Package | fail Error) findFileInPackage(string filename, Package pak, LocRange locRange)
{
    string fileInPackage = pak.path ~ "/" ~ filename;
    if (exists(fileInPackage)) {
        // print(filename ~ " in package '" ~ pak.name ~ "'");
        return (fileInPackage, pak);
    }
    // print(filename ~ " not in package '" ~ pak.name ~ "'");
    for (dep in pak.deps) {
        string fileInDep = dep.path ~ "/" ~ filename;

        if (exists(fileInDep)) {
            // print(filename ~ " in dep package '" ~ dep.name ~ "' of '" ~ pak.name ~ "'");
            return (fileInDep, dep);
        }
        // print(filename ~ " not in dep package '" ~ dep.name ~ "' of '" ~ pak.name ~ "'");
    }
    return locRange.fail("cannot find file '$filename' in package '$(pak.name)' or dependencies");
}

// TODO rewrite this once we have a std.path
(string, Package) findResidualFilename(string filename, Package[] packages)
{
    import std.file : realpath;

    // TODO split then check
    if (!exists(filename)) {
        print("file '$filename' could not be found!");
        assert(false);
    }
    string realFilename = realpath(filename);
    // scan packages in reverse order, so that latter arguments override earlier ones
    for (mut int i = cast(int) packages.length - 1; i >= 0; i -= 1) {
        auto package_ = packages[i];
        string path = package_.path;
        if (realFilename.length >= path.length
            && realFilename[0 .. path.length] == path) {
            // print("file " ~ filename ~ " found as " ~ realFilename[path.length + 1 .. $] ~ " in " ~ package_.name);
            return (realFilename[path.length + 1 .. $], package_);
        }
    }
    for (package_ in packages) {
        print(": $(package_.path)");
    }
    print("file '$filename' is not in folder of any package");
    assert(false);
}

class ImportNamespace : Namespace
{
    Module module_;

    string[] symbols;

    this(this.parent, this.module_, this.symbols) {
        this.isContextScope = this.parent.isContextScope;
    }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange) {
        if (!symbols.length || [any symbol == name for symbol in symbols]) {
            auto sym = module_.lookupPublic(context, locRange, name)?;
            if (sym) return sym;
        }
        return this.parent.lookup(name, context, locRange);
    }
}

class AstCompileTask : ITask
{
    ASTModule astModule;
    (:none | Module | Error) result;
    Context context;

    this(this.astModule, this.context) {
        this.result = :none;
    }

    (Module | fail Error) module_() {
        result.case {
            Module m: return m;
            Error error: return error;
            (:none): assert(false);
        }
    }

    override void run() {
        this.result = compileModule(context, astModule, true);
        this.result.case {
            Module m: m.mangledName;
            Error error: {}
            (:none): {}
        }
    }
}

// Classes do double duty for both module-level and statement-level imports
class ASTImport : ASTDeclaration
{
    ASTImportStatement statement;

    // running in the background
    (WorkPoolBase pool, string id, ImportTask task | ASTModule) moduleSource;

    (ASTModule | fail Error) module_() {
        this.moduleSource.case {
            (WorkPoolBase pool, string id, ImportTask task): {
                // if the task was not prequeued (ie. an import in a version()),
                // queue it now.
                pool.queue(id, task);
                return pool.wait(id).instanceOf(ImportTask).notNull.module_;
            }
            ASTModule mod: return mod;
        }
    }

    this(this.statement, this.moduleSource) { }

    override (Context | fail Error) compile(Context context) {
        auto astModule_ = this.module_?;
        auto id = "compile platform $(context.platform.ident) ast $(astModule_.mangledName)";
        auto task = new AstCompileTask(astModule_, context);

        context.compiler.workPool.queue(id, task);
        auto module_ = context.compiler.workPool.wait(id)
            .instanceOf(AstCompileTask).module_?;
        auto namespace = new ImportNamespace(context.namespace, module_, this.statement.symbols);
        auto contextModule = findParent!Module(context.namespace);

        contextModule.addModuleDependency(module_);

        return context.withNamespace(namespace);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto importStatement = this.statement.quote(quoter);
        string name() {
            this.module_.case {
                ASTModule mod: return mod.pak.name;
                Error error: assert(false);
            }
        }
        auto mod = quoter.compilerCall("resolveImport", [
            quoter.compiler.astStringLiteral(name, __RANGE__),
            importStatement], __RANGE__);

        return quoter.compilerCall("astImport", [
            importStatement,
            mod], __RANGE__);
    }
}

class ImportTask : ITask
{
    LexicalContext lexicalContext;

    ASTImportStatement import_;

    (ASTModule | :none | Error) result;

    this(this.lexicalContext, this.import_) {
        this.result = :none;
    }

    (ASTModule | fail Error) module_() {
        result.case {
            ASTModule mod: return mod;
            Error err: return err;
            (:none): assert(false);
        }
    }

    override void run() {
        this.result = this.lexicalContext.resolveImport(import_).case(
            ASTModuleBase base: base.instanceOf(ASTModule).notNull,
            Error err: err);
    }
}

(nullable ASTImportStatement | fail Error) parseImportStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto from = parser.from?;
    bool isMacroImport = acceptIdentifier(parser, "macro")?;
    if (!acceptIdentifier(parser, "import")?)
    {
        parser.revert;
        return null;
    }

    mut uninitialized (:normal, string name, string pak | :macro_, ASTModuleBase module_) target;
    parser.commit;

    auto macroArgs = new ParseImportArgs(parser, lexicalContext);
    lexicalContext.macroState.applyMacro(macroArgs);
    if (macroArgs.done) target = (:macro_, macroArgs.module_?.notNull);
    else {
        mut string pak;
        if (acceptIdentifier(parser, "package")?)
        {
            parser.expect("(")?;
            pak = parser.parseIdentifier?;
            parser.expect(")")?;
            parser.expect(".")?;
        }

        string modname = parser.parseModuleName?;
        target = (:normal, modname, pak);
    }

    mut string[] symbols;
    if (!isMacroImport && parser.accept(":")?) {
        (string | fail Error) expectIdentifier(Parser parser) {
            auto ident = parser.parseIdentifier?;
            parser.assert_(ident.length > 0, "identifier expected")?;
            return ident;
        }
        (bool | fail Error) peek(Parser parser, string str) {
            parser.begin;
            auto ret = parser.accept(str)?;
            parser.revert;
            return ret;
        }
        // : [symbol] [, symbol]* ,? ;
        symbols ~= parser.expectIdentifier?;
        while (parser.accept(",")?) {
            if (parser.peek(";")?) { break; }
            symbols ~= parser.expectIdentifier?;
        }
    }
    parser.expect(";")?;
    return new ASTImportStatement(target, isMacroImport, symbols, parser.to(from));
}

(string | fail Error) parseModuleName(Parser parser) {
    mut string ret;
    while (true) {
        ret ~= parser.parseIdentifier?;
        if (!parser.accept(".")?) break;
        ret ~= ".";
    }
    return ret;
}

class ModuleParserConfig
{
    Package[] packages;

    ASTModule[] defaultImports;

    this(this.packages, this.defaultImports) { }
}

(nullable ASTModule | fail Error) parseMacroContinuation(CompilerBase compiler, Parser parser, ParserHelper helper, ASTModule astModule,
    ModuleParserConfig config)
{
    parser.begin;
    if (!acceptIdentifier(parser, "macro")? || !parser.accept("(")?)
    {
        parser.revert;
        return null;
    }
    parser.commit;
    string identifier = parser.parseIdentifier?;
    parser.expect(")")?;
    parser.expect(";")?;

    auto newMacroState = astModule.macroState.dup;

    helper.proxyCall(astModule, identifier, newMacroState)?;

    auto subModule = new ASTModule(astModule.name, astModule.pak, newMacroState, astModule.locRange, astModule);

    return parseModuleBody(compiler, parser, helper, subModule, config);
}

(Package | fail Error) selectPackage(Package[] packages, string name, LocRange locRange)
{
    auto result = [first a for a in packages where a.name == name else null];
    locRange.assert(!!result, "undefined package: '$name'")?;
    return result.notNull;
}

class LexicalContextImpl : LexicalContext
{
    ParserHelper helper;

    ModuleParserConfig config;

    this(this.compiler, this.pak, this.macroState, this.helper, this.config) { }

    override (ASTModuleBase | fail Error) resolveImport(ASTImportStatement importStmt) {
        return .resolveImport(compiler, pak.name, importStmt, helper, config);
    }
}

(nullable ASTVersion | fail Error) parseModuleVersion(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("version")?) {
        mut ASTModuleEntry[] then, else_;
        parser.expect("(")?;
        string versionStr = parser.parseIdentifier?;
        parser.expect(")")?;
        if (parser.accept("{")?) {
            while (!parser.accept("}")?) {
                then ~= parser.parseModuleEntry(lexicalContext, false)?;
            }
        } else {
            then ~= parser.parseModuleEntry(lexicalContext, false)?;
        }
        if (parser.accept("else")?) {
            if (parser.accept("{")?) {
                while (!parser.accept("}")?) {
                    else_ ~= parser.parseModuleEntry(lexicalContext, false)?;
                }
            } else {
                else_ ~= parser.parseModuleEntry(lexicalContext, false)?;
            }
        }
        return new ASTVersion(versionStr, then, else_);
    }
    return null;
}

(ASTModuleEntry | fail Error) parseModuleEntry(Parser parser, LexicalContext lexicalContext, bool toplevel)
{
    mut (Protection | :none) protection = :none;
    if (parser.accept("public")?) {
        protection = Protection.public_;
    } else if (parser.accept("private")?) {
        protection = Protection.private_;
    }
    Protection getProtection() {
        return protection.case(
            Protection p: p,
            (:none): Protection.public_);
    }

    if (auto importStmt = parseImportStatement(parser, lexicalContext)?) {
        if (!toplevel && importStmt.isMacroImport)
        {
            return parser.fail("macro import not allowed here");
        }

        auto pool = lexicalContext.compiler.workPool;
        auto id = importStmt.repr(lexicalContext.pak.name);
        auto task = new ImportTask(lexicalContext, importStmt);
        auto import_ = new ASTImport(importStmt, (pool, id, task));

        if (toplevel) pool.queue(id, task);

        return ASTModuleEntry(getProtection, import_);
    }
    if (auto sym = parseTemplateContents(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, sym);
    }
    if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, decl);
    }
    parseExtern(parser, lexicalContext).case {
        ASTExternFunction fun: {
            return ASTModuleEntry(getProtection, fun);
        }
        ASTExternVariable var: {
            return ASTModuleEntry(getProtection, var);
        }
        (:none): {}
        Error err: return err;
    }
    if (ASTUnitTest ut = parseUnitTest(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, ut);
    }
    if (ASTPragma pragma_ = parsePragma(parser, lexicalContext)?) {
        return ASTModuleEntry(getProtection, pragma_);
    }
    if (ASTVersion version_ = parseModuleVersion(parser, lexicalContext)?) {
        protection.case {
            Protection p: {
                string repr(Protection p) {
                    if (p == Protection.public_) return "public";
                    if (p == Protection.private_) return "private";
                    if (p == Protection.protected_) return "protected";
                    assert(false);
                }
                return parser.fail("unsupported '$(p.repr)' qualifier on 'version' block");
            }
            (:none): {}
        }
        return ASTModuleEntry(Protection.public_, version_);
    }

    return parser.fail("couldn't parse function or struct");
}

(ASTModule | fail Error) parseModuleBody(CompilerBase compiler, Parser parser, ParserHelper helper, ASTModule module_,
    ModuleParserConfig config)
{
    mut LexicalContext lexicalContext = new LexicalContextImpl(compiler, module_.pak, module_.macroState, helper, config);

    while (!parser.eof?)
    {
        if (ASTModule submod = parseMacroContinuation(compiler, parser, helper, module_, config)?)
            return submod;

        auto loc = parser.loc;
        auto entry = parseModuleEntry(parser, lexicalContext, true)?;
        loc.hardCheck(parser.level == 0, "parse rule imbalance");

        entry.symbol.case {
            ASTImport import_:
                if (import_.statement.isMacroImport) {
                    auto id = import_.statement.repr(lexicalContext.pak.name);

                    module_.macroState = module_.macroState.dup;
                    lexicalContext = new LexicalContextImpl(compiler, module_.pak, module_.macroState, helper, config);

                    lexicalContext.macroState.addImport(
                        lexicalContext.compiler.workPool.wait(id)
                            .instanceOf(ImportTask).module_?.macroState);
                    continue;
                }
            default: {}
        }
        module_.entries ~= entry;
    }
    assert(parser.level == 0);
    return module_;
}

(ASTModule | fail Error) resolveImport(CompilerBase compiler, string pak, ASTImportStatement import_, ParserHelper helper,
    ModuleParserConfig config)
{
    (string name, string pak) target = import_.target.case(
        (:normal, string name, string pak): (name, pak),
        (:macro_, ASTModuleBase module_): return module_.instanceOf(ASTModule).notNull);
    mut Package pak = selectPackage(config.packages, pak, import_.locRange)?;
    // TODO enum SearchMode { Transitive, Direct, Commandline }
    mut bool transitive = true;
    if (target.pak.length) {
        pak = selectPackage(config.packages, target.pak, import_.locRange)?;
        transitive = false;
    }
    return getModule(
        compiler, moduleToFile(target.name), pak, true, helper, config, import_.locRange);
}

(Module | fail Error) compileModule(Context context, ASTModule astModule, bool addDefaultImports)
{
    mut nullable Module parent = null;
    if (auto astParent = astModule.parent)
    {
        parent = compileModule(context, astParent, addDefaultImports)?;
    }

    Module module_ = new Module(astModule.name, astModule.mangledName, astModule.locRange, parent);
    auto context = context.withNamespace(module_);

    if (addDefaultImports) {
        context.compiler.addDefaultImports(context, module_)?;
    }

    // Handle all (toplevel) imports in parallel.
    for (entry in astModule.entries) {
        entry.symbol.case {
            ASTImport import_:
                auto mod = import_.module_?;
                auto id = "compile platform $(context.platform.ident) ast $(mod.mangledName)";
                auto task = new AstCompileTask(mod, context);
                context.compiler.workPool.queue(id, task);
            default: {}
        }
    }

    (void | fail Error) handleEntry(ASTModuleEntry entry)
    {
        entry.symbol.case {
            ASTImport import_: {
                // requeue in case it was in a version()
                auto mod = import_.module_?;
                auto id = "compile platform $(context.platform.ident) ast $(mod.mangledName)";
                auto task = new AstCompileTask(mod, context);
                context.compiler.workPool.queue(id, task);

                auto importedModule = context.compiler.workPool.wait(id)
                    .instanceOf(AstCompileTask).module_?;

                bool public_ = entry.protection == Protection.public_;

                module_.addImport(
                    importedModule, public_=public_, import_.statement.symbols);
            }
            ASTDeclaration astDecl: {
                if (auto structDecl = astDecl.instanceOf(ASTStructDecl)) {
                    module_.add(structDecl.struct_.name, entry.protection, structDecl.struct_);
                } else if (auto aliasDecl = astDecl.instanceOf(ASTAliasDecl)) {
                    module_.register(aliasDecl.name, entry.protection, aliasDecl.target.compile(context)?);
                } else if (auto templateDecl = astDecl.instanceOf(ASTTemplateDecl)) {
                    module_.register(templateDecl.name, entry.protection, templateDecl.compileSymbol(context));
                } else {
                    print("declaration $(astDecl.repr)");
                    assert(false);
                }
            }
            ASTSymbol symbol: {
                // TODO just handle all as ASTDeclaration
                if (auto classDecl = symbol.instanceOf(ASTClassDecl)) {
                    module_.add(classDecl.name, entry.protection, classDecl);
                }
                else if (auto intfDecl = symbol.instanceOf(ASTIntfDecl)) {
                    module_.add(intfDecl.name, entry.protection, intfDecl);
                }
                else if (auto enumDecl = symbol.instanceOf(ASTEnumDecl)) {
                    module_.register(enumDecl.name, entry.protection, enumDecl.compile(context)?);
                }
                else if (auto aliasDecl = symbol.instanceOf(ASTAliasDecl)) {
                    module_.add(aliasDecl.name, entry.protection, aliasDecl);
                }
                else if (auto struct_ = symbol.instanceOf(ASTStruct)) {
                    module_.add(struct_.name, entry.protection, struct_);
                }
                else if (auto funDef = symbol.instanceOf(ASTFunction)) {
                    module_.add(funDef.name, entry.protection, funDef);
                }
                else {
                    print("symbol $(symbol.repr)");
                    assert(false);
                }
            }
            ASTExternFunction extern_:
                module_.register(extern_.name, entry.protection, extern_.compile(context)?);
            ASTExternVariable extern_:
                module_.register(extern_.name, entry.protection, extern_.compile(context)?);
            ASTUnitTest ut:
                module_.add("", entry.protection, ut);
            ASTPragma pragma_:
                module_.track(pragma_.compile(context)?);
            ASTVersion version_: {
                if ([any a == version_.name for a in context.platform.versions]) {
                    [handleEntry(entry)? for entry in version_.then];
                } else {
                    [handleEntry(entry)? for entry in version_.else_];
                }
            }
        }
    }

    [handleEntry(entry)? for entry in astModule.entries];

    module_.compile(context)?;

    return module_;
}

(ASTModule | fail Error) getModule(CompilerBase compiler, mut string filename, mut nullable Package pak, bool search,
    ParserHelper helper, ModuleParserConfig config, LocRange locRange)
{
    mut string path = filename;
    if (search) {
        assert2s(!!pak, "search, but no package");
        // TODO destructuring tuple
        auto pair = findFileInPackage(filename, pak.notNull, locRange)?;
        path = pair[0];
        pak = pair[1];
    } else {
        assert2s(!pak, "no search, but package");
        auto pair = findResidualFilename(filename, config.packages);
        filename = pair[0];
        pak = pair[1];
    }
    assert(!!pak);
    auto pak = pak.notNull;
    // FIXME the workpool queueing here is 100% redundant with the ImportTask queueing, p sure
    compiler.workPool.queue(path, new ParseAstModuleTask(compiler, filename, path, pak, helper, config, locRange));
    return compiler.workPool.wait(path).instanceOf(ParseAstModuleTask).module_;
}

class ParseAstModuleTask : ITask
{
    CompilerBase compiler;
    string filename;
    string path;
    Package pak;
    ParserHelper helper;
    ModuleParserConfig config;
    LocRange locRange;
    (ASTModule | :none | Error) result;
    this(this.compiler, this.filename, this.path, this.pak, this.helper, this.config, this.locRange) {
        this.result = :none;
    }
    (ASTModule | fail Error) module_() {
        result.case {
            ASTModule mod: return mod;
            (:none): assert(false);
            Error err: return err;
        }
    }
    override void run() {
        this.result = parse;
    }
    (ASTModule | fail Error) parse() {
        string code = read(path);
        // do not count references on the file source - it will end
        // up with lots of small inc/decs to fragments that we never free anyway
        (cast(size_t*) &code)[2] = 0;
        Parser parser = new Parser(path, code);

        auto fromAtModule = parser.from?;
        parser.expect("module")?;
        string modname = parser.parseModuleName?;
        parser.expect(";")?;

        import std.string : endsWith;

        parser.to(fromAtModule).assert(
            filename.endsWith(modname.moduleToFile),
            "$filename: module doesn't match filename")?;

        ASTModule baseModule = new ASTModule(modname, pak, new MacroState, parser.to(fromAtModule), null);
        return parseModuleBody(compiler, parser, helper, baseModule, config);
    }
}
