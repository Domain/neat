module neat.either;

macro import neat.macros.quasiquoting;

import backend.base;
import helpers;
import neat.base;
import neat.expr;
import neat.parser;
import neat.hash;
import neat.parser_base;
import neat.types;

/**
 * Note: Either field offset is member index + 1!
 * This way, the uninitialized state can be detected and caught.
 * (It isn't yet, though.)
 */

/**
 * What is 'fail'?
 * A "failing member" is a member of an Either decl that represents a failure of the function.
 * When extracting a result from the call, "failing" members are considered falsy and excluded.
 */
struct ASTEitherDeclEntry
{
    (Loc | LocRange) locRange;

    bool fail;

    ASTSymbol symbol;
}

class ASTEitherDecl : ASTSymbol
{
    ASTEitherDeclEntry[] partTypes;

    this(this.partTypes) { }

    override (Type | fail Error) compile(Context context)
    {
        auto partTypes = new (bool fail, Type)[](this.partTypes.length);
        for (i, partType in this.partTypes) {
            auto type = partType.symbol.compile(context)?.beType2(partType.locRange.case(Loc loc: loc.locRange, LocRange range: range))?;
            partTypes[i] = (partType.fail, type);
        }

        return new Either(partTypes);
    }

    override ASTSymbol quote(Quoter quoter)
    {
        // TODO move into quoter?
        ASTSymbol quoteBool(bool b) {
            if (b) return quoter.compiler.astIdentifier("true", __RANGE__);
            return quoter.compiler.astIdentifier("false", __RANGE__);
        }
        mut ASTSymbol[] quotedParts;
        for (entry in this.partTypes) {
            quotedParts ~= quoter.compiler.astCall(
                quoter.compiler.astIdentifier("ASTEitherDeclEntry", __RANGE__), [
                    quoter.quoteLocRange(entry.locRange.case(Loc loc: loc.locRange, LocRange range: range)),
                    quoteBool(entry.fail),
                    entry.symbol.quote(quoter)], __RANGE__);
        }
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTEitherDecl", __RANGE__), [
                quoter.compiler.astArrayLiteral(quotedParts, __RANGE__)], __RANGE__);
    }
}

class EitherExpr : Expression
{
    Either either;

    Expression value;

    int offset;

    this(this.either, this.value, this.offset) {
        this.type = this.either;
        // consume value's lifetime
        this.info = this.value.info;
    }

    override int emit(Generator generator)
    {
        BackendType eitherType = either.emit(generator.platform);
        int reg = generator.fun.staticAlloca(eitherType);
        int offsetTarget = generator.fun.fieldOffset(eitherType, reg, 0);
        int offsetValue = generator.fun.intLiteral(offset + 1);
        int rawValueTarget = generator.fun.fieldOffset(eitherType, reg, 1);
        BackendType backendValueType = either.types[offset].type.emit(generator.platform);
        int valueTarget = generator.fun.bitcast(rawValueTarget, new BackendPointerType(backendValueType));
        int value = this.value.emit(generator);

        generator.fun.store(new BackendIntType, offsetTarget, offsetValue);
        generator.fun.store(backendValueType, valueTarget, value);

        return generator.fun.load(eitherType, reg);
    }

    override void hash(Hash hash) { hash.adds("EitherExpr"); value.hash(hash); hash.addl(offset); }
}

class EitherType : Expression
{
    Expression value;

    this(this.value) {
        this.type = new Integer;
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emit(Generator generator)
    {
        auto eitherType = this.value.type.emit(generator.platform);
        int eitherValue = this.value.emit(generator);
        return generator.fun.field(eitherType, eitherValue, 0);
    }

    override void hash(Hash hash) { hash.adds("EitherType"); value.hash(hash); }
}

class EitherTypeReference : Reference
{
    Reference base;

    this(this.base) {
        this.type = new Integer;
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emitLocation(Generator output)
    {
        auto eitherType = this.base.type.emit(output.platform);
        int baseptr = this.base.emitLocation(output);
        return output.fun.fieldOffset(eitherType, baseptr, 0);
    }

    override int emit(Generator output)
    {
        return output.fun.load(this.type.emit(output.platform), this.emitLocation(output));
    }

    override void hash(Hash hash) { hash.adds("EitherTypeReference"); base.hash(hash); }
}

class EitherReference : Reference
{
    Reference base;

    int offset;

    this(this.base, this.offset) {
        this.type = this.base.type.instanceOf(Either).types[this.offset].type;
        // EitherReference should not participate in memory management
        this.info = ExprInfo(false, Ownership.owned);
    }

    override int emitLocation(Generator output)
    {
        BackendType eitherType = this.base.type.emit(output.platform);
        int eitherPtr = this.base.emitLocation(output);
        int eitherUnionPtr = output.fun.fieldOffset(eitherType, eitherPtr, 1);
        BackendType backendValueType = this.type.emit(output.platform);
        int valuePtr = output.fun.bitcast(eitherUnionPtr, new BackendPointerType(backendValueType));

        return valuePtr;
    }

    override int emit(Generator output)
    {
        return output.fun.load(
            this.type.emit(output.platform),
            emitLocation(output));
    }

    override void hash(Hash hash) { hash.adds("EitherReference"); base.hash(hash); hash.addl(offset); }
}

class EitherMember : Expression
{
    Expression value;

    int offset;

    this(this.value, this.offset) {
        this.type = this.value.type.instanceOf(Either).types[this.offset].type;
        this.info = this.value.info;
    }

    override int emit(Generator generator)
    {
        BackendType eitherType = this.value.type.emit(generator.platform);
        int eitherValuePtr = generator.fun.staticAlloca(eitherType);

        int eitherValue = this.value.emit(generator);
        generator.fun.store(eitherType, eitherValuePtr, eitherValue);

        int eitherUnionPtr = generator.fun.fieldOffset(eitherType, eitherValuePtr, 1);
        // load the union value
        BackendType backendValueType = this.type.emit(generator.platform);
        int valuePtr = generator.fun.bitcast(eitherUnionPtr, new BackendPointerType(backendValueType));
        return generator.fun.load(backendValueType, valuePtr);
    }

    override void hash(Hash hash) { hash.adds("EitherMember"); value.hash(hash); hash.addl(offset); }
}

class Either : Type
{
    (bool fail, Type type)[] types;

    this(this.types) {
        this.zeroInitializable = false;
    }

    override BackendType emit(Platform platform) {
        mut int size = 0;
        mut int alignment = 1;
        for (i, pair in this.types) {
            auto llvmType = pair.type.emit(platform);
            int memberSize = llvmType.size(platform);
            int memberAlignment = llvmType.alignment(platform);

            if (memberSize > size) size = memberSize;
            if (memberAlignment > alignment) alignment = memberAlignment;
        }
        auto parts = new BackendType[](2);
        parts[0] = new BackendIntType;
        parts[1] = new BackendSpacerType(size, alignment);
        return new BackendStructType(parts);
    }

    override nullable Expression implicitConvertFrom(Context context, Expression source)
    {
        for (int i, entry in this.types) {
            if (entry.type.same(source.type)) return new EitherExpr(this, source, i);
        }
        for (int i, entry in this.types) {
            if (auto converted = context.compiler.implicitConvertTo(context, source, entry.type))
                return new EitherExpr(this, converted, i);
        }
        return null;
    }

    override nullable Expression implicitConvertTo(Context context, Expression source, Type targetType)
    {
        // Check that every member can be converted.
        for (int i, _ in this.types) {
            auto member = new EitherMember(source, i);
            auto converted = context.compiler.implicitConvertTo(context, member, targetType);
            if (!converted) return null;
        }
        (nullable Expression | fail Error) do1(Expression source) {
            (nullable Statement | fail Error) do2(Reference target) {
                mut nullable Statement ifTree = null;
                auto sourceType = new EitherType(source);
                for (int i, type in this.types) {
                    auto member = new EitherMember(source, i);
                    auto converted = context.compiler.implicitConvertTo(context, member, targetType).notNull;
                    Expression test = context.compiler.binaryOp(
                        "==", context, sourceType, context.compiler.intLiteral(i + 1), __RANGE__)?;
                    Statement assign = context.compiler.assignStatement(target, converted);
                    ifTree = context.compiler.ifStatement(test, assign, ifTree);
                }
                return ifTree;
            }
            // TODO settle ownership
            return context.compiler.exprWithScratchspace(targetType, false, &do2);
        }
        context.compiler.exprWithTemporaryExpr(source, &do1).case {
            nullable Expression expr: return expr;
            Error: assert(false);
        }
    }

    override bool same(Type type) {
        auto other = type.instanceOf(Either);
        if (!other || types.length != other.types.length)
            return false;
        for (i, type in types)
            if (!type.type.same(other.types[i].type))
                return false;
        return true;
    }

    override string mangle() {
        mut string ret = "either";
        for (i, type in types)
            ret ~= "_" ~ type.type.mangle();
        return ret;
    }

    override string repr() {
        mut string ret = "(";
        for (i, entry in types) {
            if (i) ret ~= " | ";
            ret ~= entry.type.repr();
        }
        ret ~= ")";
        return ret;
    }

    override void hash(Hash hash) {
        hash.adds("Either");
        hash.addl(types.length);
        for (entry in types)
            entry.type.hash(hash);
    }

    /**
     * Called to create a copy of an expression in a target.
     */
    override (nullable Statement | fail Error) copyInto(Context context, Reference target, Expression source)
    {
        (nullable Statement | fail Error) do_(Expression source) {
            auto sourceType = new EitherType(source);
            auto targetType = new EitherTypeReference(target);
            auto typeAssignment = context.compiler.assignStatement(targetType, sourceType);

            mut nullable Statement ifTree;
            for (int i, entry in types) {
                auto targetMember = new EitherReference(target, i);
                auto sourceMember = new EitherMember(source, i);

                (Statement | fail Error) copy() {
                    if (auto copyInto = entry.type.copyInto(context, targetMember, sourceMember)?)
                        return copyInto;
                    return context.compiler.assignStatement(targetMember, sourceMember);
                }
                Expression test = context.compiler.binaryOp(
                    "==", context, sourceType, context.compiler.intLiteral(i + 1), __RANGE__)?;
                ifTree = context.compiler.ifStatement(test, copy?, ifTree);
            }
            if (auto ifTree = ifTree)
                return context.compiler.sequenceStatement([typeAssignment, ifTree]);
            return null; // no copyInto for any member
        }
        // TODO tmpize `target`
        if (auto ret = context.compiler.stmtWithTemporaryExpr(source, &do_)?)
            return ret;
        assert(false);
    }

    /**
     * Called when a scoped expression goes out of scope.
     */
    override nullable Statement endLifetime(Context context, Reference reference)
    {
        (nullable Statement | fail Error) do_(Expression refPtr) {
            auto reference = context.compiler.dereference(refPtr);
            auto valueType = new EitherType(reference);

            mut nullable Statement ifTree;
            for (int i, entry in types) {
                auto member = new EitherReference(reference, i);

                if (auto destroy = entry.type.endLifetime(context, member))
                {
                    Expression test = context.compiler.binaryOp(
                        "==", context, valueType, context.compiler.intLiteral(i + 1), __RANGE__)?;
                    ifTree = context.compiler.ifStatement(test, destroy, ifTree);
                }
            }

            return ifTree;
        }
        context.compiler.stmtWithTemporaryExpr(
            context.compiler.reference(reference),
            &do_
        ).case {
            nullable Statement stmt: return stmt;
            Error: assert(false);
        }
    }

    override (nullable Expression | fail Error) binaryOp(
        Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        if (op == "==") {
            mut auto rhs = rhs;
            if (auto converted = context.compiler.implicitConvertTo(context, rhs, lhs.type)) {
                rhs = converted;
            } else {
                return null;
            }

            (nullable Expression | fail Error) do1(Expression lhs) {
                (nullable Expression | fail Error) do2(Expression rhs) {
                    auto lhsType = new EitherType(lhs);
                    auto rhsType = new EitherType(rhs);
                    auto typeEq = context.compiler.astBinaryOp(
                        "==", new ASTSymbolHelper(lhsType), new ASTSymbolHelper(rhsType), __RANGE__);
                    mut ASTEitherCaseExprCase[] eqCases;
                    for (i, entry in types) {
                        auto rhsMember = new EitherMember(rhs, cast(int) i);
                        auto memberEq = context.compiler.astBinaryOp(
                            "==",
                            context.compiler.astIdentifier("a", __RANGE__),
                            new ASTSymbolHelper(rhsMember), __RANGE__);

                        eqCases ~= ASTEitherCaseExprCase(
                            __RANGE__, new ASTSymbolHelper(entry.type), "a", return_=false, memberEq);
                    }
                    auto eqTest = new ASTEitherCaseExpr(__RANGE__, new ASTSymbolHelper(lhs), eqCases);
                    auto combinedExpr = context.compiler.astBinaryOp("&&", typeEq, eqTest, __RANGE__);

                    return combinedExpr.compile(context)?.beExpression(locRange)?;
                }
                return context.compiler.exprWithTemporaryExpr(rhs, &do2);
            }
            return context.compiler.exprWithTemporaryExpr(lhs, &do1);
        }
        return null;
    }
}

/**
 * a.case(T t: 5, U u: 6)
 */
struct ASTEitherCaseExprCase
{
    (Loc|LocRange) loc;

    LocRange locRange() { return loc.case(Loc loc: loc.locRange, LocRange range: range); }

    ASTSymbol type;

    string identifier;

    bool return_;

    ASTSymbol expr;
}

class ASTEitherCaseExpr : ASTSymbol
{
    ASTSymbol base;

    ASTEitherCaseExprCase[] cases;

    this((Loc | LocRange) locRange, this.base, this.cases) { this.locRange = locRange.case(LocRange range: range, Loc loc: loc.locRange); }

    override (Expression | fail Error) compile(Context context) {
        auto baseExpr = base.compile(context)?.beExpressionImplCall(context, locRange)?;
        auto baseExprTemp = new PairedTemporary(baseExpr.type, Ownership.global);
        Statement baseExprInit = new InitializeTemporaryStatement(baseExprTemp, baseExpr);

        auto either = baseExpr.type.instanceOf(Either);

        locRange.assert(!!either, "Expected Either for case expression")?;

        bool[] handled = new bool[](either.types.length);

        // TODO implicitConvertTo should only require Type - ie. return a Expression function(Expression).
        mut Type[] resultTypes;
        void mergeType(LocRange locRange, Expression expr) {
            auto exprType = expr.type;
            for (resultType in resultTypes)
                if (resultType.same(exprType)) return;
            resultTypes ~= exprType;
        }
        for (case_ in this.cases) {
            if (case_.return_) continue;

            auto caseLoc = case_.locRange;
            auto caseType = case_.type.compile(context)?.beType2(caseLoc)?;

            auto namespace = context.compiler.variableDeclaration(
                context.namespace, case_.identifier, caseType, ExprInfo(mutable=false, Ownership.owned), false);
            auto subContext = context.withNamespace(namespace);

            Expression expr = case_.expr.compile(subContext)?.beExpressionImplCall(context, caseLoc)?;
            mergeType(caseLoc, expr);
        }

        assert(resultTypes.length > 0);
        mut uninitialized Type mergeType;
        if (resultTypes.length == 1) mergeType = resultTypes[0];
        else {
            mut (bool fail, Type)[] members;
            for (type in resultTypes) members ~= (false, type);
            mergeType = new Either(members);
        }
        // as ASTReturn
        auto resultVal = new PairedTemporary(mergeType, Ownership.gifted);
        Statement initResultVal = new UninitializeTemporaryStatement(resultVal);
        mut nullable Statement ifTree;

        for (case_ in this.cases) {
            auto caseLoc = case_.locRange;
            Type type = case_.type.compile(context)?.beType2(caseLoc)?;

            mut int matched = -1;
            for (int k, eitherType in either.types) {
                if (type.same(eitherType.type)) {
                    caseLoc.assert(matched == -1, "either type " ~ type.repr() ~ " matched twice")?;
                    matched = k;
                }
            }
            caseLoc.assert(matched != -1, "Type is not listed in Either!")?;
            handled[matched] = true;

            mut Statement[] thenSteps;

            Ownership varOwnership() {
                if (baseExpr.info.ownership == Ownership.gifted)
                    return Ownership.owned;
                return Ownership.borrowed;
            }

            auto namespace = context.compiler.variableDeclaration(
                context.namespace, case_.identifier, type, ExprInfo(mutable=false, varOwnership), false);
            auto context = context.withNamespace(namespace);
            // FIXME rename to accessDecl
            Reference variable = namespace.accessDecl2(context.compiler);
            // Borrow the case base.
            thenSteps ~= context.compiler.assignStatement(variable, new EitherMember(baseExprTemp, matched));
            Expression userExpr = case_.expr.compile(context)?
                .beExpressionImplCall(context, caseLoc)?;
            (Statement | fail Error) userStmt() {
                if (case_.return_) {
                    Type ret = findParent!FunctionScopeBase(context.namespace).ret;
                    auto userExpr = context.compiler.expectImplicitConvertTo(context, userExpr, ret, this.locRange)?;
                    return context.compiler.astReturn(new ASTSymbolHelper(userExpr), __RANGE__).compile(context)?
                         .statement;
                } else {
                    Expression expr = context.compiler.expectImplicitConvertTo(context, userExpr, mergeType, caseLoc)?;
                    return context.compiler.move(context, resultVal, expr);
                }
            }
            thenSteps ~= userStmt?;
            if (varOwnership == Ownership.owned) {
                if (auto destroy = variable.type.endLifetime(context, variable)) {
                    thenSteps ~= destroy;
                }
            }
            Statement then = context.compiler.sequenceStatement(thenSteps);
            Expression test = context.compiler.binaryOp(
                "==", context, new EitherType(baseExprTemp), context.compiler.intLiteral(matched + 1), locRange)?;

            ifTree = context.compiler.ifStatement(test, then, ifTree);
        }
        for (i, handled in handled) {
            if (!handled) {
                return locRange.fail("Type " ~ either.types[i].type.repr() ~ " not handled!");
            }
        }
        assert(!!ifTree);

        return context.compiler.statementExpression(
            context.compiler.sequenceStatement([baseExprInit, initResultVal, ifTree.notNull]), resultVal);
    }

    override ASTSymbol quote(Quoter quoter) {
        mut ASTSymbol[] quotedCases;
        ASTSymbol quoteBool(bool b) {
            if (b) return quoter.compiler.astIdentifier("true", __RANGE__);
            return quoter.compiler.astIdentifier("false", __RANGE__);
        }
        for (case_ in this.cases) {
            quotedCases ~= quoter.compiler.astCall(
                quoter.compiler.astIdentifier("ASTEitherCaseExprCase", __RANGE__), [
                    quoter.quoteLocRange(case_.locRange),
                    case_.type.quote(quoter),
                    quoter.compiler.astStringLiteral(case_.identifier, __RANGE__),
                    quoteBool(case_.return_),
                    case_.expr.quote(quoter)], __RANGE__);
        }
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTEitherCaseExpr", __RANGE__), [
                quoter.quoteLocRange(this.locRange),
                this.base.quote(quoter),
                quoter.compiler.astArrayLiteral(quotedCases, __RANGE__)], __RANGE__);
    }
}

(nullable ASTSymbol | fail Error) parseEitherCaseExpr(Parser parser, LexicalContext lexicalContext, ASTSymbol current)
{
    parser.begin;
    if (!(parser.accept(".")? && acceptIdentifier(parser, "case")? && parser.accept("(")?))
    {
        parser.revert;
        return null;
    }
    auto from = parser.from?;
    parser.commit;

    mut ASTEitherCaseExprCase[] cases;
    while (!parser.accept(")")?)
    {
        if (cases.length) parser.expect(",")?;
        auto caseFrom = parser.from?;
        nullable ASTSymbol type = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        parser.to(caseFrom).assert(!!type, "case type expected")?;
        string identifier = parseIdentifier(parser)?;
        parser.expect(":")?;
        bool return_ = parser.acceptIdentifier("return")?;
        ASTSymbol expr = lexicalContext.compiler.parseExpression(parser, lexicalContext)?
            .notNull;
        cases ~= ASTEitherCaseExprCase(parser.to(from), type.notNull, identifier, return_, expr);
    }
    return new ASTEitherCaseExpr(parser.to(from), current, cases);
}

/**
 * a.case {
 *   T t: foo;
 *   U u: { bar; }
 * }
 */

struct ASTEitherCaseStmtCase
{
    (Loc|LocRange) loc;

    LocRange locRange() { return loc.case(Loc loc: loc.locRange, LocRange range: range); }

    ASTSymbol type;

    string identifier;

    ASTStatement stmt;
}

class ASTEitherCaseStmt : ASTStatement
{
    ASTSymbol base;

    ASTEitherCaseStmtCase[] cases;

    nullable ASTStatement default_;

    this((LocRange|Loc) locRange, this.base, this.cases, this.default_) { this.locRange = locRange.case(Loc loc: loc.locRange, LocRange range: range); }

    override (StatementCompileResult | fail Error) compile(Context context) {
        auto baseExpr = base.compile(context)?
            .beExpressionImplCall(context, locRange)?;
        // FIXME
        // locRange.assert(baseExpr.info.ownership != Ownership.gifted, "TODO: Either base expr must not be gifted");
        auto baseType = baseExpr.type;
        auto either = baseType.instanceOf(Either);

        locRange.assert(!!either, "Expected Either for case expression")?;

        (nullable Statement | fail Error) do_(Expression baseExpr) {
            bool[] handled = new bool[](either.types.length);
            mut nullable Statement ifTree = null;
            for (case_ in this.cases) {
                Type type = case_.type.compile(context)?.beType2(case_.locRange)?;

                mut int matched = -1;
                for (int k, entry in either.types) {
                    if (type.same(entry.type)) {
                        case_.locRange.assert(matched == -1, "either type " ~ type.repr() ~ " matched twice")?;
                        matched = k;
                    }
                }
                case_.locRange.assert(matched != -1, "Type is not listed in Either!")?;
                handled[matched] = true;

                with (context.compiler) {
                    auto namespace = variableDeclaration(
                        context.namespace, case_.identifier, type, ExprInfo(mutable=false, Ownership.borrowed), false);
                    // FIXME rename to accessDecl
                    Reference variable = namespace.accessDecl2(context.compiler);
                    Statement assignment = assignStatement(variable, new EitherMember(baseExpr, matched));
                    auto userStmtPair = case_.stmt.compile(context.withNamespace(namespace))?;
                    Statement then = sequenceStatement([assignment, userStmtPair.statement]);
                    Expression test = binaryOp(
                        "==", context, new EitherType(baseExpr), intLiteral(matched + 1), this.locRange)?;

                    ifTree = ifStatement(test, then, ifTree);
                }
            }
            for (int i, handled in handled) with (context.compiler) {
                if (auto default_ = this.default_) {
                    if (!handled) {
                        auto defaultPair = default_.compile(context)?;
                        Expression test = binaryOp(
                            "==", context, new EitherType(baseExpr), intLiteral(i + 1), this.locRange)?;
                        ifTree = ifStatement(test, defaultPair.statement, ifTree);
                    }
                } else if (!handled) {
                    return locRange.fail("Type " ~ either.types[i].type.repr() ~ " not handled!");
                }
            }
            return ifTree;
        }
        return StatementCompileResult(
            context.compiler.stmtWithTemporaryExpr(baseExpr, &do_)?.notNull,
            context);
    }

    override ASTSymbol quote(Quoter quoter) {
        mut ASTSymbol[] quotedCases;
        for (case_ in this.cases) {
            quotedCases ~= quoter.compiler.astCall(
                quoter.compiler.astIdentifier("ASTEitherCaseStmtCase", __RANGE__), [
                    quoter.quoteLocRange(case_.locRange),
                    case_.type.quote(quoter),
                    quoter.compiler.astStringLiteral(case_.identifier, __RANGE__),
                    case_.stmt.quote(quoter)], __RANGE__);
        }
        ASTSymbol quote(nullable ASTStatement either) {
            if (auto either = either) return either.quote(quoter);
            else return quoter.compiler.astIdentifier("null", __RANGE__);
        }
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTEitherCaseStmt", __RANGE__), [
                quoter.quoteLocRange(this.locRange),
                this.base.quote(quoter),
                quoter.compiler.astArrayLiteral(quotedCases, __RANGE__),
                quote(this.default_)], __RANGE__);
    }
}

(nullable ASTStatement | fail Error) parseEitherCaseStmt(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto expr = lexicalContext.compiler.parseExpressionLeaf(parser, lexicalContext)?;
    if (!expr) {
        parser.revert;
        return null;
    }
    auto member = expr.instanceOf(ASTMemberBase);
    auto from = parser.from?;
    if (!member || member.member != "case" || !parser.accept("{")?) {
        parser.revert;
        return null;
    }
    auto locRange = parser.to(from);
    parser.commit();

    mut ASTEitherCaseStmtCase[] cases;
    mut nullable ASTStatement default_ = null;
    while (!parser.accept("}")?) {
        auto caseFrom = parser.from?;
        if (parser.accept("default")?) {
            parser.expect(":")?;
            if (default_) {
                return parser.fail("cannot have more than one default block");
            }
            auto stmt = parseEitherBlock(parser, lexicalContext)?;
            default_ = stmt;
            continue;
        }

        auto type = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        parser.assert_(!!type, "case type expected")?;
        // identifier can be empty
        string identifier = parseIdentifier(parser)?;
        parser.expect(":")?;
        auto caseLocRange = parser.to(caseFrom);
        auto stmt = parseEitherBlock(parser, lexicalContext)?;
        cases ~= ASTEitherCaseStmtCase(caseLocRange, type.notNull, identifier, stmt);
    }
    return new ASTEitherCaseStmt(locRange, member.base, cases, default_);
}

(ASTStatement | fail Error) parseEitherBlock(Parser parser, LexicalContext lexicalContext)
{
    auto from = parser.from?;
    mut ASTStatement[] stmts;
    while (true) {
        parser.begin;
        bool end = parser.accept("}")?;
        parser.revert;
        if (end) break;
        // are we seeing a new block?
        parser.begin;
        // FIXME better to discard errors here?
        auto type = lexicalContext.compiler.parseType(parser, lexicalContext)?;
        parseIdentifier(parser)?;
        bool newBlock = parser.accept(":")?;
        parser.revert;
        if (newBlock) break;
        ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext)?;
        stmts ~= stmt;
    }
    return lexicalContext.compiler.astScope(stmts, parser.to(from));
}
