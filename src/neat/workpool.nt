module neat.workpool;

macro import neat.macros.listcomprehension;

import neat.base;
import std.thread;

/*
 * Threadpool for pure tasks identified by a string.
 * Any task is started at most once.
 */
class WorkPool : WorkPoolBase
{
    TaskEntry[] tasks;

    Mutex mutex;

    ThreadPool pool;

    int threads;

    ThreadLocal!string currentTask;

    this(this.pool, this.threads) {
        this.mutex = new Mutex;
        this.currentTask = new ThreadLocal!string;
    }

    // Start task running if it isn't running yet.
    override void queue(string id, ITask task) {
        mut uninitialized TaskEntry entry;
        with (mutex.locked) {
            if ([any a.id == id for a in tasks]) {
                return;
            }
            entry = new TaskEntry(id, task, currentTask);
            tasks ~= entry;
        }
        if (threads > 0) pool.addTask(entry);
        else entry.run;
    }

    override ITask wait(string id) {
        mut uninitialized TaskEntry task;
        mut bool preempted;
        with (mutex.locked) {
            int offs = [first cast(int) i for i, a in tasks
                where a.id == id
                else -1];
            assert(offs != -1);
            task = tasks[offs];
            preempted = task.tryPreempt;
        }
        // print("$(currentTask.get) -> $id");
        if (preempted) {
            // The pool didn't get around to even starting the task yet.
            // So we run it ourselves.
            task.runDirectly;
        } else {
            task.wait_;
        }
        // print("$(currentTask.get) <- $id");
        return task.task;
    }
}

private class TaskEntry : Task
{
    string id;

    ITask task;

    (:pending | :running | :preempted | :done) state;

    Mutex mutex;

    CondVar condvar;

    ThreadLocal!string currentTask;

    this(this.id, this.task, this.currentTask) {
        this.mutex = new Mutex;
        this.condvar = new CondVar(this.mutex);
        this.state = :pending;
    }

    /**
     * Returns true if the task was "preempted": that is, the task has not
     * run yet, has not even started, and now it will never start.
     */
    bool tryPreempt() {
        with (mutex.locked) {
            if (state == :pending) {
                state = :preempted;
                return true;
            }
        }
        return false;
    }

    override void run() {
        with (mutex.locked) {
            if (state == :preempted || state == :done) return;
            assert(state == :pending);
            state = :running;
        }
        runDirectly;
    }

    void runDirectly() {
        auto prevTask = currentTask.get;
        currentTask.set(id);
        // print("+$id");
        task.run;
        // print("-$id");
        currentTask.set(prevTask);
        with (mutex.locked) {
            state = :done;
            condvar.broadcast;
        }
    }

    void wait_() {
        with (mutex.locked) {
            while (this.state != :done) this.condvar.wait;
        }
    }
}
