module neat.workpool;

macro import neat.macros.listcomprehension;

import neat.base;
import std.thread;

/*
 * Threadpool for pure tasks identified by a string.
 * Any task is started at most once.
 */
class WorkPool : WorkPoolBase
{
    TaskEntry[] tasks;

    Mutex mutex;

    ThreadPool pool;

    int threads;

    this(this.pool, this.threads) {
        this.mutex = new Mutex;
    }

    // Start task running if it isn't running yet.
    override void queue(string id, ITask task) {
        mut uninitialized TaskEntry entry;
        with (mutex.locked) {
            if ([any a.id == id for a in tasks]) {
                return;
            }
            entry = new TaskEntry(id, task);
            tasks ~= entry;
        }
        if (threads > 0) pool.addTask(entry);
        else entry.run;
    }

    override ITask wait(string id) {
        mut uninitialized TaskEntry task;
        with (mutex.locked) {
            int offs = [first cast(int) i for i, a in tasks
                where a.id == id
                else -1];
            assert(offs != -1);
            task = tasks[offs];
        }
        task.wait;
        return task.task;
    }
}

private class TaskEntry : Task
{
    string id;

    ITask task;

    (:pending | :running | :done) state;

    Mutex mutex;

    CondVar condvar;

    this(this.id, this.task) {
        this.mutex = new Mutex;
        this.condvar = new CondVar(this.mutex);
        this.state = :pending;
    }

    override void run() {
        with (mutex.locked) {
            if (started) {
                // sniped by wait()
                return;
            }
            runImpl;
        }
    }

    void wait() {
        with (mutex.locked) {
            if (:pending <- this.state) runImpl;
            // TODO while (:running <- this.state)
            else while (true) {
                if (:running <- this.state) this.condvar.wait;
                else return;
            }
        }
    }

    void runImpl() {
        this.state = :running;
        with (mutex.unlocked) {
            this.task.run;
        }
        this.state = :done;
        this.condvar.broadcast;
    }

    bool started() {
        return state.case(
            (:pending): false,
            (:running): true,
            (:done): true);
    }
}
