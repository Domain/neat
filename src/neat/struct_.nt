module neat.struct_;

macro import neat.macros.listcomprehension;

import backend.base;
import helpers;
import neat.base;
import neat.expr;
import neat.function_;
import neat.hash;
import neat.parser;
import neat.parser_base;
import neat.statements;
import neat.types;

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    StructMethod[] methods;

    Loc loc;

    string mangledName;

    Hash preHash;

    (BackendStructType type, Platform platform) backendCache;

    this(this.name, this.members, this.loc, string manglePrefix) {
        this.mangledName = manglePrefix ~ "_struct_" ~ this.name;
        this.zeroInitializable = [
            all member.type.zeroInitializable for member in this.members];
    }

    override bool same(Type other) {
        // TODO mangling
        if (auto otherStruct = other.instanceOf(Struct))
            return this.name == otherStruct.name;
        return false;
    }

    override BackendStructType emit(Platform platform)
    {
        if (!backendCache.type || backendCache.platform !is platform) {
            backendCache.platform = platform;
            auto memberTypes = new BackendType[](this.members.length);
            for (int i <- 0 .. this.members.length)
            {
                memberTypes[i] = this.members[i].type.emit(platform);
            }
            backendCache.type = new BackendStructType(memberTypes);
        }
        return backendCache.type;
    }

    override string repr() { return this.name; }

    override string mangle() {
        return this.mangledName;
    }

    override Protection protectionAt(Namespace namespace)
    {
        auto provenance = findParent!StructNamespace(namespace);
        if (provenance && same(provenance.struct_)) return Protection.private_;
        return Protection.public_;
    }

    override nullable Symbol accessMember(
        Loc loc, Context context, nullable Expression baseExpr, string member, Protection protection)
    {
        bool allowed(Protection symbol) {
            int rank(Protection p) {
                if (p == Protection.public_) return 0;
                return 1;
            }
            return rank(symbol) <= rank(protection);
        }

        if (auto baseExpr = baseExpr) {
            size_t memberOffset = [
                first i for i, a in this.members
                where a.name == member && allowed(a.protection)
                else -1];
            if (memberOffset != -1) {
                if (auto reference = baseExpr.instanceOf(Reference)) {
                    return new StructMemberReference(reference, memberOffset);
                }
                return new StructMember(baseExpr, memberOffset);
            }
        }
        size_t methodOffset = [
            first i for i, a in this.methods
            where a.name == member && allowed(a.protection)
            else -1];
        if (methodOffset != -1)
        {
            auto method = this.methods[methodOffset];
            if (method.static_) {
                loc.assert2s(!baseExpr, "static method cannot be called on value");
                return method;
            } else {
                // TODO dereference-into-symbol so we can '&' it again
                auto funcPtr = context.compiler.referenceFunction(method);
                loc.assert2s(!!baseExpr, "non-static method cannot be called on type");
                return new ClassMethodPtr(funcPtr, notNull!Expression(baseExpr), false, method.name);
            }
        }
        return null;
    }

    override void hash(Hash hash)
    {
        if (!this.preHash) {
            this.preHash = new Hash;
            // hash methods?
            with (this.preHash) {
                adds("Struct");
                adds(mangledName);
                addl(members.length);
                [member.type.hash(this.preHash) for member in this.members];
            }
        }
        hash.applyHash(preHash);
    }

    nullable FunctionDeclaration getDtor()
    {
        return [first method for method in this.methods where method.name == "__dtor" else null];
    }

    /**
     * copy constructor is constructor that takes an arg of this struct.
     */
    FunctionDeclaration getCopyCtor()
    {
        return [first method for method in this.methods
            where method.name == "__ctor" && method.params.length == 1 && method.params[0].type.same(this)
            else null];
    }

    nullable Statement callAutoDtor(Context context, Reference ref_)
    {
        auto compiler = context.compiler;

        // Parameter[] params = [Parameter(false, "ptr", new Pointer(ref_.type))];
        ASTSymbol ptr = compiler.astIdentifier("ptr", __HERE__);

        mut ASTStatement[] calls;
        for (int i <- 0 .. members.length) {
            auto entry = members[i];
            auto member = new StructMemberReference(ref_, i);
            auto destroy = entry.type.endLifetime(context, member);
            if (destroy) {
                // calls ~= compiler.$stmt __destroy ptr.$name;;
                calls ~= compiler.astExpressionStmt(
                    compiler.astDestroy(
                        compiler.astMember(ptr, entry.name, __HERE__), __HERE__), __HERE__);
            }
        }
        if (!calls.length) return null;
        ASTStatement body_ = compiler.astSequence(calls, __HERE__);
        // auto fn = compiler.createRuntimeFunction(context, "structrelease", new Void, params, body_);
        // return compiler.call(fn, [compiler.reference(ref_)], loc);
        nullable Statement do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ptr", refptr));

            return body_.compile(context).statement;
        }
        return notNull!Statement(context.compiler.stmtWithTemporaryExpr(compiler.reference(ref_), &do_));
    }

    nullable Statement copyRecursive(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        nullable Statement do1(Expression targetptr) {
            auto target = compiler.dereference(targetptr);
            nullable Statement do2(Expression source) {
                mut Statement[] assigns;
                mut bool anySpecialAssignments;
                for (int i <- 0 .. members.length) {
                    auto targetField = new StructMemberReference(target, i);
                    auto sourceField = new StructMember(source, i);
                    Statement copyInto() {
                        if (auto stmt = members[i].type.copyInto(context, targetField, sourceField)) {
                            anySpecialAssignments = true;
                            return stmt;
                        }
                        return compiler.assignStatement(targetField, sourceField);
                    }
                    assigns ~= copyInto;
                }
                if (!anySpecialAssignments) return null;
                return compiler.sequenceStatement(assigns);
            }
            return context.compiler.stmtWithTemporaryExpr(source, &do2);
        }
        return context.compiler.stmtWithTemporaryExpr(compiler.reference(target), &do1);
    }

    override nullable Statement copyInto(Context context, Reference target, Expression source)
    {
        FunctionDeclaration copyCtor = getCopyCtor;
        if (copyCtor) {
            Expression targetPtr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(target));
            auto call = new Call(copyCtor, [targetPtr, source], this.loc);
            return new ExprStatement(call);
        }
        auto copyStmt = copyRecursive(context, target, source);
        if (copyStmt)
            return copyStmt;
        return null;
    }

    override nullable Statement endLifetime(Context context, Reference ref_)
    {
        Expression ptr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(ref_));
        nullable Statement callAutoDtor_ = callAutoDtor(context, ref_);
        if (auto destructor = getDtor) {
            auto callDtor = new ExprStatement(new Call(destructor, [ptr], this.loc));
            return sequence(callDtor, callAutoDtor_);
        }
        return callAutoDtor_;
    }

    override nullable Expression call(Context context, Loc loc, ASTArgument[] args)
    {
        loc.assert2s(args.length == this.members.length, "invalid number of args for struct constructor");

        auto params = [Parameter(
                isThisAssignment=false,
                name=member.name,
                mutable=false,
                type=member.type
            ) for member in this.members];
        validateCall(params, args, "$(this.name).this()", loc);

        auto temp = new PairedTemporary(this, Ownership.gifted);
        mut Statement initialize = new UninitializeTemporaryStatement(temp);
        for (int i <- 0 .. args.length) {
            mut Expression arg = beExpression3(context, args[i].sym.compile(context), loc);
            arg = expectImplicitConvertTo(context, arg, this.members[i].type, loc);

            auto field = new StructMemberReference(temp, i);
            mut auto stmt = context.compiler.move(context, field, arg);
            if (!stmt) stmt = new AssignStatement(field, arg);

            initialize = sequence(initialize, stmt);
        }
        return new StatementExpression(initialize, temp, false);
    }

    override nullable Expression binaryOp(Context context, string op, Expression left, Expression right, Loc loc) {
        if (op == "==" && right.type.same(left.type)) {
            // TODO this is shit, factor expr and temporary shit out into one generic function
            Expression do1(Expression left) {
                Expression do2(Expression right) {
                    nullable Expression do3(Expression left) {
                        nullable Expression do4(Expression right) {
                            return structEqual(context, left, right, loc);
                        }
                        return context.compiler.exprWithTemporaryExpr(right, &do4);
                    }
                    return notNull!Expression(context.compiler.exprWithTemporaryExpr(left, &do3));
                }
                return context.compiler.consume(context, right, &do2);
            }
            return context.compiler.consume(context, left, &do1);
        }
        return null;
    }
}

Expression structEqual(Context context, Expression left, Expression right, Loc loc) {
    auto structType = left.type.instanceOf(Struct);
    mut Expression test = new IntLiteral(1);
    for (int i <- 0 .. structType.members.length) {
        auto leftField = new StructMember(left, i);
        auto rightField = new StructMember(right, i);
        Expression cmp() {
            if (auto eq = leftField.type.binaryOp(context, "==", leftField, rightField, loc))
                return eq;
            return new BinaryOp("==", leftField, rightField, loc);
        }
        test = new BoolAnd(test, cmp);
    }
    return test;
}

class StructMember : Expression
{
    Expression base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = notNull!Struct(this.base.type.instanceOf(Struct));
        this.type = this.structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        return output.fun.field(structType.emit(output.platform), base.emit(output), cast(int) index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMember");
        base.hash(hash);
        hash.addl(index);
    }
}

class StructMemberReference : Reference
{
    Reference base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = notNull!Struct(this.base.type.instanceOf(Struct));
        this.type = this.structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type.emit(output.platform), reg, this.index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMemberReference");
        base.hash(hash);
        hash.addl(index);
    }
}

struct ASTStructMethod
{
    Loc loc;

    bool static_;

    Protection protection;

    string name;

    ASTSymbol ret;

    (ASTParameter | ASTThisAssignment)[] params;

    ASTStatement body_;
}

ASTSymbol quoteStructEntry(ASTStructEntry entry, Quoter quoter) {
    entry.case {
        ASTStructMember member: return member.quoteStructMember(quoter);
        ASTStructMethod method: return method.quoteStructMethod(quoter);
        ASTStructVersionBlock blk: return blk.quoteVersionBlock(quoter);
    }
}

ASTSymbol quoteStructMember(ASTStructMember member, Quoter quoter) {
    with (quoter.compiler) {
        return astTupleLiteral([
            astStringLiteral(member.name, __HERE__),
            member.protection.quoteProtection(quoter),
            member.type.quote(quoter)], __HERE__);
    }
}

// FIXME There has to be a better way than this.
// TODO get homoiconicity somehow
ASTSymbol quoteStructMethod(ASTStructMethod method, Quoter quoter) {
    ASTSymbol transformParameter(ASTParameter param) {
        with (quoter.compiler) {
            return astCall(
                astIdentifier("ASTParameter", __HERE__), [
                    astStringLiteral(param.name, __HERE__),
                    astBoolLiteral(param.mutable, __HERE__),
                    param.type.quote(quoter),
                    quoter.quoteLoc(param.loc)], __HERE__);
        }
    }
    ASTSymbol transformThisAssignment(ASTThisAssignment assignment) {
        with (quoter.compiler) {
            return astCall(
                astIdentifier("ASTThisAssignment", __HERE__), [
                    astStringLiteral(assignment.name, __HERE__)], __HERE__);
        }
    }
    ASTSymbol transformParam(typeof(method.params[0]) param) {
        return param.case(
            ASTParameter a: transformParameter(a),
            ASTThisAssignment a: transformThisAssignment(a));
    }
    ASTSymbol[] params = [transformParam(a) for a in method.params];
    with (quoter.compiler) {
        return astCall(
            astIdentifier("ASTStructMethod", __HERE__), [
                quoter.quoteLoc(method.loc),
                astBoolLiteral(method.static_, __HERE__),
                method.protection.quoteProtection(quoter),
                astStringLiteral(method.name, __HERE__),
                method.ret.quote(quoter),
                astArrayLiteral(params, __HERE__),
                method.body_.quote(quoter)], __HERE__);
    }
}

ASTSymbol quoteVersionBlock(ASTStructVersionBlock block, Quoter quoter) {
    with (quoter.compiler) {
        return astNewExpression(
            astIdentifier("ASTStructVersionBlock", __HERE__), [
                astStringLiteral(block.name, __HERE__),
                astArrayLiteral(
                    [a.quoteStructEntry(quoter) for a in block.then],
                    __HERE__),
                astArrayLiteral(
                    [a.quoteStructEntry(quoter) for a in block.else_],
                    __HERE__)], __HERE__);
    }
}

// TODO factor out into macro?
ASTSymbol quoteProtection(Protection protection, Quoter quoter) {
    with (quoter.compiler) {
        if (protection == Protection.public_) {
            return astMember(astIdentifier("Protection", __HERE__), "public_", __HERE__);
        } else if (protection == Protection.private_) {
            return astMember(astIdentifier("Protection", __HERE__), "private_", __HERE__);
        } else if (protection == Protection.protected_) {
            return astMember(astIdentifier("Protection", __HERE__), "protected_", __HERE__);
        } else {
            assert(false);
        }
    }
}

class StructNamespace : Namespace
{
    Struct struct_;

    this(this.parent, this.struct_) { this.isContextScope = true; }

    override nullable Symbol lookup(string name, Context context, Loc loc, nullable Expression thisPtr)
    {
        // TODO early name check?
        if (auto thisPtr = thisPtr) {
            auto thisPtr = new PointerCast(new Pointer(this.struct_), thisPtr); // This is good code. Good code.
            if (auto result = context.compiler.accessMemberWithLifetime(
                    context, thisPtr, name, loc, true))
                return result;
        } else {
            // static lookup
            if (auto result = context.compiler.accessMemberWithLifetime(
                    context, this.struct_, name, loc, true))
                return result;
        }

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, loc, null);
    }
}

class StructMethod : Function
{
    Protection protection;

    bool static_;

    string mangledName;

    this(this.loc, Struct structType, nullable Namespace namespace, this.static_, this.protection, this.name,
         this.ret, this.params, this.statement, this.macroState)
    {
        // TODO super()
        auto structNamespace = new StructNamespace(namespace, structType);
        if (!this.static_) {
            auto ptr = new Pointer(structType);

            this.hasThisArg = true;
            this.contextType = ptr;
        }
        this.parent = structNamespace;
        // TODO mangle types
        this.mangledName = this.parent.mangle ~ "_" ~ structType.name ~ "_" ~ this.name;
    }

    override string mangle()
    {
        return mangledName;
    }
}

alias ASTStructMember = (string name, Protection protection, ASTSymbol type);

class ASTStructVersionBlock
{
    string name;
    ASTStructEntry[] then, else_;
    this(this.name, this.then, this.else_) { }
}

alias ASTStructEntry = (ASTStructMember | ASTStructMethod | ASTStructVersionBlock);

class ASTStructDecl : ASTDeclaration
{
    string name;

    ASTStructEntry[] entries;

    Loc loc;

    this(this.name, this.entries, this.loc) { }

    override Context compile(Context context)
    {
        auto struct_ = compileToStruct(context);
        auto module_ = findParent!ModuleBase(context.namespace);

        for (auto method <- struct_.methods) {
            module_.track(method);
        }

        return context.withNamespace(new SymbolAlias(context.namespace, this.name, struct_));
    }

    Struct compileToStruct(Context context)
    {
        mut StructMemberDeclaration[] members;
        mut ASTStructMethod[] methods;
        void walk(ASTStructEntry entry) {
            entry.case {
                ASTStructMember member: {
                    members ~= new StructMemberDeclaration(
                        member.name, member.protection, beType(this.loc, member.type.compile(context)));
                }
                ASTStructVersionBlock ver: {
                    if ([any a == ver.name for a in context.platform.versions]) {
                        [walk(entry) for entry in ver.then];
                    } else {
                        [walk(entry) for entry in ver.else_];
                    }
                }
                ASTStructMethod method: {
                    methods ~= method;
                }
            }
        }
        [walk(a) for a in this.entries];

        auto struct_ = new Struct(this.name, members, this.loc, context.namespace.mangle);
        // make S visible in struct S {}
        auto structScope = context.compiler.symbolAlias(context.namespace, struct_.name, struct_);
        auto structContext = context.withNamespace(structScope);

        struct_.methods = new StructMethod[](methods.length);
        mut int k;
        for (int i <- 0 .. methods.length)
        {
            auto method = methods[i];
            auto methodParams = new Parameter[](method.params.length);

            for (int k <- 0 .. method.params.length) {
                method.params[k].case {
                    ASTParameter param:
                        methodParams[k] = Parameter(
                            false, param.name, param.mutable, beType(param.loc, param.type.compile(structContext)));
                    ASTThisAssignment param:
                        assert(false); // TODO this.foo
                }
            }

            struct_.methods[k++] = new StructMethod(
                method.loc,
                struct_,
                context.namespace,
                method.static_,
                method.protection,
                method.name,
                beType(this.loc, method.ret.compile(structContext)),
                methodParams,
                method.body_, context.macroState);
        }
        return struct_;
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol[] entries = [a.quoteStructEntry(quoter) for a in this.entries];
        with (quoter.compiler) {
            ASTSymbol structEntry = astIdentifier("ASTStructEntry", __HERE__);
            return astNewExpression(
                astIdentifier("ASTStructDecl", __HERE__), [
                    astStringLiteral(this.name, __HERE__),
                    astArrayLiteralTypeHint(structEntry, entries, __HERE__),
                    quoter.quoteLoc(this.loc)], __HERE__);
        }
    }

    override string repr() { return name; }
}

// FIXME remove
class ASTStructDecl2 : ASTDeclaration
{
    string name;

    ASTStructEntry[] entries;

    Loc loc;

    this(this.name, this.entries, this.loc) { }

    override Context compile(Context context)
    {
        auto struct_ = compileToStruct(context);
        auto module_ = findParent!ModuleBase(context.namespace);

        for (auto method <- struct_.methods) {
            module_.track(method);
        }

        return context.withNamespace(new SymbolAlias(context.namespace, this.name, struct_));
    }

    Struct compileToStruct(Context context)
    {
        mut StructMemberDeclaration[] members;
        mut ASTStructMethod[] methods;
        void walk(ASTStructEntry entry) {
            entry.case {
                ASTStructMember member: {
                    members ~= new StructMemberDeclaration(
                        member.name, member.protection, beType(this.loc, member.type.compile(context)));
                }
                ASTStructVersionBlock ver: {
                    if ([any a == ver.name for a in context.platform.versions]) {
                        [walk(entry) for entry in ver.then];
                    } else {
                        [walk(entry) for entry in ver.else_];
                    }
                }
                ASTStructMethod method: {
                    methods ~= method;
                }
            }
        }
        [walk(a) for a in this.entries];

        auto struct_ = new Struct(this.name, members, this.loc, context.namespace.mangle);
        // make S visible in struct S {}
        auto structScope = context.compiler.symbolAlias(context.namespace, struct_.name, struct_);
        auto structContext = context.withNamespace(structScope);

        struct_.methods = new StructMethod[](methods.length);
        mut int k;
        for (int i <- 0 .. methods.length)
        {
            auto method = methods[i];
            auto methodParams = new Parameter[](method.params.length);

            for (int k <- 0 .. method.params.length) {
                method.params[k].case {
                    ASTParameter param:
                        methodParams[k] = Parameter(
                            false, param.name, param.mutable, beType(param.loc, param.type.compile(structContext)));
                    ASTThisAssignment param:
                        assert(false); // TODO this.foo
                }
            }

            struct_.methods[k++] = new StructMethod(
                method.loc,
                struct_,
                context.namespace,
                method.static_,
                method.protection,
                method.name,
                beType(this.loc, method.ret.compile(structContext)),
                methodParams,
                method.body_, context.macroState);
        }
        return struct_;
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol[] entries = [a.quoteStructEntry(quoter) for a in this.entries];
        with (quoter.compiler) {
            ASTSymbol structEntry = astIdentifier("ASTStructEntry", __HERE__);
            return astNewExpression(
                astIdentifier("ASTStructDecl", __HERE__), [
                    astStringLiteral(this.name, __HERE__),
                    astArrayLiteralTypeHint(structEntry, entries, __HERE__),
                    quoter.quoteLoc(this.loc)], __HERE__);
        }
    }

    override string repr() { return name; }
}

nullable ASTStructDecl parseStructDecl(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    parser.begin;
    if (parseIdentifier(parser) != "struct") {
        parser.revert;
        return null;
    }
    string name = parseIdentifier(parser);
    assert(!!name.length);
    mut ASTStructEntry[] entries;
    parser.expect("{");
    while (!parser.accept("}")) {
        entries ~= parseStructEntry(parser, lexicalContext);
    }
    parser.commit;
    return new ASTStructDecl(name, entries, loc);
}

ASTStructEntry[] parseStructEntry(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("version")) {
        mut ASTStructEntry[] then, else_;
        parser.expect("(");
        string versionStr = parser.parseIdentifier;
        parser.expect(")");
        if (parser.accept("{")) {
            while (!parser.accept("}")) {
                then ~= parser.parseStructEntry(lexicalContext);
            }
        } else {
            then ~= parser.parseStructEntry(lexicalContext);
        }
        if (parser.accept("else")) {
            if (parser.accept("{")) {
                while (!parser.accept("}")) {
                    else_ ~= parser.parseStructEntry(lexicalContext);
                }
            } else {
                else_ ~= parser.parseStructEntry(lexicalContext);
            }
        }
        // FIXME explicitly type hinted literal
        ASTStructEntry result = new ASTStructVersionBlock(versionStr, then, else_);
        return [result];
    }
    mut ASTStructEntry[] entries;
    mut bool static_ = false;
    mut nullable ASTSymbol memberType;
    mut string memberName;
    mut Protection protection = Protection.public_;
    auto loc = parser.loc;
    while (true) {
        if (parser.accept("static")) {
            static_ = true;
            continue;
        }
        // FIXME only allow one
        // FIXME parseProtection?
        if (acceptIdentifier(parser, "public")) {
            protection = Protection.public_;
            continue;
        }
        if (acceptIdentifier(parser, "private")) {
            protection = Protection.private_;
            continue;
        }
        break;
    }
    if (parser.accept("this"))
    {
        memberType = new ASTBasicType("void", parser.loc);
        memberName = "__ctor";
    }
    else if (parser.accept("~this"))
    {
        memberType = new ASTBasicType("void", parser.loc);
        memberName = "__dtor";
    }
    else
    {
        memberType = lexicalContext.compiler.parseType(parser, lexicalContext);
        if (!memberType) parser.fail("expected member type");
        memberName = parseIdentifier(parser);
        if (!memberName.length) parser.fail("expected member name");
    }
    if (parser.accept("(")) // method
    {
        auto params = parseParamList(parser, lexicalContext);
        parser.assert_(
            memberName != "__dtor" || params.length == 0, "destructor cannot take parameters");
        ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext);
        entries ~= ASTStructMethod(
            parser.loc, static_, protection, memberName, notNull!ASTSymbol(memberType), params, stmt);
    }
    else
    {
        loc.assert2s(!static_, "no static fields");
        void addMember() {
            parser.assert_(memberName != "__ctor", "constructor cannot be member");
            parser.assert_(memberName != "__dtor", "destructor cannot be member");
            entries ~= (memberName, protection, notNull!ASTSymbol(memberType));
        }
        addMember;
        while (!parser.accept(";")) {
            parser.expect(",");
            if (parser.accept(";")) break;
            memberName = parseIdentifier(parser);
            if (!memberName.length) parser.fail("expected member name");
            addMember;
        }
    }
    return entries;
}
