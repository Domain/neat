module neat.statements;

macro import neat.macros.once;

import backend.base;
import helpers;
import neat.base;
import neat.expr;
import neat.hash;
import neat.parser;
import neat.parser_base;

class AssignStatement : Statement
{
    Reference target;

    Expression value;

    this(this.target, this.value) {
        assert(target.type.same(value.type));
    }

    override void emit(Generator output)
    {
        Type valueType = this.value.type;
        int target_reg = this.target.emitLocation(output);
        int value_reg = this.value.emit(output);

        output.fun.store(valueType.emit(output.platform), target_reg, value_reg);
    }

    override void hash(Hash hash) { hash.adds("AssignStatement"); target.hash(hash); value.hash(hash); }
}

class ReturnStatement : Statement
{
    Expression value;

    this(this.value) { }

    override void emit(Generator output)
    {
        int reg = this.value.emit(output);

        output.fun.ret(reg);
        output.fun.setLabel(output.fun.getLabel);
    }

    override void hash(Hash hash) { hash.adds("ReturnStatement"); value.hash(hash); }
}

class IfStatement : Statement
{
    Expression test;

    Statement then;

    nullable Statement else_;

    this(this.test, this.then, this.else_) { }

    override void emit(Generator output)
    {
        int reg = this.test.emit(output);

        string label = output.fun.getLabel;
        if (this.else_)
            output.fun.testBranch(reg, label ~ "_then", label ~ "_else");
        else
            output.fun.testBranch(reg, label ~ "_then", label ~ "_fin");

        output.fun.setLabel(label ~ "_then");
        this.then.emit(output);
        output.fun.branch(label ~ "_fin");

        if (this.else_)
        {
            output.fun.setLabel(label ~ "_else");
            this.else_.emit(output);
            output.fun.branch(label ~ "_fin");
        }
        output.fun.setLabel(label ~ "_fin");
    }

    override void hash(Hash hash) {
        hash.adds("IfStatement");
        test.hash(hash);
        then.hash(hash);
        if (else_) else_.hash(hash);
        else hash.adds("no else");
    }
}

class ASTBreakStatement : ASTStatement
{
    Loc loc;

    this(this.loc) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto loopScope = findParent!LoopScope(context.namespace);
        loc.assert(!!loopScope, "Cannot 'break': not in a loop.")?;
        return StatementCompileResult(loopScope.breakFrom(context)?, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTBreakStatement", loc), [
                quoter.quoteLoc(loc)], loc);
    }
}

class ASTContinueStatement : ASTStatement
{
    Loc loc;

    this(this.loc) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto loopScope = findParent!LoopScope(context.namespace);
        loc.assert(!!loopScope, "Cannot 'continue': not in a loop.")?;
        return StatementCompileResult(loopScope.continueFrom(context)?, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTContinueStatement", loc), [
                quoter.quoteLoc(loc)], loc);
    }
}

class Branch : Statement
{
    string label;

    this(this.label) { }

    override void emit(Generator output)
    {
        output.fun.branch(this.label);
        output.fun.setLabel(output.fun.getLabel);
    }

    override void hash(Hash hash) { hash.adds("Branch"); hash.adds(label); }
}

class ASTExprStatement : ASTStatement
{
    ASTSymbol value;

    Loc loc;

    this(this.value, this.loc) { }

    override (StatementCompileResult | fail Error) compile(Context context)
    {
        auto expr = this.value.compile(context)?.beExpressionImplCall(context, this.loc)?;

        return StatementCompileResult(discard(context, expr, this.loc)?, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astExpressionStmt", [value.quote(quoter)], loc);
    }
}

// see ExprInfo info in Expression
// this is a "move" not in the sense that the source gets destroyed,
// as that it steals the reference belonging to the source. Essentially,
// it takes ownership of the source expression.
(Statement | fail Error) move(Context context, Reference target, Expression source)
{
    if (source.info.ownership == Ownership.gifted) {
        // steal the reference
        return new AssignStatement(target, source);
    }
    auto type = target.type;
    if (auto copyIntoStmt = type.copyInto(context, target, source)?)
        return copyIntoStmt;
    return new AssignStatement(target, source);
}

class ExprStatement : Statement
{
    Expression value;

    this(this.value) { assert(!!value); }

    override void emit(Generator output)
    {
        this.value.emit(output);
    }

    override void hash(Hash hash) { hash.adds("ExprStatement"); value.hash(hash); }
}

Statement destroy(Context context, Expression expr)
{
    auto type = expr.type;
    if (auto reference = expr.instanceOf(Reference)) {
        if (auto endLifetime = type.endLifetime(context, reference)) {
            return endLifetime;
        }
        return new NoopStatement;
    }
    // TODO hasDestructor?
    Reference temp = new Temporary(new NullExpr(type));
    // call destructor on result
    if (auto stmt = type.endLifetime(context, temp))
        return sequence(new AssignStatement(temp, expr), stmt);
    return new ExprStatement(expr);
}

(Statement | fail Error) discard(Context context, Expression expr, Loc loc)
{
    auto type = expr.type;
    context.compiler.discardErrorCheck(expr, loc)?;
    if (expr.info.ownership == Ownership.gifted && !type.same(once new Void)) {
        return destroy(context, expr);
    } else {
        return new ExprStatement(expr);
    }
}

/**
 * Generic loop class, covering For and While.
 *
 *  setup // may be null for while loop
 * start:
 *  if (!condition) goto break
 *  body
 * continue:
 *  loopstep // may be null for while loop
 *  goto start
 * break:
 */
class Loop : Statement
{
    string label;

    nullable Statement setup;

    Expression condition;

    Statement body_;

    nullable Statement loopstep;

    this(this.label, this.setup, this.condition, this.body_, this.loopstep) { }

    override void emit(Generator output)
    {
        if (this.setup) this.setup.emit(output);

        output.fun.branch(label ~ "_start");

        output.fun.setLabel(label ~ "_start"); // start:
        int condReg = this.condition.emit(output);
        output.fun.testBranch(condReg, label ~ "_body", label ~ "_break");

        output.fun.setLabel(label ~ "_body");
        this.body_.emit(output);
        output.fun.branch(label ~ "_continue");
        output.fun.setLabel(label ~ "_continue");
        if (this.loopstep) this.loopstep.emit(output);
        output.fun.branch(label ~ "_start");
        output.fun.setLabel(label ~ "_break");
    }

    override void hash(Hash hash) {
        hash.adds("LoopStatement");
        hash.adds(label);
        if (setup) setup.hash(hash);
        else hash.adds("no setup");
        condition.hash(hash);
        body_.hash(hash);
        if (loopstep) loopstep.hash(hash);
        else hash.adds("no loopstep");
    }
}

class LabelLoopScope : LoopScope
{
    string label;
    this(this.label, this.parent) { this.isContextScope = true; }
    override (Statement | fail Error) breakFrom(Context context) {
        auto branch = new Branch(this.label ~ "_break");

        return sequence2(context.compiler.unwindScope(context, this, new NoopStatement)?, branch);
    }
    override (Statement | fail Error) continueFrom(Context context) {
        auto branch = new Branch(this.label ~ "_continue");

        return sequence2(context.compiler.unwindScope(context, this, new NoopStatement)?, branch);
    }
}

class SequenceStatement : Statement
{
    Statement[] statements;

    this(this.statements) { }

    override void emit(Generator output)
    {
        for (statement in this.statements) {
            statement.emit(output);
        }
    }

    override void hash(Hash hash)
    {
        hash.adds("SequenceStatement");
        hash.addl(statements.length);
        for (statement in statements)
            statement.hash(hash);
    }
}

Statement sequence(Statement left, nullable Statement right)
{
    if (!right) return left;
    auto rightNonNull = right.notNull;
    if (left.instanceOf(NoopStatement)) return rightNonNull;
    if (rightNonNull.instanceOf(NoopStatement)) return left;
    auto prevSequence = left.instanceOf(SequenceStatement);
    if (prevSequence) return new SequenceStatement(prevSequence.statements ~ rightNonNull);
    return new SequenceStatement([left, rightNonNull]);
}

Statement sequence2(nullable Statement first, Statement second) {
    if (auto first = first) return sequence(first, second);
    return second;
}

class StatementExpression : Expression
{
    Statement statement;

    Expression expression;

    bool gifted;

    this(this.statement, this.expression, this.gifted) {
        assert(!!statement);
        assert(!!expression);
        this.type = this.expression.type;
        if (gifted) this.info = ExprInfo(false, Ownership.gifted);
        else this.info = expression.info;
    }

    override int emit(Generator generator)
    {
        this.statement.emit(generator);
        return this.expression.emit(generator);
    }

    override void hash(Hash hash) {
        hash.adds("StatementExpression");
        statement.hash(hash);
        expression.hash(hash);
    }
}
