module neat.class_;

macro import neat.macros.listcomprehension;
macro import neat.macros.once;
macro import neat.macros.quasiquoting;

import backend.base;
import helpers;
import neat.array;
import neat.base;
import neat.expr;
import neat.hash;
import neat.parser;
import neat.parser_base;
import neat.function_;
import neat.struct_;
import neat.types;

class ClassMethod : Function
{
    Protection protection;

    bool override_;

    bool abstract_;

    this(ClassType classType, this.loc, this.protection, this.override_, this.abstract_, this.name,
         this.ret, this.params, this.statement, this.macroState, this.parent)
    {
        this.hasThisArg = true;
        this.contextType = classType;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.parent.mangle ~ "_" ~ this.contextType.instanceOf(ClassType).class_.name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto params = [Parameter.fromType(this.contextType)] ~ this.params;
        return new FunctionPointer(this.ret, params);
    }
}

class IntfMethod : FunctionDeclaration
{
    this(IntfType intfType, this.name, this.ret, this.params)
    {
        this.contextType = intfType;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.contextType.instanceOf(IntfType).intf.name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto params = [Parameter.fromType(this.contextType)] ~ this.params;
        return new FunctionPointer(this.ret, params);
    }
}

class ClassNamespace : Namespace
{
    ClassType class_;

    this(this.parent, this.class_) { this.isContextScope = true; }

    override Symbol lookup(string name, Context context, Loc loc, Expression thisPtr)
    {
        if (thisPtr) {
            auto thisPtr = new PointerCast(this.class_, thisPtr);

            if (auto result = context.compiler.accessMemberWithLifetime(
                    context, thisPtr, name, loc, true))
                return result;
        }

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, loc, null);
    }
}

/**
 * Class layout:
 * - super class data OR
 *   - vtable ptr
 *   - reference count
 * - class data
 * - interface pointers
 *
 * Note: Class is *not* a type, because compiling it involves some funky magic that requires
 * mutating class state and is awkward,
 * so we cannot also dup it for "nullable Class" because then we wouldn't be able to handle these changes.
 * So this is what goes on: Class is wrapped by ClassType, which is what "ClassName" resolves to.
 * Class declarations reference Class. ClassType has nullability.
 */
class Class
{
    string name;

    bool final_; // methods may not be overridden

    bool abstract_; // may contain abstract methods

    Class superClass;

    Intf[] superIntfs;

    // will resolve members and methods as required
    ASTClassDecl decl;

    Namespace namespace;

    (string name, Protection protection, Type type)[] members;

    ClassMethod[] methods;

    (ClassMethod | (:baseOffset, size_t offs))[] vtable; // methods appearing in the classinfo struct

    string vtableSymbol;

    string mangledName;

    Hash cachedHash;

    /**
     * dataStruct takes the form:
     * {
     *   {super data}
     *   {my own data}
     *   {interface slots}
     * }
     */
    Struct dataStruct;

    this(this.decl, this.superClass, this.superIntfs, this.namespace)
    {
        if (superClass && superClass.final_)
            decl.loc.fail("cannot subclass a final class");
        assert(!!decl);
        this.name = decl.name;
        this.final_ = decl.final_;
        this.abstract_ = decl.abstract_;
        this.mangledName = namespace.mangle ~ "_class_" ~ this.name;
        // TODO this is *wildly* insufficient!
        this.cachedHash = new Hash;
        this.cachedHash.adds("Class " ~ this.mangledName);
        this.cachedHash.addl(this.members.length);
        for (auto member <- this.members) {
            this.cachedHash.adds(member.name);
            this.cachedHash.addl(cast(int) member.protection);
            member.type.hash(this.cachedHash);
        }
        if (this.superClass)
            this.cachedHash.applyHash(this.superClass.cachedHash);
    }

    void resolve(Context context)
    {
        // TODO compilation stage enum
        if (this.vtableSymbol != "") return;
        this.decl.compile2(context, this);
    }

    void initDataStruct(Context context)
    {
        mut StructMemberDeclaration[] structMembers;
        if (this.superClass) {
            this.superClass.initDataStruct(context);
            structMembers ~= new StructMemberDeclaration(
                "super", Protection.public_, this.superClass.dataStruct);
        } else {
            structMembers ~= new StructMemberDeclaration(
                "super", Protection.public_, new Struct("nothing", [], this.decl.loc, this.mangledName));
        }

        StructMemberDeclaration[] dataMembers() {
            StructMemberDeclaration toMember(typeof(this.members[0]) entry) {
                return new StructMemberDeclaration(entry.name, entry.protection, entry.type);
            }
            if (!this.superClass) {
                return [
                    new StructMemberDeclaration("__classinfo", Protection.private_, once new Pointer(new Void)),
                    new StructMemberDeclaration("__refs", Protection.private_, context.nativeWordType),
                ] ~ [a.toMember for a in this.members];
            }
            return [a.toMember for a in this.members];
        }
        structMembers ~= new StructMemberDeclaration(
            "data", Protection.public_, new Struct("data", dataMembers, this.decl.loc, this.mangledName));

        StructMemberDeclaration[] intfSlots() {
            int slots = [sum i.slots for i in this.superIntfs];
            mut StructMemberDeclaration[] ret;
            for (int i <- 0 .. slots)
                ret ~= new StructMemberDeclaration(
                    "__$(name)_islot$i", Protection.public_, once new Pointer(new Void));
            return ret;
        }
        structMembers ~= new StructMemberDeclaration(
            "islots", Protection.public_, new Struct("islots", intfSlots, this.decl.loc, this.mangledName));

        this.dataStruct = new Struct("", structMembers, this.decl.loc, this.mangledName);
    }

    Struct classInfoStructCache;

    Struct classInfoStruct(Context context)
    {
        if (classInfoStructCache) {
            assert(classInfoStructCache.members.length == vtable.length);
            return classInfoStructCache;
        }

        StructMemberDeclaration transform(typeof(vtable[0]) entry) {
            auto sizeT = context.nativeWordType;
            return entry.case(
                ClassMethod method: new StructMemberDeclaration(method.name, Protection.public_, method.funcPtrType),
                (:baseOffset, size_t offs): new StructMemberDeclaration("", Protection.public_, sizeT));
        }

        auto vtableMembers = [transform(entry) for entry in vtable];
        classInfoStructCache = new Struct("", vtableMembers, this.decl.loc, this.mangledName);
        return classInfoStructCache;
    }

    // FIXME: roll into vtable(), this.vtable => this.vtableCache
    void genVtable(Context context)
    {
        if (this.vtableSymbol != "") return;

        assert(this.vtable.length == 0);

        // Ensure these two are added first.
        this.methods = [
            this.genInstanceofMethod(context),
            this.genReleaseMethod(context)] ~ this.methods;

        mut (ClassMethod | IntfMethod | (:baseOffset, size_t offs))[] vtable;
        if (this.superClass) {
            this.superClass.genVtable(context);
            for (auto a <- this.superClass.vtable)
                vtable ~= a;
            vtable[0] = this.methods[0];
            vtable[1] = this.methods[1];
        } else {
            vtable ~= this.methods[0];
            vtable ~= this.methods[1];
        }
        int wordSize = context.nativeWordType.emit(context.platform).size(context.platform);
        // offset of intf slots in this class
        mut size_t baseOffset = this.dataStruct.emit(context.platform).memberOffset(2, context.platform);
        for (auto intf <- this.superIntfs) {
            intf.genVtable;
            for (auto entry <- intf.vtable) {
                entry.case {
                    IntfMethod method: vtable ~= method;
                    (:baseOffset): { // one per slot
                        vtable ~= (:baseOffset, baseOffset);
                        baseOffset += wordSize;
                    }
                }
            }
        }

        for (ClassMethod method <- this.methods) {
            // TODO match types
            bool isCtor = method.name == "__ctor"; // workaround: no final yet, no proper masking yet
            bool sameName(typeof(vtable[0]) entry) {
                return entry.case(
                    ClassMethod classMethod: classMethod.name == method.name,
                    IntfMethod intfMethod: intfMethod.name == method.name,
                    (:baseOffset, size_t offs): false);
            }
            /*
            string repr(typeof(vtable[0]) entry) {
                return entry.case(
                    ClassMethod classMethod: "ClassMethod($(classMethod.name))",
                    IntfMethod intfMethod: "IntfMethod($(intfMethod.name))",
                    (:baseOffset, size_t offs): "baseOffset($offs)");
            }
            print("$(this.name): debug: vtable = " ~ [join ", " e.repr for e in vtable]);
            */
            size_t index = [first i for i, a in vtable where a.sameName else -1];
            if (index != -1)
            {
                method.loc.assert2s(method.override_ || isCtor,
                    "Expected 'override' attribute for overriding method.");
                if (!isCtor) { // ctor is always called static
                    // override
                    vtable[index].case {
                        ClassMethod classMethod: validateOverride(classMethod, method);
                        IntfMethod intfMethod: validateOverride(intfMethod, method);
                        (:baseOffset, size_t offs): {}
                    }
                }
                // print("a: $(this.name): vtable[$index] = $(method.name)");
                vtable[index] = method;
            }
            else
            {
                method.loc.assert2s(!method.override_,
                    "'override' specified but method does not override a parent method.");
                // print("b: $(this.name): vtable[$(vtable.length)] = $(method.name)");
                vtable ~= method;
            }
        }
        if (!this.abstract_)
        {
            for (auto method <- vtable) {
                method.case {
                    ClassMethod method: {
                        if (method.abstract_)
                            this.decl.loc.fail(
                                "Abstract method '$(method.name)' not overridden in non-abstract class $(this.name)");
                    }
                    IntfMethod method: {
                        this.decl.loc.fail(
                            "Interface method '$(method.name)' not overridden in non-abstract class $(this.name)");
                    }
                    (:baseOffset, size_t offs): { }
                }
            }
        }
        (ClassMethod | (:baseOffset, size_t)) filter(typeof(vtable[0]) entry) {
            entry.case {
                ClassMethod m: return m;
                IntfMethod m: assert(false);
                (:baseOffset, size_t) pair: return pair;
            }
        }
        this.vtable = [filter(a) for a in vtable];
        this.vtableSymbol = this.mangledName ~ "_vtable";
    }

    void validateOverride(FunctionDeclaration parent, ClassMethod child)
    {
        child.loc.assert2s4(parent.params.length == child.params.length,
            "Override expected ", ltoa(parent.params.length), " arguments, not ", ltoa(child.params.length));
        // return type is covariant
        child.loc.assert2s4(child.ret.isStrictSubtypeOf(parent.ret),
            "child return type must be strict subtype of parent return type: ",
            child.ret.repr, " and ", parent.ret.repr);
        for (int i <- 0 .. parent.params.length)
        {
            auto parentParam = parent.params[i];
            auto childParam = child.params[i];
            child.loc.assert2s(parentParam.mutable == childParam.mutable,
                "parameter mutability must match between base method and override");
            // parameters are contravariant
            child.loc.assert2s4(parentParam.type.isStrictSubtypeOf(childParam.type),
                "child argument type must be strict supertype of parent argument type: ",
                childParam.type.repr, " and ", parentParam.type.repr);
        }
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(vtableSymbol))
            return;

        generator.mod.declareSymbolList(vtableSymbol, vtable.length);
    }

    void define(Generator generator)
    {
        (string | size_t) transform(typeof(vtable[0]) entry) {
            entry.case {
                ClassMethod method: {
                    method.declare(generator);
                    return method.mangle;
                }
                (:baseOffset, size_t offset): return offset;
            }
        }
        auto backendVtable = [transform(entry) for entry in vtable];

        generator.mod.defineSymbolList(vtableSymbol, backendVtable);
    }

    ClassMethod genInstanceofMethod(Context context)
    {
        mut ASTStatement[] castStmts;
        mut Class current = this;
        while (current)
        {
            auto classType = new ClassType(current, zeroInitializable=false);
            auto classinfo = new ASTSymbolHelper(new ClassInfo(classType));
            castStmts ~= context.compiler.$stmt if (targetClassinfo is $classinfo) {
                // take a bonus reference because the return type isn't right
                (cast(size_t*) this)[1] += 1;
                return this;
            };
            // TODO allow recursion in nested fn
            mut void delegate(Intf) recurse;
            void recurse_(Intf intf) {
                auto intfType = new IntfType(intf, zeroInitializable=false);
                auto astIntf = new ASTSymbolHelper(intfType);
                auto intfClassinfo = new ASTSymbolHelper(new ClassInfo(intfType));
                castStmts ~= context.compiler.$stmt if (targetClassinfo is $intfClassinfo) {
                    // take a bonus reference because the return type isn't right
                    (cast(size_t*) this)[1] += 1;
                    // implconv to interface
                    $astIntf intf = this;
                    return intf;
                };
                for (auto superIntf <- intf.superIntfs) {
                    recurse(superIntf);
                }
            }
            recurse = &recurse_;
            for (auto superIntf <- current.superIntfs) {
                recurse(superIntf);
            }
            current = current.superClass;
        }
        castStmts ~= context.compiler.$stmt return null;;
        auto stmt = context.compiler.astSequence(castStmts, __HERE__);

        auto classType = new ClassType(this, zeroInitializable=false);
        auto methodNamespace = new ClassNamespace(this.namespace, classType);
        return new ClassMethod(
            classType, __HERE__, Protection.public_, override_=true, abstract_=false, "__instanceof",
            once new Pointer(new Void), [Parameter(false, "targetClassinfo", false, once new Pointer(new Void))],
            stmt, new MacroState, methodNamespace);
    }

    ClassMethod genReleaseMethod(Context context)
    {
        mut ASTStatement[] statements;
        // FIXME self-recursion in nested function
        mut void delegate(Class) recurse;
        void recurse_(Class self) {
            if (self.superClass) recurse(self.superClass);
            for (auto member <- self.members) {
                auto name = context.compiler.astIdentifier(member.name, __HERE__);
                statements ~= context.compiler.$stmt __destroy($name);;
            }
        }
        recurse = &recurse_;
        recurse(this);
        auto stmt = context.compiler.astSequence(statements, __HERE__);

        auto classType = new ClassType(this, zeroInitializable=false);
        auto methodNamespace = new ClassNamespace(this.namespace, classType);
        return new ClassMethod(
            classType, __HERE__, Protection.public_, override_=true, abstract_=false, "__destroy",
            once new Void, [], stmt, new MacroState, methodNamespace);
    }
}

class ClassType : Type
{
    Class class_;

    this(this.class_, this.zeroInitializable) { }

    ClassType makeNullable() {
        if (this.zeroInitializable) return this;
        return new ClassType(this.class_, zeroInitializable=true);
    }

    ClassType makeNotNullable() {
        if (!this.zeroInitializable) return this;
        return new ClassType(this.class_, zeroInitializable=false);
    }

    ClassType superClass() {
        if (!this.class_.superClass) return null;
        return new ClassType(this.class_.superClass, zeroInitializable=false);
    }

    IntfType[] superIntfs() {
        return [new IntfType(a, zeroInitializable=false) for a in this.class_.superIntfs];
    }

    override Expression implicitConvertFrom(Expression from)
    {
        // upcast
        if (from.type.instanceOf(ClassType))
        {
            mut ClassType currentClass = from.type.instanceOf(ClassType);

            while (currentClass)
            {
                // Class implconv to nullable Class
                if (currentClass.same(this) || currentClass.makeNullable.same(this))
                {
                    return new PointerCast(this, from);
                }
                currentClass = currentClass.superClass;
            }
        }
        // = null
        if (from.instanceOf(NullExpr))
        {
            return new PointerCast(this, from);
        }
        return null;
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    override string mangle() {
        if (this.zeroInitializable)
            return "nullable_" ~ this.class_.mangledName;
        return this.class_.mangledName;
    }

    override Expression truthy(Context context, Expression value, Loc loc)
    {
        Expression do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy(context, new PointerCast(voidp, value), loc);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override Protection protectionAt(Namespace namespace)
    {
        auto provenance = findParent!ClassNamespace(namespace);
        if (provenance && same(provenance.class_)) return Protection.private_;
        // TODO implement protected
        return Protection.public_;
    }

    override Symbol accessMember(Loc loc, Context context, Expression baseExpr, string member, Protection protection)
    {
        bool allowed(Protection symbol) {
            int rank(Protection p) {
                if (p == Protection.public_) return 0;
                if (p == Protection.protected_) return 1;
                return 2;
            }
            return rank(symbol) <= rank(protection);
        }
        bool test(typeof(this.class_.vtable[0]) entry) {
            return entry.case(
                ClassMethod m: m.name == member && allowed(m.protection),
                (:baseOffset, size_t offs): false);
        }
        size_t methodOffset = [first i for i, a in this.class_.vtable where test(a) else -1];
        if (methodOffset != -1)
        {
            return new ClassMethodSymbol(this.class_, baseExpr, methodOffset, staticLookup=false);
        }

        if (!baseExpr) return null;

        // FIXME self-recursion in nested function
        mut Symbol delegate(Class) recurse;
        Symbol recurse_(Class self) {
            size_t memberOffset = [first i for i, m in self.members where m.name == member && allowed(m.protection) else -1];
            if (memberOffset != -1) {
                Reference asStruct = context.compiler.dereference(
                    new PointerCast(new Pointer(self.dataStruct), baseExpr));
                // select "data" substruct
                auto dataMember = new StructMemberReference(asStruct, 1);
                // select member field
                if (self.superClass)
                    return new StructMemberReference(dataMember, memberOffset);
                // skip classinfo and refs
                return new StructMemberReference(dataMember, memberOffset + 2);
            }
            if (self.superClass) {
                return recurse(self.superClass);
            }
            return null;
        }
        recurse = &recurse_;
        return recurse(this.class_);
    }

    override Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);

        // disabled cause cast() now tries to implcast first
        // and we need `cast(void*) obj` (leaking!) for `once` macro.
        // we still need proper errors
        // TODO maybe a dedi keyword for leaking a reference to C?
        /*if (to.same(voidp) && from.info.ownership == Ownership.gifted)
        {
            print("cannot convert temporary expression to void* - where would the reference go?");
            // TODO return (Expression | Error)
            assert(false);
        }*/
        if (to.same(voidp) && from.info.ownership != Ownership.gifted)
        {
            return new PointerCast(voidp, from);
        }
        return null;
    }

    override bool same(Type other) {

        if (ClassType otherClass = other.instanceOf(ClassType)) {
            // TODO module
            return otherClass.class_.name == this.class_.name
                && this.zeroInitializable == otherClass.zeroInitializable;
        }
        return false;
    }

    override string repr() {
        if (this.zeroInitializable) return "nullable $(this.class_.name)";
        return this.class_.name;
    }

    override void hash(Hash hash) {
        hash.applyHash(this.class_.cachedHash);
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        mut Context context = context;
        Statement do_(Expression source) {
            auto sizeT = context.nativeWordType;
            auto refCountIncFun = once new FunctionDeclaration(
                "neat_runtime_refcount_inc", new Void, [
                    Parameter(false, "label", false, new Array(new Character)),
                    Parameter(false, "ptr", false, new Pointer(new Void))]);

            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "this", new IgnoreLifetimeExpr(source)));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_refcount_inc", refCountIncFun));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "inc_name", new StringLiteral("inc " ~ this.class_.name)));

            auto incref = context.compiler.$stmt
            if (!!this) {
                neat_runtime_refcount_inc(inc_name, &(cast(size_t*) this)[1]);
            };
            auto assign = context.compiler.assignStatement(target, source);
            return context.compiler.sequence(incref.compile(context).statement, assign);
        }
        return context.compiler.stmtWithTemporaryExpr(source, &do_);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        mut Context context = context;
        // disable lifetime management
        // (otherwise we get an infinite cycle when the compiler
        // tries to clean up 'this' after the __destroy() call by
        // ending its lifetime (ad infinitum).
        auto tempThis = new PairedTemporary(reference.type, Ownership.owned);
        auto initTemp = new InitializeTemporaryStatement(tempThis, reference);

        auto sizeT = context.nativeWordType;
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "this", tempThis));
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "size_t", sizeT));

        // TODO do in __destroy() once we have function imports
        auto freeFun = once new FunctionDeclaration(
            "free", new Void, [Parameter(false, "ptr", false, new Pointer(new Void))]);
        auto refCountDecFun = once new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                Parameter(false, "label", false, new Array(new Character)),
                Parameter(false, "ptr", false, new Pointer(new Void))]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "free", freeFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "neat_runtime_refcount_dec", refCountDecFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "dec_name", new StringLiteral("dec " ~ this.class_.name)));
        auto stmt = context.compiler.$stmt
            if (!!this) {
                if (neat_runtime_refcount_dec(dec_name, &(cast(size_t*) this)[1]))
                {
                    this.__destroy;
                    free(this);
                }
            };
        return context.compiler.sequence(initTemp, stmt.compile(context).statement);
    }
}

/**
 * Interface layout:
 * - vtable pointer
 * Vtable layout:
 * - EITHER OF
 *   - class base offset
 *   - primary super interface layout
 * - secondary super interface layouts
 * - own methods
 */
class Intf
{
    string name;

    Intf[] superIntfs;

    // FIXME do we need this?
    ASTIntfDecl decl;

    Namespace namespace;

    IntfMethod[] methods; // methods declared in this intf

    (IntfMethod | :baseOffset)[] vtable; // layout of the classinfo subsection generated for this intf

    // TODO eventually string name will go in here for .classinfo.name
    string classInfoSymbol;

    string mangledName;

    PolyHashState mangledHash;

    this(this.decl, this.superIntfs, this.namespace)
    {
        assert(!!decl);
        this.name = decl.name;
        this.mangledName = namespace.mangle ~ "_intf_" ~ this.name;
        auto state = poly_hash_string("Intf" ~ this.mangledName);
        this.mangledHash = PolyHashState(state.add, state.mult);
    }

    public int slots() {
        // FIXME self-recursion in nested function
        mut int delegate(Intf) recurse;
        int recurse_(Intf current) {
            if (current.superIntfs.length == 0) return 1;
            return [sum recurse(i) for i in current.superIntfs];
        }
        recurse = &recurse_;
        return recurse(this);
    }

    void resolve(Context context)
    {
        // TODO compilation stage enum
        if (this.classInfoSymbol != "") return;
        this.decl.compile2(context, this);
    }

    Struct intfVtableStructCache;

    Struct intfVtableStruct(Context context)
    {
        assert(this.classInfoSymbol != "");

        if (intfVtableStructCache) {
            assert(intfVtableStructCache.members.length == vtable.length);
            return intfVtableStructCache;
        }

        auto sizeT = context.nativeWordType;
        StructMemberDeclaration transform(typeof(vtable[0]) entry) {
            return entry.case(
                IntfMethod m: new StructMemberDeclaration(m.name, Protection.public_, m.funcPtrType),
                (:baseOffset): new StructMemberDeclaration("basePtr", Protection.public_, sizeT));
        }
        auto vtableMembers = [transform(method) for method in vtable];

        intfVtableStructCache = new Struct("", vtableMembers, this.decl.loc, this.mangledName);
        return intfVtableStructCache;
    }

    // FIXME: roll into vtable(), this.vtable => this.vtableCache
    void genVtable()
    {
        if (this.classInfoSymbol != "") return;

        assert(this.vtable.length == 0);

        if (this.superIntfs.length == 0) {
            this.vtable ~= :baseOffset;
        } else {
            for (auto superIntf <- this.superIntfs) {
                superIntf.genVtable;
                this.vtable ~= [a for a in superIntf.vtable]; // dup
            }
        }
        for (auto method <- this.methods)
            this.vtable ~= method;
        /*
        string repr(typeof(vtable[0]) entry) {
            return entry.case(
                IntfMethod intfMethod: "IntfMethod($(intfMethod.name))",
                (:baseOffset): "baseOffset()");
        }
        print("$(this.name): debug: vtable = " ~ [join ", " e.repr for e in vtable]);
        */
        this.classInfoSymbol = this.mangledName ~ "_classinfo";
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(classInfoSymbol))
            return;

        generator.mod.declareSymbolList(classInfoSymbol, 0);
    }

    void define(Generator generator)
    {
        // placeholder to ensure a symbol with a unique id is emitted
        mut (string | size_t)[] classinfo;
        classinfo ~= cast(size_t) this;

        generator.mod.defineSymbolList(classInfoSymbol, classinfo);
    }
}

/**
 * Like ClassType, IntfType is split off from Intf to allow setting nullable with makeNullable.
 * This is not necessary, as opposed to ClassType, IntfType does not need any mutable state.
 * But it's easier to understand and remember if they're consistent.
 */
class IntfType : Type
{
    Intf intf;

    this(this.intf, this.zeroInitializable) { }

    override string mangle() {
        if (this.zeroInitializable)
            return "nullable_" ~ this.intf.mangledName;
        return this.intf.mangledName;
    }

    IntfType[] superIntfs() {
        return [new IntfType(a, zeroInitializable=false) for a in this.intf.superIntfs];
    }

    IntfType makeNullable() {
        if (this.zeroInitializable) return this;
        return new IntfType(this.intf, zeroInitializable=true);
    }

    IntfType makeNotNullable() {
        if (!this.zeroInitializable) return this;
        return new IntfType(this.intf, zeroInitializable=false);
    }

    // get slot pointer of target in our hierarchy
    // if not found, return the number of bases traversed
    private (Expression | int) getSlot(IntfType target, Expression islotTablePtr, mut int base) {
        // FIXME self-recursion in nested function
        mut int delegate(IntfType) recurse;
        int recurse_(IntfType current) {
            // implconv intf to nullable intf
            if (current.same(target) || current.makeNullable.same(target)) return base;
            if (current.superIntfs.length == 0) {
                base += 1;
                return -1;
            }
            for (auto superIntf <- current.superIntfs) {
                int ret = superIntf.recurse;
                if (ret != -1) return ret;
            }
            return -1;
        }
        recurse = &recurse_;
        int slot = recurse(this);
        if (slot != -1) {
            auto basePtr = new PointerCast(once new Pointer(new Pointer(new Void)), islotTablePtr);
            return new PointerCast(target, new PointerOffset(basePtr, new IntLiteral(slot)));
        }
        return base;
    }

    override Expression truthy(Context context, Expression value, Loc loc)
    {
        Expression do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy(context, new PointerCast(voidp, value), loc);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override Symbol accessMember(Loc loc, Context context, Expression baseExpr, string member, Protection _)
    {
        bool nameMatches(typeof(this.intf.vtable[0]) entry) {
            return entry.case(
                IntfMethod m: m.name == member,
                (:baseOffset): false);
        }
        size_t methodOffset = [first i for i, a in this.intf.vtable where nameMatches(a) else -1];
        if (methodOffset != -1)
        {
            return new IntfMethodSymbol(this, baseExpr, methodOffset);
        }
        return null;
    }

    override Expression implicitConvertFrom(Expression from)
    {
        // upcast
        if (from.type.instanceOf(ClassType)) {
            mut ClassType currentClass = from.type.instanceOf(ClassType);
            while (currentClass) {
                auto asStructRef = new Dereference(new PointerCast(
                    new Pointer(currentClass.class_.dataStruct), from));
                auto islotTablePtr = new ReferenceExpression(new StructMemberReference(asStructRef, 2));

                // Count up slot base over all interfaces.
                mut int base = 0;
                for (auto intfType <- currentClass.superIntfs) {
                    intfType.getSlot(this, islotTablePtr, base).case {
                        Expression expr: return expr;
                        int newBase: base = newBase;
                    }
                }
                currentClass = currentClass.superClass;
            }
            return null;
        }
        if (auto intfType = from.type.instanceOf(IntfType)) {
            intfType.getSlot(this, from, 0).case {
                Expression expr: return expr;
                int newBase: { }
            }
        }
        // = null
        if (from.instanceOf(NullExpr))
        {
            return new PointerCast(this, from);
        }
        return null;
    }

    override Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);
        if (to.same(voidp) && from.info.ownership != Ownership.gifted)
        {
            return new PointerCast(voidp, from);
        }
        return null;
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    override bool same(Type other) {
        if (IntfType otherIntf = other.instanceOf(IntfType)) {
            // TODO module
            return otherIntf.intf.name == this.intf.name
                && otherIntf.zeroInitializable == this.zeroInitializable;
        }
        return false;
    }

    override string repr() {
        if (this.zeroInitializable) return "nullable $(this.intf.name)";
        return this.intf.name;
    }

    override void hash(Hash hash) {
        hash.apply(intf.mangledHash.add, intf.mangledHash.mult);
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        mut Context context = context;
        Statement do_(Expression source) {
            auto sizeT = context.nativeWordType;
            auto refCountIncFun = once new FunctionDeclaration(
                "neat_runtime_refcount_inc", new Void, [
                    Parameter(false, "label", false, new Array(new Character)),
                    Parameter(false, "ptr", false, new Pointer(new Void))]);

            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "this", new IgnoreLifetimeExpr(source)));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "neat_runtime_refcount_inc", refCountIncFun));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "inc_name", new StringLiteral("inc " ~ this.intf.name)));

            auto incref = context.compiler.$stmt
            if (!!this) {
                auto baseOffset = **cast(size_t**) this;
                auto object = &(cast(char*) this)[-baseOffset];
                neat_runtime_refcount_inc(inc_name, &(cast(size_t*) object)[1]);
            };
            auto assign = context.compiler.assignStatement(target, source);
            return context.compiler.sequence(incref.compile(context).statement, assign);
        }
        return context.compiler.stmtWithTemporaryExpr(source, &do_);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        mut Context context = context;
        // disable lifetime management
        // (otherwise we get an infinite cycle when the compiler
        // tries to clean up 'this' after the __destroy() call by
        // ending its lifetime (ad infinitum).
        auto tempThis = new PairedTemporary(reference.type, Ownership.owned);
        auto initTemp = new InitializeTemporaryStatement(tempThis, reference);

        auto sizeT = context.nativeWordType;
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "this", tempThis));
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "size_t", sizeT));

        // TODO do in __destroy() once we have function imports
        auto freeFun = once new FunctionDeclaration(
            "free", new Void, [Parameter(false, "ptr", false, new Pointer(new Void))]);
        auto refCountDecFun = once new FunctionDeclaration(
            "neat_runtime_refcount_dec", new Integer, [
                Parameter(false, "label", false, new Array(new Character)),
                Parameter(false, "ptr", false, new Pointer(new Void))]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "free", freeFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "neat_runtime_refcount_dec", refCountDecFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "dec_name", new StringLiteral("dec " ~ this.intf.name)));
        auto stmt = context.compiler.$stmt
            if (!!this) {
                auto baseOffset = **cast(size_t**) this;
                auto object = &(cast(char*) this)[-baseOffset];
                if (neat_runtime_refcount_dec(dec_name, &(cast(size_t*) object)[1]))
                {
                    // manually call __destroy method, second entry in the object vtable
                    auto fn = (*cast(void function(void*)**) object)[1];
                    fn(object);
                    free(object);
                }
            };
        return context.compiler.sequence(initTemp, stmt.compile(context).statement);
    }
}

/// Checks that first is a Liskov-substitutable subtype of second (without implicit conversion).
/// This is the sense in which two classes are substitutable in parameters or return types.
bool isStrictSubtypeOf(Type first, Type second)
{
    mut auto firstClass = first.instanceOf(ClassType), secondClass = second.instanceOf(ClassType);
    if (firstClass && secondClass)
    {
        // TODO check interface slots here once that's a thing (count distance from each root parent?)
        while (firstClass)
        {
            if (firstClass.same(secondClass)) return true;
            firstClass = firstClass.superClass;
        }
        return false;
    }
    return first.same(second);
}

class ClassMethodSymbol : LateSymbol
{
    Class class_; // TODO does this cause a ref cycle? remove?

    size_t methodOffset;

    // We somehow selected a method of a specific class. Bypass vtable lookup.
    // For instance, used for super methods.
    bool staticLookup;

    this(this.class_, this.baseExpr, this.methodOffset, this.staticLookup) {}

    override Expression resolve(Context context, Expression baseExpr)
    {
        if (this.class_.final_ || this.staticLookup) {
            this.class_.vtable[methodOffset].case {
                ClassMethod method: return new FunctionReference(method);
                (:baseOffset, size_t): assert(false);
            }
        }
        Reference classInfo = context.compiler.dereference(context.compiler.dereference(new PointerCast(
            new Pointer(new Pointer(class_.classInfoStruct(context))),
            baseExpr)));
        mut Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
        auto funcPtr = funcPtrValue.type.instanceOf(FunctionPointer);

        auto funcPtrWithVoidpThis = new FunctionPointer(funcPtr.ret, [param for param in funcPtr.params]);
        funcPtrWithVoidpThis.params[0] = Parameter.fromType(once new Pointer(new Void));
        funcPtrValue = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);

        return funcPtrValue;
    }
}

class IntfMethodSymbol : LateSymbol
{
    IntfType intfType; // TODO does this cause a ref cycle? remove?

    // methodOffset includes base offsets.
    size_t methodOffset;

    this(this.intfType, this.baseExpr, this.methodOffset) {}

    override Expression resolve(Context context, Expression baseExpr)
    {
        Reference classInfo = context.compiler.dereference(context.compiler.dereference(new PointerCast(
            new Pointer(new Pointer(this.intfType.intf.intfVtableStruct(context))),
            baseExpr)));
        mut Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
        auto funcPtr = funcPtrValue.type.instanceOf(FunctionPointer);

        auto funcPtrWithVoidpThis = new FunctionPointer(funcPtr.ret, [param for param in funcPtr.params]);
        funcPtrWithVoidpThis.params[0] = Parameter.fromType(once new Pointer(new Void));
        funcPtrValue = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);

        return funcPtrValue;
    }

    override Expression patchContext(Context context, Expression baseExpr) {
        auto astBaseExpr = new ASTSymbolHelper(baseExpr);
        auto astObjectPtr = context.compiler.$expr ({
            auto baseOffset = **cast(size_t**) $astBaseExpr;
            &(cast(char*) $astBaseExpr)[-baseOffset];
        });
        return astObjectPtr.compile(context).beExpression;
    }
}

struct ASTClassDeclMember
{
    Protection protection;

    string name;

    ASTSymbol type;

    Loc loc;
}

struct ASTClassDeclMethod
{
    Loc loc;

    Protection protection;

    bool override_;

    bool abstract_;

    string name;

    ASTSymbol ret;

    (ASTParameter | ASTThisAssignment)[] params;

    ASTStatement body_;
}

class ASTClassVersionBlock
{
    string name;
    ASTClassEntry[] then, else_;
    this(this.name, this.then, this.else_) { }
}

alias ASTClassEntry = (ASTClassDeclMember | ASTClassDeclMethod | ASTDeclaration | ASTClassVersionBlock);

class ASTClassDecl : ASTSymbol
{
    string name;

    string[] supers;

    bool final_;

    bool abstract_;

    ASTClassEntry[] members;

    MacroState macroState;

    Loc loc;

    this(this.name, this.supers, this.final_, this.abstract_,
         this.members, this.macroState, this.loc) { }

    override ClassType compile(Context context)
    {
        mut Class superClass = null;
        mut Intf[] superIntfs = [];
        for (int i <- 0 .. this.supers.length) {
            auto super_ = this.supers[i];
            Symbol superObj = context.namespace.lookup(super_, context, loc, null);
            this.loc.assert2s(!!superObj, "super class/intf not found: $super_");
            auto superClassTest = superObj.instanceOf(ClassType);
            if (i == 0 && superClassTest) {
                // first super may be a class
                superClass = superClassTest.class_;
            } else {
                // all others must be intfs
                auto superIntf = superObj.instanceOf(Intf);
                this.loc.assert2s(!!superIntf, "super interface is not an interface: $super_");
                superIntfs ~= superIntf;
            }
        }
        return new ClassType(new Class(this, superClass, superIntfs, context.namespace),
            zeroInitializable=false);
    }

    void compile2(Context context, Class target)
    {
        auto classType = new ClassType(target, zeroInitializable=false);
        auto classScope = context.compiler.symbolAlias(context.namespace, target.name, classType);

        mut Context currentContext = context.withNamespace(classScope);
        mut (string name, Protection protection, Type type)[] memberFields;
        // Do those later; they need fields resolved for this.field assignments.
        mut (ASTClassDeclMethod method, Context context)[] lateMemberMethods;

        void walk(ASTClassEntry entry) {
            entry.case {
                ASTClassDeclMember member: {
                    auto type = beType(member.loc, member.type.compile(currentContext));
                    memberFields ~= (member.name, member.protection, type);
                }
                ASTClassDeclMethod method: {
                    lateMemberMethods ~= (method, currentContext);
                }
                /**
                 * Note: currentContext gets overwritten even in version blocks,
                 * because version blocks *don't* open a scope.
                 */
                ASTDeclaration astDecl: {
                    currentContext = astDecl.compile(currentContext);
                }
                ASTClassVersionBlock ver: {
                    if ([any a == ver.name for a in context.platform.versions]) {
                        [walk(entry) for entry in ver.then];
                    } else {
                        [walk(entry) for entry in ver.else_];
                    }
                }
            }
        }
        [walk(a) for a in this.members];

        target.members = memberFields;

        target.methods = new ClassMethod[](lateMemberMethods.length);
        target.initDataStruct(context);
        for (int i <- 0 .. lateMemberMethods.length)
        {
            ASTClassDeclMethod method = lateMemberMethods[i].method;
            auto methodContext = lateMemberMethods[i].context;

            auto methodParams = new Parameter[](method.params.length);
            for (int k <- 0 .. method.params.length)
            {
                auto param = method.params[k];
                param.case {
                    ASTThisAssignment param:
                    {
                        // FIXME self-recursion in nested function
                        mut Type delegate(Class) findType;
                        Type findType_(Class self) {
                            if (self.superClass)
                                if (auto ret = findType(self.superClass))
                                    return ret;
                            return [first m.type for m in self.members where m.name == param.name else null];
                        }
                        findType = &findType_;
                        auto type = findType(target);
                        // TODO specific loc
                        method.loc.assert2s2(!!type, "no such member: ", param.name);
                        methodParams[k] = Parameter(true, param.name, false, type);
                    }
                    ASTParameter param:
                        methodParams[k] = Parameter(
                            false, param.name, param.mutable, beType(param.loc, param.type.compile(methodContext)));
                }
            }

            auto classType = new ClassType(target, zeroInitializable=false);
            auto methodNamespace = new ClassNamespace(currentContext.namespace, classType);
            target.methods[i] = new ClassMethod(
                classType,
                method.loc,
                method.protection,
                method.override_,
                method.abstract_,
                method.name,
                beType(method.loc, method.ret.compile(methodContext)),
                methodParams,
                method.body_,
                this.macroState,
                methodNamespace);
        }
        target.genVtable(currentContext);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTClassDecl'!"); assert(false); }
}

struct ASTIntfDeclMethod
{
    Loc loc;

    string name;

    ASTSymbol ret;

    ASTParameter[] params;
}

class ASTIntfDecl : ASTSymbol
{
    string name;

    string[] superIntfs;

    (ASTIntfDeclMethod | ASTDeclaration)[] members;

    MacroState macroState;

    Loc loc;

    this(this.name, this.superIntfs, this.members, this.macroState, this.loc) { }

    override IntfType compile(Context context)
    {
        mut Intf[] superIntfs = [];
        if (this.superIntfs.length > 0)
        {
            for (auto superIntf <- this.superIntfs) {
                Symbol superIntfSym = context.namespace.lookup(superIntf, context, loc, null);
                this.loc.assert2s(!!superIntfSym, "super interface not found: " ~ superIntf);
                auto superIntf = superIntfSym.instanceOf(Intf);
                assert(!!superIntf);
                superIntfs ~= superIntf;
            }
        }
        return new IntfType(
            new Intf(this, superIntfs, context.namespace),
            zeroInitializable=false);
    }

    void compile2(Context context, Intf target)
    {
        auto intfType = new IntfType(target, zeroInitializable=false);
        auto intfScope = context.compiler.symbolAlias(context.namespace, target.name, intfType);

        mut Context currentContext = context.withNamespace(intfScope);

        for (auto member <- this.members) {
            member.case {
                ASTIntfDeclMethod method: {
                    auto methodParams = new Parameter[](method.params.length);
                    for (int k <- 0 .. method.params.length) {
                        auto param = method.params[k];
                        methodParams[k] = Parameter(
                            false, param.name, param.mutable, beType(param.loc, param.type.compile(currentContext)));
                    }

                    target.methods ~= new IntfMethod(
                        intfType,
                        method.name,
                        beType(method.loc, method.ret.compile(currentContext)),
                        methodParams);
                }
                ASTDeclaration astDecl: {
                    currentContext = astDecl.compile(currentContext);
                }
            }
        }

        target.genVtable;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTIntfDecl'!"); assert(false); }
}

ASTClassDecl parseClassDecl(Parser parser, LexicalContext lexicalContext)
{
    mut bool classAbstract = false;
    mut bool classFinal = false;
    parser.begin;
    parser.strip;
    auto loc = parser.loc;
    while (true) {
        if (acceptIdentifier(parser, "abstract")) {
            classAbstract = true;
            continue;
        }
        if (acceptIdentifier(parser, "final")) {
            classFinal = true;
            continue;
        }
        break;
    }
    if (!acceptIdentifier(parser, "class"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parseIdentifier(parser);
    mut string[] supers;
    if (parser.accept(":")) {
        while (true) {
            auto super_ = parseIdentifier(parser);
            parser.assert_(super_.length > 0, "expected super class identifier");
            supers ~= super_;
            if (parser.accept(",")) continue;
            break;
        }
    }

    mut ASTClassEntry[] members;
    parser.expect("{");
    while (!parser.accept("}")) {
        members ~= parseClassEntry(parser, lexicalContext);
    }
    return new ASTClassDecl(
        name, supers, classFinal, classAbstract,
        members, lexicalContext.macroState, loc);
}

ASTClassEntry[] parseClassEntry(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("version")) {
        mut ASTClassEntry[] then, else_;
        parser.expect("(");
        string versionStr = parser.parseIdentifier;
        parser.expect(")");
        if (parser.accept("{")) {
            while (!parser.accept("}")) {
                then ~= parser.parseClassEntry(lexicalContext);
            }
        } else {
            then ~= parser.parseClassEntry(lexicalContext);
        }
        if (parser.accept("else")) {
            if (parser.accept("{")) {
                while (!parser.accept("}")) {
                    else_ ~= parser.parseClassEntry(lexicalContext);
                }
            } else {
                else_ ~= parser.parseClassEntry(lexicalContext);
            }
        }
        // FIXME explicitly type hinted literal
        ASTClassEntry result = new ASTClassVersionBlock(versionStr, then, else_);
        return [result];
    }

    parser.strip;

    auto loc = parser.loc;

    mut ASTSymbol retType;
    mut string memberName;
    mut bool override_ = false;
    mut bool abstract_ = false;
    mut Protection protection = Protection.public_;
    while (true) {
        if (acceptIdentifier(parser, "override")) {
            override_ = true;
            continue;
        }
        if (acceptIdentifier(parser, "abstract")) {
            abstract_ = true;
            continue;
        }
        // FIXME only allow one
        // FIXME parseProtection?
        if (acceptIdentifier(parser, "public")) {
            protection = Protection.public_;
            continue;
        }
        if (acceptIdentifier(parser, "private")) {
            protection = Protection.private_;
            continue;
        }
        if (acceptIdentifier(parser, "protected")) {
            protection = Protection.protected_;
            continue;
        }
        break;
    }

    if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)) {
        // TODO return [ASTClassEntry: decl];
        ASTClassEntry entry = decl;
        return [entry];
    }

    if (parser.accept("this"))
    {
        parser.assert_(!override_, "cannot override constructor");
        retType = new ASTBasicType("void", loc);
        memberName = "__ctor";
    }
    else
    {
        retType = lexicalContext.compiler.parseType(parser, lexicalContext);
        parser.assert_(!!retType, "expected member type");
        memberName = parseIdentifier(parser);
        parser.assert_(memberName.length > 0, "expected member name");
    }
    if (parser.accept("(")) // method
    {
        auto params = parseParamList(parser, lexicalContext);
        ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext);
        ASTClassEntry entry = ASTClassDeclMethod(
            loc, protection, override_, abstract_, memberName, retType, params, stmt);
        return [entry];
    }
    else
    {
        mut ASTClassEntry[] members;
        void addMember() {
            parser.assert_(!override_, "cannot override class member");
            parser.assert_(!abstract_, "cannot declare class member abstract");
            members ~= ASTClassDeclMember(protection, memberName, retType, loc);
        }
        addMember;
        while (!parser.accept(";")) {
            parser.expect(",");
            if (parser.accept(";")) break;
            memberName = parseIdentifier(parser);
            parser.assert_(memberName.length > 0, "expected member name");
            addMember;
        }
        return members;
    }
}

ASTIntfDecl parseIntfDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    parser.strip;
    auto loc = parser.loc;
    if (!acceptIdentifier(parser, "interface"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parseIdentifier(parser);
    mut string[] superIntfs;
    if (parser.accept(":")) {
        while (true) {
            string superIntf = parseIdentifier(parser);
            parser.assert_(superIntf.length > 0, "expected super identifier identifier");
            superIntfs ~= superIntf;
            if (parser.accept(",")) continue;
            break;
        }
    }
    mut (ASTIntfDeclMethod | ASTDeclaration)[] members;
    parser.expect("{");
    while (!parser.accept("}"))
    {
        parser.strip;

        auto loc = parser.loc;

        if (auto decl = lexicalContext.compiler.parseDeclaration(parser, lexicalContext)) {
            members ~= decl;
            continue;
        }

        ASTSymbol retType = lexicalContext.compiler.parseType(parser, lexicalContext);
        parser.assert_(!!retType, "expected member type");
        string memberName = parseIdentifier(parser);
        parser.assert_(memberName.length > 0, "expected member name");
        parser.expect("(");
        auto params = parseParamList(parser, lexicalContext);
        parser.expect(";");
        parser.loc.assert2s(
            [all a.case(ASTParameter: true, ASTThisAssignment: false) for a in params],
            "no 'this.' in interface method");
        // FIXME bottom
        ASTParameter fail() { assert(false); }
        auto astParameters = [a.case(ASTParameter p: p, ASTThisAssignment: fail) for a in params];
        members ~= ASTIntfDeclMethod(loc, memberName, retType, astParameters);
    }
    return new ASTIntfDecl(name, superIntfs, members, lexicalContext.macroState, loc);
}

class ClassInfo : Expression
{
    (ClassType | IntfType) classType;

    this(this.classType) {
        this.type = once new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        this.classType.case {
            ClassType classType: {
                classType.class_.declare(output);
                return output.fun.symbolList(classType.class_.vtableSymbol);
            }
            IntfType intfType: {
                intfType.intf.declare(output);
                return output.fun.symbolList(intfType.intf.classInfoSymbol);
            }
        }
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.owned); }

    override void hash(Hash hash) {
        hash.adds("ClassInfo");
        classType.case {
            ClassType classType: classType.hash(hash);
            IntfType intfType: intfType.hash(hash);
        }
    }
}

class NewClassExpression : Expression
{
    ClassType classType;

    this(this.classType) {
        this.type = this.classType;
    }

    override int emit(Generator output)
    {
        // oh boy!
        BackendType voidp = once (new Pointer(new Void)).emit(output.platform);
        BackendType sizeT = output.platform.nativeWordType;
        auto basicClassStruct = new BackendStructType([voidp, sizeT]);

        int classDataSize = this.classType.class_.dataStruct.emit(output.platform).size(output.platform);
        int classInfoPtr = (new ClassInfo(classType)).emit(output);
        int classPtr = output.fun.call(
            voidp, "neat_runtime_alloc", [output.fun.wordLiteral(output.platform, classDataSize)]);

        int classInfoTarget = output.fun.fieldOffset(basicClassStruct, classPtr, 0);
        output.fun.store(voidp, classInfoTarget, classInfoPtr);
        int refCount = output.fun.fieldOffset(basicClassStruct, classPtr, 1);
        int one = output.fun.wordLiteral(output.platform, 1);
        // write interface slot pointers
        for (int i <- 0 .. classType.class_.vtable.length) {
            classType.class_.vtable[i].case {
                ClassMethod method: continue;
                (:baseOffset, size_t offset): {
                    // void*[] class_islot1;
                    auto vtablePtrType = once new BackendPointerType(new BackendPointerType(new BackendVoidType));
                    // &class_islot1
                    auto interfaceSlot = output.fun.bitcast(
                        output.fun.ptrOffset(
                            once new BackendCharType,
                            classPtr,
                            output.fun.intLiteral(offset)),
                        once new BackendPointerType(vtablePtrType));

                    auto vtableOffset = output.fun.intLiteral(i);
                    auto vtableOffsetPtr = output.fun.ptrOffset(
                        once new BackendPointerType(new BackendVoidType),
                        classInfoPtr,
                        vtableOffset);

                    output.fun.store(
                        vtablePtrType,
                        interfaceSlot,
                        vtableOffsetPtr);
                }
            }
        }
        output.fun.store(sizeT, refCount, one);

        return classPtr;
    }

    // the archetypal example
    override ExprInfo info() { return ExprInfo(false, Ownership.gifted); }

    override void hash(Hash hash) { hash.adds("NewClassExpression"); classType.hash(hash); }
}

class ASTInstanceOf : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol target;

    Loc loc;

    this(this.base, this.target, this.loc) { }

    override Symbol compile(Context context)
    {
        Expression base = beExpression3(context, this.base.compile(context), loc);
        auto type = base.type;
        loc.assert2s(
            type.instanceOf(ClassType) || type.instanceOf(IntfType),
            "Base of instanceOf must be class or interface.");
        Expression do_(Expression base) {
            auto targetSym = target.compile(context);
            ClassType targetClass = targetSym.instanceOf(ClassType);
            IntfType targetIntf = targetSym.instanceOf(IntfType);
            Type target() {
                if (targetClass) return targetClass;
                else return targetIntf;
            }
            loc.assert2s(!!target, "Target of instanceOf must be class or interface.");
            Expression classInfo() {
                if (targetClass) return new ClassInfo(targetClass);
                else return new ClassInfo(targetIntf);
            }
            ASTSymbol astTarget = new ASTSymbolHelper(target);
            ASTSymbol astClassInfo = new ASTSymbolHelper(classInfo);

            if (type.instanceOf(Intf)) {
                auto astBase = new ASTSymbolHelper(base);
                auto instanceOfExpr = context.compiler.$expr ({
                    auto baseOffset = **cast(size_t**) $astBase;
                    auto object = &(cast(char*) $astBase)[-baseOffset];
                    // vtable 0 is always instanceof
                    auto fn = (*cast($astTarget function(void*, void*)**) object)[0];
                    fn(object, $astClassInfo);
                });
                return instanceOfExpr.compile(context).beExpression;
            }

            Symbol instanceOf = context.compiler.accessMember(context, base, "__instanceof", loc, false);
            auto astInstanceOf = new ASTSymbolHelper(instanceOf);
            return new PointerCast(target,
                context.compiler.call(context, astInstanceOf, [ASTArgument(astClassInfo, "")], loc, false));
        }
        return context.compiler.exprWithTemporaryExpr(base, &do_);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTInstanceOf'"); assert(false); }
}

ASTSymbol parseInstanceOf(Parser parser, LexicalContext lexicalContext, ASTSymbol left)
{
    parser.begin;
    if (!(parser.accept(".") && parser.accept("instanceOf")))
    {
        parser.revert;
        return null;
    }
    parser.expect("(");
    ASTSymbol type = lexicalContext.compiler.parseType(parser, lexicalContext);
    parser.expect(")");
    parser.commit;
    return new ASTInstanceOf(left, type, parser.loc);
}

class ASTNewExpression : ASTSymbol
{
    ASTSymbol type;

    ASTArgument[] astArgs;

    Loc loc;

    this(this.type, this.astArgs, this.loc) { }

    override Symbol compile(Context context)
    {
        Type type = beType(this.loc, this.type.compile(context));

        if (ClassType classType = type.instanceOf(ClassType)) {
            Expression classptr = new NewClassExpression(classType);

            this.loc.assert2s2(!!classType, "expected new <class>, not %s", type.repr);

            Expression do_(Expression classptr) {
                // don't clean up classptr after constructor call, we're continuing its lifetime
                auto ctor = context.compiler.accessMember(
                    context, new IgnoreLifetimeExpr(classptr), "__ctor", this.loc, false);
                auto astCtor = new ASTSymbolHelper(ctor);
                auto ctorCall = context.compiler.exprStatement(
                    context.compiler.call(context, astCtor, this.astArgs, this.loc, false));

                return context.compiler.statementExpression(ctorCall, classptr);
            }
            return context.compiler.exprWithTemporaryExpr(classptr, &do_);
        }
        if (Array arrayType = type.instanceOf(Array)) {
            this.loc.assert2s(this.astArgs.length == 1, "expected one argument to loc");

            Type sizeT = context.nativeWordType;
            auto length = expectImplicitConvertTo(
                context, beExpression3(context, this.astArgs[0].sym.compile(context), this.loc), sizeT, this.loc);
            return new ArrayAllocation(arrayType.elementType, length);
        }
        this.loc.assert2s2(false, "don't know how to allocate ", type.repr);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto quotedArgs = [
            quoter.compiler.astCall(
                quoter.compiler.astIdentifier("ASTArgument", loc), [
                    arg.sym.quote(quoter),
                    quoter.compiler.astStringLiteral(arg.name, loc)], loc)
            for arg in this.astArgs];
        return quoter.compilerCall("astNewExpression", [
            this.type.quote(quoter),
            quoter.compiler.astArrayLiteral(quotedArgs, loc)], loc);
    }
}

class Super : Symbol
{
    ClassType classType;

    this(this.classType) { }

    Symbol lookup(Context context, string name, Loc loc) {
        auto superClass = this.classType.class_.superClass;
        bool matches(typeof(this.classType.class_.vtable[0]) entry) {
            return entry.case(
                ClassMethod m: m.name == name,
                (:baseOffset, size_t): false);
        }
        auto methodOffset = [first i for i, a in superClass.vtable where matches(a) else -1];
        loc.assert2s3(methodOffset != -1, "Method '", name, "' not found in super class!");
        // TODO lookup() that handles the stackframe thing
        auto stackframe = once new ReferenceExpression(new StackFrame(new Void));
        auto baseExpr = context.namespace.lookup("this", context, loc, stackframe).instanceOf(Expression);
        return new ClassMethodSymbol(superClass, baseExpr, methodOffset, staticLookup=true);
    }
}

/**
 * The 'super' keyword. Only supports the syntax `super.foo` to select a superclass method statically.
 */
class ASTSuper : ASTSymbol
{
    Loc loc;

    this(this.loc) { }

    override Symbol compile(Context context) {
        auto classNs = findParent!ClassNamespace(context.namespace);
        loc.assert2s(!!classNs, "'super' may only appear in class");
        loc.assert2s(!!classNs.class_.superClass, "'super' may only appear in class that has parent class");
        return new Super(classNs.class_);
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTArgument[] noArgs; // hax: [] can't convert to an Either of two arrays
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTSuper", __HERE__), noArgs, __HERE__);
    }

    override string repr() { return "super"; }
}

class ASTNullable : ASTSymbol
{
    Loc loc;

    ASTSymbol next;

    this(this.loc, this.next) { }

    override Symbol compile(Context context) {
        auto next = beType(this.loc, this.next.compile(context));
        if (auto classType = next.instanceOf(ClassType))
            return classType.makeNullable;
        else if (auto intfType = next.instanceOf(IntfType))
            return intfType.makeNullable;
        this.loc.fail("Cannot mark type as nullable: $(next.repr)");
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astNullable", [this.next.quote(quoter)], loc);
    }
}
