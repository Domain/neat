module neat.formatstring;

macro import std.macro.listcomprehension;
macro import std.macro.quasiquoting;

import neat.array;
import neat.base;
import neat.class_;
import neat.decl;
import neat.expr;
import neat.struct_;
import neat.types;
import neat.tuples;
import neat.util;

class ASTFormatString : ASTSymbol
{
    ASTSymbol[] parts;

    this(this.parts, this.locRange) { }

    override (Symbol | fail Error) compile(Context context) {
        mut auto context = context;
        auto compiler = context.compiler;
        mut ASTSymbol result = compiler.astStringLiteral("", __RANGE__);
        bool isString(Type type) {
            if (auto array = type.instanceOf(Array))
                return !!array.elementType.instanceOf(Character);
            return false;
        }
        ASTSymbol str(string text) {
            return compiler.astStringLiteral(text, __RANGE__);
        }
        ASTSymbol append(ASTSymbol prev, string text) {
            auto strSym = str(text);
            return compiler.$expr $prev ~ $strSym;
        }
        for (auto part in parts) {
            auto sym = part.compile(context)?.beExpressionImplCall(context, part.locRange)?;
            ASTSymbol astSym = new ASTSymbolHelper(sym);
            if (sym.type.isString) {
                result = compiler.$expr $result ~ $astSym;
            } else if (sym.type.instanceOf(Integer) || sym.type.instanceOf(Short) || sym.type.instanceOf(UByte)) {
                result = compiler.$expr $result ~ itoa($astSym);
            } else if (sym.type.instanceOf(Float) || sym.type.instanceOf(Double)) {
                result = compiler.$expr $result ~ ftoa($astSym);
            } else if (sym.type.instanceOf(Long)) {
                result = compiler.$expr $result ~ ltoa($astSym);
            } else if (sym.type.instanceOf(Boolean)) {
                result = compiler.$expr $result ~ btoa($astSym);
            } else if (sym.type.instanceOf(Struct) || sym.type.instanceOf(ClassType) || sym.type.instanceOf(IntfType)) {
                result = compiler.$expr $result ~ $astSym.toString;
            } else if (sym.type.instanceOf(Array)) {
                result = compiler.$expr $result ~ atoa($astSym);
            } else if (sym.type.instanceOf(NullPointer) || sym.type.instanceOf(Pointer)) {
                result = compiler.$expr $result ~ ptoa($astSym);
            } else if (auto identType = sym.type.instanceOf(SymbolIdentifierType)) {
                result = result.append(identType.repr);
            } else if (auto tupleType = sym.type.instanceOf(TupleType)) {
                mut ASTSymbol[] parts = [str("(")];
                for (int i, member in tupleType.members) {
                    if (i) parts ~= str(", ");
                    auto memberExpr = compiler.astIndex(
                        compiler.astIdentifier("that", __RANGE__),
                        compiler.astIntLiteral(i, __RANGE__), __RANGE__);
                    parts ~= memberExpr;
                }
                parts ~= str(")");
                auto subExpr = new ASTFormatString(parts, __RANGE__);
                auto astPropertyExpr = compiler.astParenPropertyExpression(astSym, subExpr, __RANGE__);
                result = compiler.$expr $result ~ $astPropertyExpr;
            } else {
                return this.locRange.fail("Don't know how to format $(sym.type.repr)");
            }
        }
        result = compiler.$expr ({ import package(compiler).neat.runtime : atoa, btoa, ftoa, itoa, ltoa, ptoa; $result; });

        return result.compile(context);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto parts = [a.quote(quoter) for a in this.parts];
        auto partsArray = quoter.compiler.astArrayLiteralTypeHint(
            quoter.compiler.astIdentifier("ASTSymbol", __RANGE__),
            parts,
            __RANGE__);

        return quoter.compilerCall("astFormatString", [
            partsArray], this.locRange);
    }
}

