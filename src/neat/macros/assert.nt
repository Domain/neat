module neat.macros.assert;

macro import neat.macros.quasiquoting;

import package(compiler).helpers;
import package(compiler).neat.array;
import package(compiler).neat.base;
import package(compiler).neat.decl;
import package(compiler).neat.expr;
import package(compiler).neat.parser_base;
import package(compiler).neat.statements;
import package(compiler).neat.types;

class ASTAssertion : ASTStatement
{
    ASTSymbol test;

    string exprText;

    Loc loc;

    this(this.test, this.exprText, this.loc) { }

    Expression symbolTest(Context context, ASTSymbol sym) {
        auto context = context.withNamespace(context.compiler.exprAlias(
                context.namespace, "identName", context.compiler.stringLiteral(repr(sym))));

        return notNull!Expression((
            context.compiler.$expr ({ import package(compiler).neat.runtime : itoa; identName ~ " = " ~ itoa(cast(int) $sym); })
        ).compile(context).instanceOf(Expression));
    }

    nullable Expression binopTest(mut Context context, ASTBinaryOp binop) {
        void set(string name, Symbol value) {
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, name, value));
        }
        string leftStr = repr(binop.left), rightStr = repr(binop.right);
        set("leftStr", context.compiler.stringLiteral(leftStr));
        set("rightStr", context.compiler.stringLiteral(rightStr));
        auto
            left = binop.left.compile(context).instanceOf(Expression),
            right = binop.right.compile(context).instanceOf(Expression);
        if (!left || !right) return null;
        set("left", left);
        set("right", right);

        if (binop.op == "&&") {
            auto leftRecurse = dispatch(context, binop.left);
            auto rightRecurse = dispatch(context, binop.right);
            if (!leftRecurse || !rightRecurse) return null;
            set("leftRecurse", leftRecurse);
            set("rightRecurse", rightRecurse);

            return (context.compiler.$expr ({
                mut string ret;
                if (!left) ret = leftStr ~ " failed, because " ~ leftRecurse;
                else ret = rightStr ~ " failed, because " ~ rightRecurse;
                ret;
            })).compile(context).instanceOf(Expression);
        }
        if (binop.op == "||") {
            auto leftRecurse = dispatch(context, binop.left);
            auto rightRecurse = dispatch(context, binop.right);
            if (!leftRecurse || !rightRecurse) return null;
            set("leftRecurse", leftRecurse);
            set("rightRecurse", rightRecurse);

            return (context.compiler.$expr ({
                mut string ret;
                if (left) ret = rightStr ~ " failed, because " ~ rightRecurse;
                else if (right) ret = leftStr ~ " failed, because " ~ leftRecurse;
                else ret = leftStr ~ " failed (because " ~ leftRecurse ~ ") and "
                    ~ rightStr ~ " failed (because " ~ rightRecurse ~ ")";
                ret;
            })).compile(context).instanceOf(Expression);
        }
        bool isString(Type type) {
            if (auto arr = type.instanceOf(Array))
                return !!arr.elementType.instanceOf(Character);
            return false;
        }
        bool isIntCastable(Type type) {
            return type.instanceOf(Integer) || type.instanceOf(Long)
                || type.instanceOf(Character) || type.instanceOf(Short);
        }
        if (left.type.isIntCastable && right.type.isIntCastable) {
            if (right.instanceOf(IntLiteral)) {
                return (context.compiler.$expr ({
                    import package(compiler).neat.runtime : itoa;
                    leftStr ~ " = " ~ itoa(cast(int) left);
                })).compile(context).instanceOf(Expression);
            }
            return (context.compiler.$expr ({
                import package(compiler).neat.runtime : itoa;
                leftStr ~ " = " ~ itoa(cast(int) left)
                ~ " and " ~ rightStr ~ " = " ~ itoa(cast(int) right);
            })).compile(context).instanceOf(Expression);
        }
        if (left.type.instanceOf(Float) && right.type.instanceOf(Float)) {
            return (context.compiler.$expr ({
                import package(compiler).neat.runtime : ftoa;
                leftStr ~ " = " ~ ftoa(left)
                ~ " and " ~ rightStr ~ " = " ~ ftoa(right);
            })).compile(context).instanceOf(Expression);
        }
        if (left.type.isString && right.type.isString) {
            if (right.instanceOf(StringLiteral)) {
                return (
                    context.compiler.$expr leftStr ~ " = \"" ~ left ~ "\""
                ).compile(context).instanceOf(Expression);
            }
            return (
                context.compiler.$expr
                    leftStr ~ " = \"" ~ left ~ "\""
                    ~ " and " ~ rightStr ~ " = \"" ~ right ~ "\""
            ).compile(context).instanceOf(Expression);
        }
        return null;
    }

    nullable Expression negTest(mut Context context, ASTNegation astNegation)
    {
        void set(string name, Symbol value) {
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, name, value));
        }

        auto nextRecurse = dispatch(context, astNegation.next);
        if (!nextRecurse) return null;
        set("nextRecurse", nextRecurse);
        string nextStr = repr(astNegation.next);
        set("nextStr", context.compiler.stringLiteral(nextStr));

        return (
            context.compiler.$expr nextRecurse ~ " was true"
        ).compile(context).instanceOf(Expression);
    }

    nullable Expression dispatch(Context context, ASTSymbol sym) {
        if (auto ident = sym.instanceOf(ASTIdentifier))
        {
            return symbolTest(context, ident);
        }
        if (auto member = sym.instanceOf(ASTMemberBase))
        {
            return symbolTest(context, member);
        }
        if (auto binop = sym.instanceOf(ASTBinaryOp))
        {
            return binopTest(context, binop);
        }
        if (auto neg = sym.instanceOf(ASTNegation))
        {
            return negTest(context, neg);
        }
        return null;
    }

    override StatementCompileResult compile(Context context)
    {
        mut Context context = context;
        auto printFun = new FunctionDeclaration(
            "print", new Void, [Parameter(false, "str", false, new Array(new Character))]);
        auto assertFun = new FunctionDeclaration(
            "assert", new Void, [Parameter(false, "test", false, new Integer)]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "print", printFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "assert", assertFun));
        string failedMsg = loc.location() ~ ": assertion failed: " ~ exprText ~ ", because ";
        if (auto ifFailed = dispatch(context, test)) {
            context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "ifFailed", ifFailed));
            context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "failedMsg", context.compiler.stringLiteral(failedMsg)));
            auto assertTest = context.compiler.$stmt {
                if (!$test) {
                    print(failedMsg ~ ifFailed);
                    assert(false);
                }
            };
            auto assertTestStmt = assertTest.compile(context);
            return StatementCompileResult(assertTestStmt.statement, context);
        }

        // fallback: old impl
        // TODO quasiquote this
        auto test = this.test.compile(context);
        auto expr = beExpression2(test, this.loc);
        auto texpr = context.compiler.truthy(context, expr, this.loc);
        auto nexpr = context.compiler.binaryOp(
            "==", context, texpr, context.compiler.intLiteral(0), this.loc);

        Expression failStr = context.compiler.binaryOp(
                "~", context,
                context.compiler.stringLiteral(this.loc.location()),
                context.compiler.stringLiteral(": '" ~ this.exprText ~ "' was false"),
                this.loc);
        Expression false_ = context.compiler.intLiteral(0);
        Statement printSt = context.compiler.exprStatement(
            notNull!Expression(context.compiler.plainCall(context, printFun, [failStr], this.loc, false)));
        Statement failSt = context.compiler.exprStatement(
            notNull!Expression(context.compiler.plainCall(context, assertFun, [false_], this.loc, false)));
        // `if (!$expression) { print($assertLocStr ~ ": '" ~ $exprText ~ "' was false."); assert(false); }`
        return StatementCompileResult(
            context.compiler.ifStatement(
                nexpr,
                context.compiler.sequenceStatement([printSt, failSt]),
                null),
            context);
    }

    override ASTSymbol quote(Quoter quoter) {
        with (quoter.compiler) return astNewExpression(
            astIdentifier("ASTAssertion", __HERE__), [
                this.test.quote(quoter),
                astStringLiteral(this.exprText, __HERE__),
                quoter.quoteLoc(this.loc)], __HERE__);
    }
}

string repr(ASTSymbol expr) {
    assert(!!expr);
    if (auto ident = expr.instanceOf(ASTIdentifier)) {
        return ident.name;
    }
    if (auto neg = expr.instanceOf(ASTNegation)) {
        return "!" ~ repr(neg.next);
    }
    if (auto member = expr.instanceOf(ASTMemberBase)) {
        return repr(member.base) ~ "." ~ member.member;
    }
    if (auto binop = expr.instanceOf(ASTBinaryOp)) {
        return "(" ~ repr(binop.left) ~ " " ~ binop.op ~ " " ~ repr(binop.right) ~ ")";
    }
    if (auto intl = expr.instanceOf(ASTIntLiteral)) {
        return itoa(intl.value);
    }
    if (auto str = expr.instanceOf(ASTStringLiteral)) {
        return "\"" ~ str.text ~ "\"";
    }
    return "TODO";
}

class ParseAssert : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        if (auto args = args.instanceOf(ParseStatementArgs)) {
            // FIXME
            // args.statement = this.parse(args.parser, args.lexicalContext);
            if (auto ret = this.parse(args.parser, args.lexicalContext))
                args.statement = ret;
        }
    }

    nullable ASTStatement parse(Parser parser, LexicalContext context)
    {
        parser.begin();
        parser.strip();
        auto assertLoc = parser.loc();
        if (!parser.accept("assert"))
        {
            parser.revert();
            return null;
        }
        if (!parser.accept("("))
        {
            parser.revert();
            return null;
        }
        parser.commit();
        auto exprStartLoc = parser.loc;
        auto exprStart = parser.text;
        auto expression = notNull!ASTSymbol(context.compiler.parseExpression(parser, context));
        auto exprEnd = parser.text;
        auto exprText = exprStart[0 .. exprStart.length - exprEnd.length];

        parser.expect(")");
        parser.expect(";");

        return new ASTAssertion(expression, exprText, exprStartLoc);
    }
}

void assertMacro(MacroState macroState)
{
    macroState.addMacro(new ParseAssert);
}

macro(assertMacro);
