// TODO: $var escaping
module neat.macros.quasiquoting;

import package(compiler).helpers;
import package(compiler).neat.base;
import package(compiler).neat.parser_base;

class QuasiQuoterImpl : Quoter
{
    ASTSymbol compilerExpr;

    this(this.compiler, this.compilerExpr) { }

    version (next_generation) {
        override ASTSymbol compilerCall(string name, ASTSymbol[] parameters, Loc loc) {
            return compiler.astCall(compiler.astMember(compilerExpr, name, loc), parameters ~ quoteLoc(loc), loc);
        }
    } else {
        override ASTSymbol compilerCall(string name, ASTSymbol[] parameters, LocRange locRange) {
            return compiler.astCall(compiler.astMember(compilerExpr, name, locRange), parameters ~ quoteLocRange(locRange), locRange);
        }
    }

    version (next_generation) {
        override ASTSymbol quoteLoc(Loc loc) {
            return compiler.astCall(
                compiler.astIdentifier("Loc", __HERE__), [
                    compiler.astStringLiteral(loc.filename, __HERE__),
                    compiler.astIntLiteral(loc.row, __HERE__),
                    compiler.astIntLiteral(loc.column, __HERE__)
                ], __HERE__);
        }
    } else {
        override ASTSymbol quoteLocRange(LocRange locRange) {
            return compiler.astCall(
                compiler.astIdentifier("LocRange", __RANGE__), [
                    compiler.astStringLiteral(locRange.filename, __RANGE__),
                    compiler.astTupleLiteral([
                        compiler.astIntLiteral(locRange.from.row, __RANGE__),
                        compiler.astIntLiteral(locRange.from.column, __RANGE__)], __RANGE__),
                    compiler.astTupleLiteral([
                        compiler.astIntLiteral(locRange.to.row, __RANGE__),
                        compiler.astIntLiteral(locRange.to.column, __RANGE__)], __RANGE__)
                ], __RANGE__);
        }
    }
}

class QuasiQuoting : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        if (auto args = args.instanceOf(ParsePropertyArgs)) {
            args.result = this.parse(args.parser, args.lexicalContext, args.left);
        }
    }

    (nullable ASTSymbol | fail Error) parse(Parser parser, LexicalContext lexicalContext, ASTSymbol compilerExpr)
    {
        auto compiler = lexicalContext.compiler;

        auto quoter = new QuasiQuoterImpl(compiler, compilerExpr);
        {
            parser.begin();
            if (parser.accept(".")? && parser.accept("\$stmt")?) {
                parser.commit();
                auto stmt = compiler.parseStatement(parser, lexicalContext)?;
                parser.assert_(!!stmt, "statement expected")?;
                return stmt.quote(quoter);
            }
            parser.revert();
        }
        {
            parser.begin();
            if (parser.accept(".")? && parser.accept("\$expr")?) {
                parser.commit();
                auto expr = compiler.parseExpression(parser, lexicalContext)?;
                parser.assert_(!!expr, "expression expected")?;
                return expr.quote(quoter);
            }
            parser.revert();
        }
        {
            parser.begin();
            if (parser.accept(".")? && parser.accept("\$type")?) {
                parser.commit();
                auto type = compiler.parseType(parser, lexicalContext)?;
                parser.assert_(!!type, "type expected")?;
                return type.quote(quoter);
            }
            parser.revert();
        }
        return null;
    }
}

void addQuasiQuotingMacro(MacroState macroState)
{
    macroState.addMacro(new QuasiQuoting);
}

macro(addQuasiQuotingMacro);
