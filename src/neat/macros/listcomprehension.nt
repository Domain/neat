module neat.macros.listcomprehension;

macro import neat.macros.quasiquoting;

import package(compiler).helpers;
import package(compiler).neat.array;
import package(compiler).neat.base;
import package(compiler).neat.decl;
import package(compiler).neat.either;
import package(compiler).neat.parser;
import package(compiler).neat.parser_base;
import package(compiler).neat.statements;

class ASTListComprehension : ASTSymbol
{
    string iterationMode; // "", "any", "all", "first", "join", "count", "sum", "min", "max"

    nullable ASTSymbol expr;

    nullable ASTSymbol default_;

    nullable ASTSymbol joinKey;

    string iname; // iteration variable

    string varname;

    ASTSymbol source;

    nullable ASTSymbol where;

    this(this.iterationMode, this.expr, this.default_, this.joinKey,
        this.iname, this.varname, this.source, this.where, this.locRange)
    {
        if (!iname.length) iname = "__i";
    }

    override (Symbol | fail Error) compile(Context context) {
        auto compiler = context.compiler;

        if (iterationMode == "count") {
            this.locRange.assert(!expr, "no expr for count")?;
            mut auto test = compiler.$expr true;
            if (auto where = where) test = compiler.$expr $where && $test;
            return (compiler.$expr ({
                auto __source = $source;
                mut int __count = 0;
                for ($iname, $varname in __source) {
                    if ($test) __count += 1;
                }
                __count;
            })).compile(context);
        }

        auto sourceType = source.compile(context)?.beExpressionImplCall(context, this.locRange)?.type;
        auto expr = notNull!ASTSymbol(this.expr);
        mut uninitialized ASTSymbol astType;
        if (sourceType.instanceOf(Array)) {
            astType = compiler.$type typeof(({ auto $varname = $source[0]; size_t $iname = 0; $expr; }));
        } else {
            astType = compiler.$type typeof(({ auto $varname = $source.front; size_t $iname = 0; $expr; }));
        }
        mut auto type = astType.compile(context)?;

        bool defaultIsNullExpr() {
            // FIXME ?.
            if (auto default_ = default_)
                if (auto default_ = default_.instanceOf(ASTIdentifier))
                    return default_.name == "null";
            return false;
        }

        if (defaultIsNullExpr && context.compiler.isClassType(notNull!Type(type.instanceOf(Type)))) {
            astType = compiler.$type nullable $astType;
            type = astType.compile(context)?;
        }

        if (type.instanceOf(Void)) {
            this.locRange.assert(iterationMode == "", "non-void expression expected")?;
            assert(!default_);
            if (auto where = where) {
                return (compiler.$expr ({
                    auto __source = $source;
                    for ($iname, $varname in __source) {
                        if ($where) $expr;
                    }
                    0;
                })).compile(context);
            }
            return (compiler.$expr ({
                auto __source = $source;
                for ($iname, $varname in __source) {
                    $expr;
                }
                0;
            })).compile(context);
        } else if (iterationMode == "any") {
            assert(!default_);
            mut auto test = expr;
            if (auto where = where) test = compiler.$expr $where && $test;
            return (compiler.$expr ({
                auto __source = $source;
                mut bool __result = false;
                for ($iname, $varname in __source) {
                    if ($test) { __result = true; break; }
                }
                __result;
            })).compile(context);
        } else if (iterationMode == "all") {
            assert(!default_);
            mut auto test = compiler.$expr !$expr;
            if (auto where = where) test = compiler.$expr $where && $test;
            return (compiler.$expr ({
                auto __source = $source;
                mut bool __result = true;
                for ($iname, $varname in __source) {
                    if ($test) { __result = false; break; }
                }
                __result;
            })).compile(context);
        } else if (iterationMode == "join") {
            assert(!default_);
            mut auto test = compiler.$expr true;
            if (auto where = where) test = compiler.$expr $where && $test;
            if (auto joinKey = this.joinKey) {
                return (compiler.$expr ({
                    auto __source = $source;
                    mut typeof(({ $astType sample; $joinKey ~ sample; })) __result;
                    mut bool __first = true;
                    for ($iname, $varname in __source) {
                        if ($test) {
                            if (__first) {
                                __first = false;
                            } else {
                                __result ~= $joinKey;
                            }
                            __result ~= $expr;
                        }
                    }
                    __result;
                })).compile(context);
            }
            return (compiler.$expr ({
                auto __source = $source;
                mut typeof(({ $astType sample; sample ~ sample; })) __result;
                for ($iname, $varname in __source) {
                    if ($test) {
                        __result ~= $expr;
                    }
                }
                __result;
            })).compile(context);
        } else if (iterationMode == "first") {
            mut auto test = compiler.$expr true;
            if (auto where = where) test = where;
            mut ASTStatement setDefault = compiler.$stmt assert(__found);;
            if (auto default_ = default_) {
                setDefault = compiler.$stmt if (!__found) __result = $default_;;
            }
            auto sym = compiler.$expr ({
                auto __source = $source;
                mut auto __found = false;
                mut uninitialized $astType __result;
                for ($iname, $varname in __source) {
                    __result = $expr;
                    if ($test) { __found = true; break; }
                }
                $stmt setDefault;
                __result;
            });
            return sym.compile(context);
        } else if (iterationMode == "sum") {
            assert(!default_);
            mut auto test = compiler.$expr true;
            if (auto where = where) test = where;
            return (compiler.$expr ({
                auto __source = $source;
                mut $astType __sum = 0;
                for ($iname, $varname in __source) {
                    if ($test) { __sum += $expr; }
                }
                __sum;
            })).compile(context);
        } else if (iterationMode == "min") {
            mut auto test = compiler.$expr true;
            if (auto where = where) test = where;
            ASTSymbol init() {
                if (auto ret = default_) return ret;
                return compiler.$expr ({ assert(false); $astType __unreachable; __unreachable; });
            }
            return (compiler.$expr ({
                auto __source = $source;
                mut (:initial | $astType) __min = :initial;
                for ($iname, $varname in __source) {
                    if ($test) {
                        auto __value = $expr;
                        __min.case {
                            (:initial): __min = __value;
                            $astType current: {
                                if (__value < current)
                                    __min = __value;
                            }
                        }
                    }
                }
                __min.case(
                    (:initial): $init,
                    $astType v: v);
            })).compile(context);
        } else if (iterationMode == "max") {
            mut auto test = compiler.$expr true;
            if (auto where = where) test = where;
            // FIXME mangle with line
            ASTSymbol init2() {
                if (auto ret = default_) return ret;
                return compiler.$expr ({ import neat.runtime : assert; assert(false); $astType __unreachable; __unreachable; });
            }
            return (compiler.$expr ({
                auto __source = $source;
                mut (:initial | $astType) __max = :initial;
                for ($iname, $varname in __source) {
                    if ($test) {
                        auto __value = $expr;
                        __max.case {
                            (:initial): __max = __value;
                            $astType current: {
                                if (__value > current)
                                    __max = __value;
                            }
                        }
                    }
                }
                __max.case(
                    (:initial): $init2,
                    $astType v: v);
            })).compile(context);
        } else {
            auto i = compiler.astIdentifier(iname, this.locRange);

            assert(iterationMode == "");
            if (auto where = where) {
                return (compiler.$expr ({
                    auto __source = $source;
                    mut $astType[] __result;
                    for ($iname, $varname in __source) {
                        if ($where) __result ~= $expr;
                    }
                    __result;
                })).compile(context);
            }
            return (compiler.$expr ({
                auto __source = $source;
                auto __result = new $astType[](__source.length);
                for ($iname, $varname in __source) {
                    __result[$i] = $expr;
                }
                __result;
            })).compile(context);
        }
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTListComprehension'"); assert(false); }
}

class ListComprehension : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        if (auto args = args.instanceOf(ParseExpressionBaseArgs)) {
            args.symbol = this.parse(args.parser, args.lexicalContext);
        }
    }

    (nullable ASTSymbol | fail Error) parse(Parser parser, LexicalContext lexicalContext)
    {
        auto compiler = lexicalContext.compiler;

        parser.begin();
        auto from = parser.from?;
        if (!parser.accept("[")?) {
            parser.revert();
            return null;
        }
        mut string iterationMode;
        mut nullable ASTSymbol default_;
        mut nullable ASTSymbol joinKey;
        if (acceptIdentifier(parser, "any")?) iterationMode = "any";
        else if (acceptIdentifier(parser, "all")?) iterationMode = "all";
        else if (acceptIdentifier(parser, "first")?) iterationMode = "first";
        else if (acceptIdentifier(parser, "join")?) {
            iterationMode = "join";
            if (acceptIdentifier(parser, "with")?) {
                joinKey = compiler.parseExpression(parser, lexicalContext)?;
                parser.assert_(!!joinKey, "join key expected")?;
            }
        }
        else if (acceptIdentifier(parser, "count")?) {
            iterationMode = "count";
        }
        else if (acceptIdentifier(parser, "sum")?) {
            iterationMode = "sum";
        }
        else if (acceptIdentifier(parser, "min")?) iterationMode = "min";
        else if (acceptIdentifier(parser, "max")?) iterationMode = "max";
        mut nullable ASTSymbol expr;
        // count is expressionless
        if (iterationMode != "count") {
            expr = compiler.parseExpression(parser, lexicalContext)?;
            if (!expr) {
                parser.revert();
                return null;
            }
            if (!acceptIdentifier(parser, "for")?) {
                parser.revert();
                return null;
            }
        }
        mut string iname;
        mut string varname = parseIdentifier(parser)?;
        if (!varname.length) {
            return parser.fail("variable name expected");
        }
        if (parser.accept(",")?) {
            iname = varname;
            varname = parseIdentifier(parser)?;
            if (!varname.length) {
                return parser.fail("variable name expected");
            }
        }
        parser.expect("in")?;
        auto source = compiler.parseExpression(parser, lexicalContext)?;
        if (!source) {
            return parser.fail("source expression expected");
        }
        auto source = notNull!ASTSymbol(source);
        mut nullable ASTSymbol where;
        if (acceptIdentifier(parser, "where")?) {
            where = compiler.parseExpression(parser, lexicalContext)?;
            if (!where) {
                return parser.fail("where expression expected");
            }
        }
        if (iterationMode == "first") {
            if (acceptIdentifier(parser, "else")?) {
                default_ = compiler.parseExpression(parser, lexicalContext)?;
            }
        }
        else if (iterationMode == "min" || iterationMode == "max") {
            if (acceptIdentifier(parser, "base")?)
                default_ = compiler.parseExpression(parser, lexicalContext)?;
        }
        parser.expect("]")?;
        parser.commit();
        return new ASTListComprehension(iterationMode, expr, default_, joinKey, iname, varname, source, where, parser.to(from));
    }
}

void addListComprehensionMacro(MacroState macroState)
{
    macroState.addMacro(new ListComprehension);
}

macro(addListComprehensionMacro);
