module neat.tuples;

macro import neat.macros.listcomprehension;
macro import neat.macros.quasiquoting;

import backend.base;
import helpers;
import neat.base;
import neat.expr;
import neat.hash;
import neat.parser_base;

Expression makeTuple(Context context, Loc loc, TupleType type, Expression[] fields) {
    assert(type.members.length == fields.length);
    nullable Statement do_(Reference target) {
        mut nullable Statement init;
        for (int i, field in fields) {
            init = context.compiler.sequence2(init,
                context.compiler.move(context, new TupleMemberRef(loc, target, i), field));
        }
        return init;
    }
    return context.compiler.exprWithScratchspace(type, true, &do_).notNull;
}

class ASTTupleExpr : ASTSymbol
{
    Loc loc;

    ASTSymbol[] members;

    this(this.loc, this.members) { }

    override Expression compile(Context context) {
        Expression[] fields = [member.compile(context).beExpressionImplCall(context, loc) for member in members];
        auto type = new TupleType([("", member.type) for member in fields]);

        return makeTuple(context, this.loc, type, fields);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto members = [a.quote(quoter) for a in this.members];
        with (quoter.compiler) return astNewExpression(
            astIdentifier("ASTTupleExpr", __HERE__), [
                quoter.quoteLoc(this.loc),
                astArrayLiteral(members, __HERE__)], __HERE__);
    }
}

nullable ASTSymbol parseTupleExpression(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto loc = parser.loc;
    if (!parser.accept("(")) {
        parser.revert;
        return null;
    }
    mut ASTSymbol[] members;
    while (!parser.accept(")"))
    {
        if (members.length && !parser.accept(",")) {
            // be a bit lenient for (bla bla)
            if (members.length == 1) {
                parser.revert;
                return null;
            }
            auto loc = parser.loc;
            loc.assert2s(false, "tuple: ',' expected");
        }
        if (auto member = lexicalContext.compiler.parseExpression(parser, lexicalContext)) {
            members ~= member;
        } else {
            // (bla bla) still
            if (members.length <= 1) {
                parser.revert;
                return null;
            }
            // FIXME parser.loc.assert2s
            auto loc = parser.loc;
            loc.assert2s(false, "tuple: member expected");
        }
    }
    // (bla) is not a tuple, it's a paren expression
    if (members.length == 1) {
        parser.revert;
        return null;
    }
    parser.commit;
    return new ASTTupleExpr(loc, members);
}

class TupleMemberExpr : Expression
{
    Loc loc;

    Expression tuple;

    int index;

    this(this.loc, this.tuple, this.index) {
        if (auto tuple = this.tuple.type.instanceOf(TupleType)) {
            loc.assert2s(this.index >= 0 && this.index < tuple.members.length, "tuple index out of range");
            this.type = tuple.members[index].type;
        } else {
            // This should never happen!
            // TODO index overload on types
            loc.assert2s(false, "tuple index on non-tuple type");
        }
    }

    override int emit(Generator output) {
        // TODO free unused fields
        auto tuple = this.tuple.emit(output);
        return output.fun.field(this.tuple.type.emit(output.platform), tuple, index);
    }
    override ExprInfo info() {
        return tuple.info;
    }
    override void hash(Hash hash) {
        hash.adds("tuple_member");
        hash.addl(index);
        tuple.hash(hash);
    }
}

// TODO merge with TupleMemberExpression somehow... mixin? static if (is(T == Reference))?
class TupleMemberRef : Reference
{
    Loc loc;

    Reference tuple;

    int index;

    this(this.loc, this.tuple, this.index) {
        // FIXME we should check this earlier
        if (auto tuple = this.tuple.type.instanceOf(TupleType)) {
            loc.assert2s(this.index >= 0 && this.index < tuple.members.length, "tuple index out of range");
            this.type = tuple.members[index].type;
        } else {
            // This should never happen!
            // TODO index overload on types
            loc.assert2s(false, "tuple index on non-tuple type");
        }
    }

    override int emit(Generator output) {
        // TODO free unused fields
        auto tuple = this.tuple.emit(output);
        return output.fun.field(this.tuple.type.emit(output.platform), tuple, index);
    }
    override ExprInfo info() {
        return tuple.info;
    }
    override int emitLocation(Generator output) {
        auto tupleLocation = this.tuple.instanceOf(Reference).emitLocation(output);
        return output.fun.fieldOffset(this.tuple.type.emit(output.platform), tupleLocation, index);
    }
    override void hash(Hash hash) {
        hash.adds("tuple_member_ref");
        hash.addl(index);
        tuple.hash(hash);
    }
}

class TupleType : Type
{
    (string name, Type type)[] members;

    this(this.members) {
        this.zeroInitializable = [
            all a.type.zeroInitializable for a in this.members];
    }

    override BackendType emit(Platform platform) {
        return new BackendStructType([member.type.emit(platform) for member in members]);
    }

    override bool same(Type type) {
        if (auto other = type.instanceOf(TupleType)) {
            return other.members.length == members.length &&
                [all member.type.same(other.members[i].type) for i, member in members];
        }
        return false;
    }

    override string repr() {
        return "(" ~ [join ", " member.type.repr for member in members] ~ ")";
    }

    override string mangle() {
        return "tuple_" ~ [join "_" member.type.mangle for member in members];
    }

    override nullable Symbol accessMember(Loc loc, Context context, nullable Expression base, string field, Protection _)
    {
        auto base <- base;
        int index = [first cast(int) i for i, member in members where member.name == field else -1];
        // TODO return (Symbol | LookupError);
        if (index == -1) return null;
        // loc.assert2s(index != -1, "no such tuple field: " ~ field);
        if (auto ref_ = base.instanceOf(Reference)) {
            return new TupleMemberRef(loc, ref_, index);
        }
        return new TupleMemberExpr(loc, base, index);
    }

    // basically just like struct
    override nullable Statement copyInto(Context context, Reference target, Expression source)
    {
        nullable Statement do1(Expression targetptr) {
            auto target = context.compiler.dereference(targetptr);
            nullable Statement do2(Expression source) {
                mut Statement[] assigns;
                mut bool anySpecialAssignments;
                for (int i, member in members) {
                    auto targetField = new TupleMemberRef(__HERE__, target, i);
                    auto sourceField = new TupleMemberExpr(__HERE__, source, i);
                    Statement copyInto() {
                        if (auto copyInto = member.type.copyInto(context, targetField, sourceField)) {
                            anySpecialAssignments = true;
                            return copyInto;
                        }
                        return context.compiler.assignStatement(targetField, sourceField);
                    }
                    assigns ~= copyInto;
                }
                if (!anySpecialAssignments) return null;
                return context.compiler.sequenceStatement(assigns);
            }
            return context.compiler.stmtWithTemporaryExpr(source, &do2);
        }
        return context.compiler.stmtWithTemporaryExpr(context.compiler.reference(target), &do1);
    }

    // also like struct
    override nullable Statement endLifetime(Context context, Reference ref_)
    {
        auto compiler = context.compiler;

        nullable Statement doRef(Expression refptr) {
            auto context = context.withNamespace(
                compiler.exprAlias(context.namespace, "ref_", compiler.dereference(refptr)));

            mut ASTStatement[] destructors;
            for (i in 0 .. members.length) {
                auto member = new TupleMemberRef(__HERE__, ref_, cast(int) i);
                auto destroy = members[i].type.endLifetime(context, member);
                auto index = compiler.astIntLiteral(cast(int) i, __HERE__);
                if (destroy) {
                    destructors ~= compiler.$stmt __destroy(ref_[$index]);;
                }
            }
            if (!destructors.length) return null;
            ASTStatement body_ = compiler.astSequence(destructors, __HERE__);

            return body_.compile(context).statement;
        }
        return compiler.stmtWithTemporaryExpr(compiler.reference(ref_), &doRef);
    }

    override nullable Expression implicitConvertTo(Context context, Expression source, Type target)
    {
        auto tupleTargetType = target.instanceOf(TupleType);
        if (!tupleTargetType || tupleTargetType.members.length != members.length)
            return null;
        auto tupleTargetType = tupleTargetType.notNull;

        nullable Expression do_(Expression source) {
            auto sourceMembers = [new TupleMemberExpr(__HERE__, source, cast(int) i) for i, _ in members];
            auto convFields = [
                context.compiler.implicitConvertTo(context, member, tupleTargetType.members[i].type)
                for i, member in sourceMembers];

            if ([any !a for a in convFields]) return null;

            return makeTuple(
                context, __HERE__, tupleTargetType, [a.notNull for a in convFields]);
        }
        return context.compiler.exprWithTemporaryExpr(source, &do_);
    }

    override nullable Expression index(Context context, Expression base, Expression index, Loc loc) {
        // TODO refcounting
        auto indexExpr = index.instanceOf(IntLiteral);
        loc.assert2s(!!indexExpr, "int literal expected for tuple access");
        return new TupleMemberExpr(loc, base, indexExpr.value);
    }

    override nullable Expression binaryOp(Context context, string op, Expression lhs, Expression rhs, Loc loc)
    {
        if (op == "==") {
            mut auto rhs = rhs;
            if (auto converted = context.compiler.implicitConvertTo(context, rhs, lhs.type)) {
                rhs = converted;
            } else {
                return null;
            }
            nullable Expression do1(Expression lhs) {
                nullable Expression do2(Expression rhs) {
                    mut auto result = context.compiler.boolLiteral(true);
                    for (i, member in members) {
                        auto lhsMember = new TupleMemberExpr(loc, lhs, cast(int) i);
                        auto rhsMember = new TupleMemberExpr(loc, rhs, cast(int) i);
                        // FIXME overload in expr or Compiler instead of laundering through ASTBinaryOp
                        auto memberEq = context.compiler.astBinaryOp(
                            "==",
                            new ASTSymbolHelper(lhsMember),
                            new ASTSymbolHelper(rhsMember), __HERE__);
                        result = context.compiler.astBinaryOp(
                            "&&",
                            new ASTSymbolHelper(result),
                            memberEq, __HERE__).compile(context).beExpression;
                    }

                    return result;
                }
                return context.compiler.exprWithTemporaryExpr(rhs, &do2);
            }
            return context.compiler.exprWithTemporaryExpr(lhs, &do1);
        }
        return null;
    }

    override void hash(Hash hash) {
        hash.adds("tuple");
        hash.addl(this.members.length);
        [member.type.hash(hash) for member in this.members];
    }
}

/**
 * Tuple with pending member type
 */
class PendingTuple : PendingSymbol
{
    Loc loc;

    (string name, (PendingSymbol | Type) sym)[] members;

    this(this.loc, this.members) { }

    override Symbol resolve() {
        mut (string name, Type)[] result;
        for (int i, entry in members) {
            string name = entry.name;
            auto sym = entry.sym;
            result ~= (name, sym.case(
                Type t: t,
                PendingSymbol s: beType(this.loc, s.resolve)
            ));
        }
        return new TupleType(result);
    }
}

class ASTTupleType : ASTSymbol
{
    Loc loc;

    (string name, ASTSymbol type)[] members;

    this(this.loc, this.members) { }

    override Symbol compile(Context context) {
        Symbol[] syms = [member.type.compile(context) for member in this.members];
        if ([any s.instanceOf(PendingSymbol) for s in syms]) {
            mut (string name, (PendingSymbol | Type) sym)[] result;
            for (i, member in this.members) {
                if (auto ps = syms[i].instanceOf(PendingSymbol))
                    result ~= (member.name, ps);
                else
                    result ~= (member.name, beType(this.loc, syms[i]));
            }
            return new PendingTuple(this.loc, result);
        }
        return new TupleType([
            (member.name, beType(this.loc, syms[i]))
            for i, member in this.members]);
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol quoteMember(typeof(members[0]) member) {
            with (quoter.compiler) return astTupleLiteral([
                astStringLiteral(member.name, __HERE__),
                member.type.quote(quoter)], __HERE__);
        }
        auto members = [a.quoteMember for a in this.members];
        with (quoter.compiler) return astNewExpression(
            astIdentifier("ASTTupleType", __HERE__), [
                quoter.quoteLoc(this.loc),
                astArrayLiteral(members, __HERE__)], __HERE__);
    }
}
