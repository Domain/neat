module neat.base;

import backend.base;
import helpers;
import neat.hash;
import neat.parser_base;

void assert2s(int test, string msg) { if (!test) { print(msg); exit(1); } }
void assert2s2(int test, string a, string b) { if (!test) { print(a ~ b); exit(1); } }
void assert2s3(int test, string a, string b, string c) { if (!test) { print(a ~ b ~ c); exit(1); } }
void assert2s4(int test, string a, string b, string c, string d) {
    if (!test) { print(a ~ b ~ c ~ d); exit(1); } }
void assert2s5(int test, string a, string b, string c, string d, string e) {
    if (!test) { print(a ~ b ~ c ~ d ~ e); exit(1); } }

// something that can be referenced by a name
abstract class Symbol
{
    string repr() {
        // TODO this.__classname
        return "TODO Symbol.repr";
    }
}

/**
 * A namespace is a lexical environment that supports identifier lookup.
 * Note that this means "foo", not "a.foo".
 */
abstract class Namespace
{
    nullable Namespace parent; // lexical parent

    bool isContextScope;

    this(this.parent, this.isContextScope) { }

    /**
     * name:    The name being looked up.
     *
     * context: The compiler context originating the lookup.
     *          The namespace in context is used as the provenance of the lookup,
     *          meaning it decides whether private members may be read.
     *
     * loc:     The location of the symbol triggering the lookup.
     */
    abstract (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange);

    string mangle() { return this.parent.mangle; }
}

/// Something that 'return' returns from.
interface Returnable
{
    /// We want to return `proposed`, so give me a type you can be happy with.
    Type mergeReturnType(Type proposed, bool failProp);
}

/// Something that variables can be declared in.
interface Declarable
{
    LatentVariable declare(string name, Type type, bool mut, bool borrowed);
}

// variable without stackframe
interface LatentVariable
{
    Expression localStackFrame(CompilerBase compiler);

    Reference access(CompilerBase compiler, Expression frame);
}

class ASTImportStatement
{
    (:normal, string name, string pak | :macro_, ASTModuleBase module_) target;

    bool isMacroImport;

    string[] symbols;

    LocRange locRange;

    this(this.target, this.isMacroImport, this.symbols, this.locRange) { }

    string repr(string pak) {
        this.target.case {
            (:normal, string name, string importPak): {
                if (importPak.length) return "import package($importPak).$name";
                return "import package($pak).$name";
            }
            (:macro_, ASTModuleBase module_): {
                return "macro import package($pak) $(module_.mangledName)";
            }
        }
    }
}

// bleh cycle
abstract class ASTModuleBase
{
    string mangledName;

    abstract void addEntry(Protection protection, (ASTExternFunctionBase | ASTSymbol) target);

    abstract void addAliasDecl(string name, Protection protection, ASTSymbol target);

    abstract nullable ASTSymbol getSymbolAlias(string name);
}

abstract class ASTExternFunctionBase
{
    string name;

    abstract string repr();
}

abstract class LexicalContext
{
    CompilerBase compiler;

    Package pak;

    MacroState macroState;

    // break an annoying dependency cycle
    abstract (ASTModuleBase | fail Error) resolveImport(ASTImportStatement importStmt);

    this(this.compiler, this.pak, this.macroState) { }
}

/**
 * Delineates a region of control flow in which 'break;' and 'continue;' may be used.
 */
abstract class LoopScope : Namespace
{
    abstract (Statement | fail Error) breakFrom(Context context);
    abstract (Statement | fail Error) continueFrom(Context context);
    // purely a marker
    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange) {
        return this.parent.lookup(name, context, locRange);
    }
}

// helper for binding values for stuff like compiler.$stmt
class SymbolAlias : Namespace
{
    string name;

    Symbol value;

    this(this.parent, this.name, this.value) { this.isContextScope = parent.isContextScope; }

    override (nullable Symbol | fail Error) lookup(string name, Context context, LocRange locRange)
    {
        if (this.name == name) {
            if (auto latent = this.value.instanceOf(LatentSymbol)) {
                return latent.resolve(context);
            }
            return value;
        }
        if (this.parent) return this.parent.lookup(name, context, locRange);
        return null;
    }
}

template findParent(T) {
    nullable T findParent(nullable Namespace namespace) {
        if (auto namespace = namespace) {
            if (auto hit = namespace.instanceOf(T)) return hit;
            if (auto parent = namespace.parent) return findParent!T(parent);
        }
        return null;
    }
}

abstract class ASTSymbol
{
    LocRange locRange;

    abstract (Symbol | fail Error) compile(Context context);

    ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTSymbol'! this=$(cast(size_t) this)"); assert(false); }

    // TODO this.classname
    string repr() { return "TODO repr(ASTSymbol): $(locRange.repr)"; }
}

abstract class ASTMemberBase : ASTSymbol
{
    ASTSymbol base;

    string member;

    this(this.base, this.member, this.locRange) { }

    override string repr() {
        return "$(this.base.repr).$member";
    }
}

abstract class Statement
{
    abstract void emit(Generator output);
    abstract void hash(Hash hash);
    string repr() { return "TODO Statement.repr"; }
}

abstract class Type : Symbol
{
    abstract BackendType emit(Platform platform);
    abstract bool same(Type type);
    string mangle() {
        print("Don't know how to mangle $(repr)");
        assert(false);
    }
    abstract void hash(Hash hash);

    bool zeroInitializable;

    bool hasElaborateCopyConstructor;

    nullable Expression implicitConvertFrom(Context context, Expression source)
    {
        return null;
    }

    // TODO take Loc
    nullable Expression implicitConvertTo(Context context, Expression source, Type target)
    {
        return null;
    }

    (nullable Expression | fail Error) truthy(Context context, Expression expr, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to create a copy of the expression.
     * The returned expression will count as a new reference.
     */
    (Expression | fail Error) copy(Context context, Expression source)
    {
        return source;
    }

    /**
     * Called when a scoped expression goes out of scope.
     */
    nullable Statement endLifetime(Context context, Expression value)
    {
        return null;
    }

    /**
     * When looking up a nember in this type at scope 'namespace',
     * what is the maximum protection level of the member where
     * lookup will succeed?
     */
    Protection protectionAt(Namespace namespace) {
        // all are visible by default.
        return Protection.private_;
    }

    /**
     * Called to resolve 'value.field'.
     * If 'base' is null, this indicates a static field access, 'Type.field'.
     */
    (nullable Symbol | fail Error) accessMember(
        Context context, nullable Expression base, string field, Protection protection, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `value.field(args)`.
     */
    (nullable Expression | fail Error) callMember(
        Context context, nullable Expression base, string field, ASTArgument[] args, Protection protection, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `base[index]`.
     */
    (nullable Expression | fail Error) index(Context context, Expression base, Expression index, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve `base[index] = value`.
     */
    (nullable Statement | fail Error) indexAssignment(
        Context context, Expression base, Expression index, Expression value, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve 'lhs op rhs' where op is a binary operator.
     */
    (nullable Expression | fail Error) binaryOp(Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        return null;
    }

    /**
     * Called to resolve 'Type(a, b, c)'.
     *
     * TODO: rename to callType
     */
    (nullable Expression | fail Error) call(Context context, LocRange locRange, ASTArgument[] args)
    {
        return null;
    }

    /**
     * Called to resolve `expr(a, b, c)`, where `typeof(expr)` is `Type`.
     *
     * TODO: rename to call
     */
    (nullable Expression | fail Error) callExpr(Context context, LocRange locRange, Expression expr, ASTArgument[] args)
    {
        return null;
    }
}

/// Copy the source expression.
(Expression | fail Error) copy(Expression source, Context context) {
    return source.type.copy(context, source)?;
}

/// Take ownership of the source expression.
(Expression | fail Error) take(Expression source, Context context) {
    if (source.info.lifetime == Lifetime.gifted || source.info.lifetime == Lifetime.permanent) {
        return source;
    }
    return source.copy(context)?;
}

class Void : Type
{
    this() {
        // because it has no size, it needs no initializer.
        this.zeroInitializable = true;
    }

    override BackendType emit(Platform platform) { return platform.void_; }

    override bool same(Type other) { return !!other.instanceOf(Void); }

    override string repr() { return "void"; }

    override string mangle() { return "void"; }

    override void hash(Hash hash) { hash.adds("void"); }
}

class Pointer : Type
{
    Type target;

    this(this.target) {
        // TODO nullable qualifier
        this.zeroInitializable = true;
    }

    override BackendType emit(Platform platform)
    {
        return new BackendPointerType(this.target.emit(platform));
    }

    override bool same(Type other)
    {
        if (auto otherPtr = other.instanceOf(Pointer))
            return this.target.same(otherPtr.target);
        return false;
    }

    override string repr() { return this.target.repr ~ "*"; }

    override string mangle() { return "ptr_" ~ this.target.mangle; }

    override void hash(Hash hash) { hash.adds("pointer"); target.hash(hash); }
}

class NoopStatement : Statement
{
    this() { }

    override void emit(Generator generator)
    {
    }

    override void hash(Hash hash) { hash.adds("NoopStatement"); }
}

class Generator
{
    BackendModule mod;

    nullable BackendFunction fun;

    Platform platform;

    int frameReg;

    string[] extraLibs; // from pragma(lib)

    this(this.platform, this.mod)
    {
        this.fun = null;
    }

    bool once(string name)
    {
        return this.mod.once(name);
    }

    void addLibrary(string lib) {
        this.extraLibs ~= lib;
    }
}

/**
 * Gifted: An expression with an unmanaged lifetime that we must take over.
 * Ephemeral: An expression that will be freed at some indeterminate point.
 * Lexical: An expression that will be freed at the earliest when the scope ends.
 * Permanent: An expression that will never be freed, or that does not participate in rc.
 *
 * Examples:
 * - unique: `new Class()`
 * - ephemeral: `foo.(that)`
 * - lexical: `void foo(Class obj) { }` or `Class obj;`
 * - permanent: `"string"`
 */
enum Lifetime
{
    gifted,
    ephemeral,
    lexical,
    permanent,
}

struct ExprInfo
{
    Lifetime lifetime;

    string repr() {
        mut string ret;
        if (lifetime == Lifetime.gifted) ret ~= "gifted";
        else if (lifetime == Lifetime.ephemeral) ret ~= "ephemeral";
        else if (lifetime == Lifetime.lexical) ret ~= "lexical";
        else if (lifetime == Lifetime.permanent) ret ~= "permanent";
        else assert(false);
        return ret;
    }
}

abstract class Expression : Symbol
{
    Type type;
    ExprInfo info;
    abstract int emit(Generator output);
    abstract void hash(Hash hash);
}

(Expression | fail Error) beExpression(Symbol symbol, LocRange locRange)
{
    if (auto symbolIdent = symbol.instanceOf(SymbolIdentifier))
        return new SymbolIdentifierExpression(symbolIdent.name);
    if (auto expr = symbol.instanceOf(Expression))
        return expr;
    return locRange.fail("expression expected");
}

(Type | fail Error) beType(Symbol symbol, LocRange locRange)
{
    if (auto type = symbol.instanceOf(Type))
        return type;
    if (auto symbolIdent = symbol.instanceOf(SymbolIdentifier))
        return new SymbolIdentifierType(symbolIdent.name);
    return locRange.fail("type expected");
}

(Type | fail Error) beType2(Symbol symbol, LocRange locRange)
{
    return beType(symbol, locRange);
}

abstract class Reference : Expression
{
    bool mutable;
    abstract int emitLocation(Generator output);
}

class PointerCast : Expression
{
    Type target;

    Expression value;

    this(this.target, this.value) {
        this.type = this.target;
        assert(!!target);
        assert(!!value);
        this.info = this.value.info;
    }

    override int emit(Generator output)
    {
        int reg = this.value.emit(output);
        return output.fun.bitcast(reg, this.target.emit(output.platform));
    }

    override void hash(Hash hash) { hash.adds("ptrcast"); target.hash(hash); value.hash(hash); }

    override string repr() { return "cast($(target.repr)) $(value.repr)"; }
}

class NullExpr : Expression
{
    this(this.type) { this.info = ExprInfo(Lifetime.permanent); }

    override int emit(Generator generator)
    {
        return generator.fun.zeroLiteral(this.type.emit(generator.platform));
    }
    override void hash(Hash hash) { hash.adds("NullExpr"); type.hash(hash); }
    override string repr() { return "null"; }
}

/**
 * `SymbolIdentifier` is the core of the :name symbol type impl.
 * Because :foo a = :foo; and we can't double inherit,
 * `SymbolIdentifier` has special handling in `beType` and `beExpression`.
 */
class SymbolIdentifier : Symbol
{
    string name;
    this(this.name) { }
}

class SymbolIdentifierType : Type
{
    string name;
    this(this.name) { }
    override BackendType emit(Platform platform) { return new BackendVoidType; }
    override bool same(Type type) {
        if (auto other = type.instanceOf(SymbolIdentifierType))
            return other.name == this.name;
        return false;
    }
    override string repr() { return ":" ~ this.name; }
    override string mangle() { return "symbol_" ~ name; }
    override void hash(Hash hash) { hash.adds("SymbolType"); hash.adds(name); }
    override (nullable Expression | fail Error) binaryOp(
        Context context, string op, Expression lhs, Expression rhs, LocRange locRange)
    {
        if (op == "==" && rhs.type.same(lhs.type)) {
            return context.compiler.boolLiteral(true);
        }
        return null;
    }
}

class SymbolIdentifierExpression : Expression
{
    string name;
    this(this.name) { this.type = new SymbolIdentifierType(name); this.info = ExprInfo(Lifetime.permanent); }
    override int emit(Generator output) { return output.fun.voidLiteral; }
    override void hash(Hash hash) { hash.adds("SymbolExpr"); hash.adds(name); }
}

/*
 * Stackoverflow insists that "parameters" are the stuff in the function parameter list,
 * and "arguments" are the values you pass to a function.
 *
 * Fine by me.
 *
 * We could separate "declaration parameters" and "definition parameters."
 * For instance, extern(C) declarations are only interesting for generating a call,
 * and will never generate a function body. However, usually when meaningful information
 * is used to customize the define-site, this is also interesting for the call-site,
 * especially with regards to lifetime. As such, it's probably good there is only one type.
 */
struct Parameter
{
    bool isThisAssignment;

    string name;

    bool mutable;

    Type type;

    nullable Expression defaultValue;

    static Parameter fromType(Type type) {
        return Parameter(false, "", false, type, null);
    }

    static Parameter simple(string name, Type type) {
        return Parameter(false, name, false, type, null);
    }
}

struct ASTParameter
{
    string name;

    bool mutable;

    ASTSymbol type;

    nullable ASTSymbol defaultValue;

    LocRange locRange;
}

// this(this.name)
struct ASTThisAssignment
{
    string name;

    LocRange locRange;
}

/**
 * A value being passed to a callable parameter.
 */
struct Argument
{
    Expression value;

    string name;
}

struct ASTArgument
{
    ASTSymbol sym;

    string name;

    LocRange locRange;
}

class FunctionDeclaration : Symbol
{
    string name;

    Type ret;

    Parameter[] params;

    bool variadic;

    nullable Type contextType; // must be a pointer

    this(this.name, this.ret, this.params)
    {
        this.contextType = null;
    }

    size_t numArgs()
    {
        mut size_t ret = this.params.length;
        if (!!contextType) ret += 1;
        return ret;
    }

    string mangle() { return this.name; } // TODO extern

    void declare(Generator generator)
    {
        if (generator.mod.declared(this.mangle))
            return;

        Type voidp = new Pointer(new Void);
        mut int extra = 0;
        if (this.contextType) extra = 1;

        auto paramTypes = new BackendType[](numArgs);
        if (this.contextType) paramTypes[0] = voidp.emit(generator.platform);
        for (i, param in this.params)
            paramTypes[extra + i] = param.type.emit(generator.platform);

        generator.mod.declare(
            this.mangle,
            this.ret.emit(generator.platform),
            paramTypes,
            variadic=this.variadic
        );
    }

    override string repr()
    {
        return this.name;
    }
}

/**
 * This is in base because it's circular with Context.
 */
class MacroState
{
    Macro[] macros;

    MacroState[] imports;

    this() { }

    MacroState dup() {
        auto newState = new MacroState;
        newState.macros = new Macro[](this.macros.length);
        for (i, macro_ in this.macros)
            newState.macros[i] = macro_;
        newState.imports = new MacroState[](this.imports.length);
        for (i, import_ in this.imports)
            newState.imports[i] = import_;
        return newState;
    }

    void applyMacro(MacroArgs args) {
        this.applyMacroExported(args);
        if (args.done) return;
        for (import_ in this.imports) {
            import_.applyMacroExported(args);
            if (args.done) return;
        }
    }

    void applyMacroExported(MacroArgs args) {
        for (macro_ in this.macros) {
            macro_.apply(args);
            if (args.done) return;
        }
    }

    void addImport(MacroState target) {
        this.imports ~= target;
    }

    void addMacro(Macro macro_) {
        this.macros ~= macro_;
    }
}

// Something that should be cleaned up on unwind.
abstract class DeclarationHolder : Namespace
{
    abstract bool freeOnExit();

    abstract Reference accessDecl(CompilerBase compiler);

    Reference accessDecl2(CompilerBase compiler) { return accessDecl(compiler); }
}

// Namespace with unwind side effect, such as onExit call.
// Evaluated before declaration cleanup.
interface Unwindable
{
    (nullable Statement | fail Error) unwind(Context context);
}

// cycle breaker helper: needed for CompilerBase
abstract class ModuleBase : Namespace
{
    string name;

    string mangledName;

    abstract void addImport(ModuleBase module_, bool public_, string[] symbols);

    abstract void addModuleDependency(ModuleBase module_);

    abstract (void | fail Error) compile(Context context);

    // Add symbol to list of anonymous symbols that will be emitted.
    abstract void track((Symbol | FinishedSymbol) sym);
}

alias ExtForVarDecl = ((:auto_ | ASTSymbol | :none) type, LocRange locRange, string name);

ASTSymbol quoteExtForVarDecl(ExtForVarDecl decl, Quoter quoter) {
    mut ASTSymbol[] tupleArgs;
    tupleArgs ~= decl.type.case(
            (:auto_): new ASTSymbolIdentifier("auto_", __RANGE__),
            (:none): new ASTSymbolIdentifier("none", __RANGE__),
            ASTSymbol sym: sym.quote(quoter));
    tupleArgs ~= quoter.quoteLocRange(decl.locRange);
    // auto $foo => (..., foo)
    if (decl.name.length > 0 && decl.name[0 .. 1] == "\$") {
        tupleArgs ~= quoter.compiler.astIdentifier(decl.name[1 .. $], __RANGE__);
    } else {
        tupleArgs ~= quoter.compiler.astStringLiteral(decl.name, __RANGE__);
    }

    return quoter.compiler.astTupleLiteral(tupleArgs, __RANGE__);
}

/**
 * Helper class used to break dependency loops between neat.base, macros and the rest of the compiler.
 */
abstract class CompilerBase
{
    WorkPoolBase workPool;

    // for neat.macros.cimport
    string[] cFlags;

    // parser
    abstract (nullable ASTSymbol | fail Error) parseExpression(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTSymbol | fail Error) parseExpressionLeaf(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTSymbol | fail Error) parseType(
        Parser parser, LexicalContext lexicalContext);

    abstract (ASTStatement | fail Error) parseStatement(
        Parser parser, LexicalContext lexicalContext);

    abstract (nullable ASTDeclaration | fail Error) parseDeclaration(
        Parser parser, LexicalContext lexicalContext);

    abstract (ASTSymbol | fail Error) parseStringLiteral(
        Parser parser, LexicalContext lexicalContext, string endMarker, LocRange from);

    abstract ASTStatement astExpressionStmt(ASTSymbol expr, LocRange locRange);

    abstract ASTStatement astScope(ASTStatement[] stmts, LocRange locRange);

    // sequence of statements that don't open a new scope
    abstract ASTStatement astSequence(ASTStatement[] stmts, LocRange locRange);

    abstract ASTStatement astIf((ASTSymbol | ASTStatement) test, ASTStatement then, nullable ASTStatement else_, LocRange locRange);

    abstract ASTStatement astForLoop(
        ASTStatement init, ASTSymbol test, ASTStatement step, ASTStatement body_, LocRange locRange);

    abstract ASTStatement astExtForLoop(
        ASTSymbol source, ExtForVarDecl var1, (ExtForVarDecl | :none) var2, ASTStatement body_, LocRange locRange);

    abstract ASTStatement astAssign(ASTSymbol target, ASTSymbol source, LocRange locRange);

    // a += 2
    abstract ASTStatement astOpAssign(ASTSymbol left, string op, ASTSymbol right, LocRange locRange);

    abstract ASTStatement astDeclareVar(
        string name, bool mutable, bool uninitialized, nullable ASTSymbol initial, LocRange locRange);

    abstract ASTStatement astDeclareVarExtract(
        string name, bool mutable, bool infer, nullable ASTSymbol type, ASTSymbol source, LocRange locRange);

    // initial is optional
    abstract ASTStatement astDeclareTypedVar(
        string name, bool mutable, bool uninitialized, ASTSymbol type, nullable ASTSymbol initial, LocRange locRange);

    abstract ASTStatement astReturn(ASTSymbol value, bool failProp, LocRange locRange);

    abstract ASTStatement astDeclarationStatement(ASTDeclaration target, LocRange locRange);

    abstract ASTSymbol astBinaryOp(string op, ASTSymbol left, ASTSymbol right, LocRange locRange);

    abstract ASTSymbol astCast(ASTSymbol target, ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astIndex(ASTSymbol base, ASTSymbol index, LocRange locRange);

    abstract ASTSymbol astMember(ASTSymbol base, string name, LocRange locRange);

    abstract ASTSymbol astReference(ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astDereference(ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astIntLiteral(int value, LocRange locRange);

    abstract ASTSymbol astLongLiteral(long value, LocRange locRange);

    abstract ASTSymbol astStringLiteral(string text, LocRange locRange);

    ASTSymbol astBoolLiteral(bool value, LocRange locRange) {
        if (value) return astIdentifier("true", locRange);
        else return astIdentifier("false", locRange);
    }

    ASTSymbol astArrayLiteral(ASTSymbol[] values, LocRange locRange) {
        return astArrayLiteralTypeHint(null, values, locRange);
    }

    abstract ASTSymbol astArrayLiteralTypeHint(nullable ASTSymbol typeHint, ASTSymbol[] values, LocRange locRange);

    abstract ASTSymbol astTupleLiteral(ASTSymbol[] entries, LocRange locRange);

    abstract ASTSymbol astArraySlice(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, LocRange locRange);

    // a .. b
    abstract ASTSymbol astIota(ASTSymbol from, ASTSymbol to, LocRange locRange);

    abstract ASTSymbol astVoidLiteral(LocRange locRange);

    abstract ASTSymbol astIdentifier(string name, LocRange locRange);

    abstract ASTSymbol astNegation(ASTSymbol value, LocRange locRange);

    abstract ASTSymbol astCall(ASTSymbol target, ASTSymbol[] args, LocRange locRange);

    abstract ASTSymbol astNewExpression(ASTSymbol type, (ASTSymbol[] | ASTArgument[]) args, LocRange locRange);

    abstract ASTSymbol astDestroy(ASTSymbol target, LocRange locRange);

    abstract ASTSymbol astStatementExpression(ASTStatement[] statements, ASTSymbol expr, LocRange locRange);

    abstract ASTSymbol astArray(ASTSymbol elementType, LocRange locRange);

    abstract ASTSymbol astBasicType(string name, LocRange locRange);

    abstract ASTSymbol astTypeOf(ASTSymbol symbol, LocRange locRange);

    abstract ASTSymbol astPointer(ASTSymbol target, LocRange locRange);

    abstract ASTSymbol astTupleType((string name, ASTSymbol type)[] members, LocRange locRange);

    abstract ASTSymbol astNullable(ASTSymbol next, bool nullify, LocRange locRange);

    abstract ASTExternFunctionBase astExternFunction(
        string name, ASTSymbol ret, ASTParameter[] params, bool variadic, LocRange retLocRange);

    abstract ASTModuleBase astModule(
        string name, Package pak, MacroState macroState, LocRange locRange, nullable ASTModuleBase parent);

    abstract ASTDeclaration astImport(ASTImportStatement import_, ASTModuleBase module_, LocRange locRange);

    abstract ASTDeclaration astImport2(string name, string pak, string[] symbols, LocRange locRange);

    abstract ASTModuleBase resolveImport(string pak, ASTImportStatement import_, LocRange locRange);

    // expressions and statements
    abstract nullable Expression implicitConvertTo(Context context, Expression from, Type to);

    abstract (Expression | fail Error) binaryOp(
        string op, Context context, Expression left, Expression right, LocRange locRange);

    abstract Expression intLiteral(int value);

    abstract Expression wordLiteral(Platform platform, long value);

    abstract Expression boolLiteral(bool value);

    abstract Expression voidLiteral();

    abstract (Expression | fail Error) truthy(Context context, Expression value, LocRange locRange);

    abstract Expression castTo(Type target, Expression source);

    abstract Expression stringLiteral(string value);

    abstract Reference stackFrame(Type type);

    abstract (nullable Expression | fail Error) call(
        Context context, ASTSymbol target, ASTArgument[] args, LocRange locRange, bool isImplCall);

    (nullable Expression | fail Error) simpleCall(
        Context context, Symbol sym, Expression[] args, LocRange locRange)
    {
        mut ASTArgument[] astArgs;
        for (arg in args)
            astArgs ~= ASTArgument(new ASTSymbolHelper(arg), "", locRange);
        return call(context, new ASTSymbolHelper(sym), astArgs, locRange, false);
    }

    abstract Expression mkCall(Symbol target, Expression[] args, LocRange locRange);

    abstract Expression pointerOffset(Expression pointer, Expression offset);

    // evaluate first `statement`, then `expression`.
    abstract Expression statementExpression(Statement statement, Expression expression);

    abstract Reference dereference(Expression value);

    abstract Expression reference(Reference ref_);

    abstract Expression wrap(nullable Statement before, Expression value, nullable Statement after);

    // wrap(), allowing References
    abstract Expression wrapRef(nullable Statement before, Expression value, nullable Statement after);

    // Call dg with expr or copy of expr.
    // If expr was a gift, it is freed after.
    abstract (Expression | fail Error) consume(
        Context context, Expression expr, (Expression | fail Error) delegate(Expression) dg);

    abstract Statement consumeStmt(Context context, Expression expr, Statement delegate(Expression) dg);

    /// Call dg with owned temp of expr.
    /// If expr was a gift, it is freed after.
    ///
    /// Set `mayUnwind` to true if `dg()` may unwind.
    /// in that case, borrowed `expr` must be copied.
    abstract (nullable Expression | fail Error) consumeTemporary(
            Context context, bool allowRefReturn, Expression expr,
            (nullable Expression | fail Error) delegate(Expression) dg);

    abstract (nullable Statement | fail Error) consumeTemporaryStmt(
        Context context, Expression expr, (nullable Statement | fail Error) delegate(Reference) dg);

    abstract (nullable Symbol | fail Error) accessMember(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined);

    abstract Reference structMemberReference(Reference base, int index);

    abstract (nullable Symbol | fail Error) accessMemberWithLifetime(
        Context context, Symbol base, string member, LocRange locRange, bool allowUndefined);

    // look up name following the namespace in context
    abstract (nullable Symbol | fail Error) lookup(Context context, LocRange locRange, string name);

    abstract Statement assignStatement(Reference target, Expression value);

    abstract Statement sequence(Statement first, nullable Statement second);

    Statement sequence2(nullable Statement first, Statement second) {
        if (auto first = first) return sequence(first, second);
        return second;
    }

    abstract Statement sequenceStatement(Statement[] stmts);

    abstract Statement ifStatement(Expression test, Statement then, nullable Statement else_);

    abstract Statement loopStatement(
            Context context, Statement initializer, Expression test, Statement body_, Statement step);

    abstract Statement returnStatement(Expression value);

    abstract Statement exprStatement(Expression test);

    abstract (Statement | fail Error) move(Context context, Reference target, Expression source);

    /// Create a temporary of `type`. Temporary is passed to `callback`, which returns an initializer.
    /// Returns Expression evaluating to "Initializer, then temporary".
    abstract (nullable Expression | fail Error) exprWithScratchspace(
        Type type, bool temporary, (nullable Statement | fail Error) delegate(Reference) callback);

    abstract (Statement | fail Error) unwindScope(Context context, Namespace target, Statement next);

    abstract (nullable Statement | fail Error) stmtWithTemporary(
        Expression value, (nullable Statement | fail Error) delegate(Reference) callback);

    abstract (nullable Expression | fail Error) exprWithTemporary(
        Expression value, (nullable Expression | fail Error) delegate(Reference) callback);

    // don't create referenceable memory
    abstract (nullable Statement | fail Error) stmtWithTemporaryExpr(
        Expression value, (nullable Statement | fail Error) delegate(Expression) callback);

    abstract (nullable Expression | fail Error) exprWithTemporaryExpr(
        Expression value, (nullable Expression | fail Error) delegate(Expression) callback);

    abstract Expression referenceFunction(FunctionDeclaration decl);

    /**
    * Create a runtime function that, given some parameters, declares and calls the ASTStatement
    * provided.
    * The function will be automatically linked in.
    */
    abstract FunctionDeclaration createRuntimeFunction(
        Context context, string name, Type ret, Parameter[] params, ASTStatement delegate() makeBody);

    Namespace exprAlias(nullable Namespace parent, string name, Symbol value) {
        return symbolAlias(parent, name, value);
    }

    abstract Namespace symbolAlias(nullable Namespace parent, string name, Symbol value);

    abstract DeclarationHolder variableDeclaration(
        nullable Namespace parent, string name, Type type, bool mut, bool borrowed, bool hidden);

    abstract Type nativeWordType(Platform platform);

    abstract Type struct_(string name, StructMemberDeclaration[] members, LocRange locRange, string manglePrefix);

    abstract Type eitherType((bool fail, Type type)[] types);

    (Expression | fail Error) expectImplicitConvertTo(Context context, Expression from, Type to, LocRange locRange)
    {
        if (auto result = implicitConvertTo(context, from, to)) return result;
        context.assert2(false, locRange, "Cannot convert to $(to.repr): $(from.type.repr)")?;
    }

    // true if ClassType or IntfType
    abstract bool isClassType(Type type);

    // called when expr is discarded (usually via ignored return value)
    abstract (void | fail Error) discardErrorCheck(Expression expr, LocRange locRange);

    abstract (void | fail Error) addDefaultImports(Context context, ModuleBase module_);

    abstract ModuleBase createModule(string name, string mangle, LocRange locRange, nullable ModuleBase parent);
}

(Expression | fail Error) expectImplicitConvertTo(Context context, Expression from, Type to, LocRange locRange)
{
    locRange.assert(!!to, "no implconv target type")?;
    if (auto result = context.compiler.implicitConvertTo(context, from, to)) return result;
    context.assert2(false, locRange, "Cannot convert to $(to.repr): $(from.type.repr)")?;
}

abstract class WorkPoolBase
{
    abstract void queue(string id, ITask task) { }
    abstract ITask wait(string id) { }
}

interface ITask
{
    void run();
}

class IdCounter
{
    int count;

    this() { }

    int next() {
        int ret = this.count;
        this.count += 1;
        return ret;
    }
}

// Used by main to analyze the AST tree (docgen)
interface ModulePreProcessor
{
    void process(ASTModuleBase astModule_);
}

// Will be used by main to start emitting modules as soon as they finish.
interface ModulePostProcessor
{
    void process(ModuleBase module_);
}

/**
 * This contains the parts of Context that are rarely modified,
 * and should thus be hidden behind a pointer.
 */
class ImmutableContext
{
    CompilerBase compiler;

    Platform platform;

    MacroState macroState;

    // here for caching reasons
    // TODO replace with once
    Type nativeWordType;

    IdCounter idCounter;

    LocRange[] errorStack;

    ModulePreProcessor modulePreProcessor;

    ModulePostProcessor modulePostProcessor;

    this(this.compiler, this.platform, this.macroState, this.nativeWordType, this.idCounter, this.errorStack,
        this.modulePreProcessor, this.modulePostProcessor) { }
}

/**
 * Context used when transforming an AST into a semantic tree.
 *
 * TODO figure out how to reduce refcounts on this.
 */
struct Context
{
    Namespace namespace;

    // the reference by which free variables are resolved.
    nullable Expression framePointer;

    ModuleBase compilingModule;

    ImmutableContext data;

    Context withNamespace(Namespace namespace) {
        return Context(namespace, this.framePointer, this.compilingModule, this.data);
    }

    Context withFramePointer(nullable Expression framePointer) {
        return Context(this.namespace, framePointer, this.compilingModule, this.data);
    }

    Context withCompilingModule(ModuleBase compilingModule) {
        return Context(this.namespace, framePointer, compilingModule, this.data);
    }

    // TODO alias, this is a bit too reliant on the inliner
    CompilerBase compiler() { return data.compiler; }

    Platform platform() { return data.platform; }

    MacroState macroState() { return data.macroState; }

    Type nativeWordType() { return data.nativeWordType; }

    ModulePreProcessor modulePreProcessor() { return data.modulePreProcessor; }

    ModulePostProcessor modulePostProcessor() { return data.modulePostProcessor; }

    void pushErrorLoc(LocRange locRange) {
        this.data.errorStack ~= locRange;
    }

    void popErrorLoc() {
        this.data.errorStack = this.data.errorStack[0 .. $ - 1];
    }

    (void | fail Error) assert2(bool test, LocRange locRange, string msg) {
        if (test) return;
        return new Error(data.errorStack ~ locRange, msg);
    }

    string getLabel() { return "uniq$(data.idCounter.next)"; }
}

(nullable Expression | fail Error) isExpressionImplCall(Symbol symbol, Context context, LocRange locRange)
{
    if (auto symbolIdent = symbol.instanceOf(SymbolIdentifier))
        return new SymbolIdentifierExpression(symbolIdent.name);

    // implicit function calls
    // TODO check if we should propagate this upcall
    auto astSymbol = new ASTSymbolHelper(symbol);
    if (auto expr = context.compiler.call(context, astSymbol, [], locRange, true)?)
        return expr;
    return symbol.instanceOf(Expression);
}

(Expression | fail Error) beExpressionImplCall(Symbol symbol, Context context, LocRange locRange)
{
    if (auto expr = symbol.isExpressionImplCall(context, locRange)?)
        return expr;
    return locRange.fail("expression expected");
}

ImmutableContext makeIContext(
    CompilerBase compiler, Platform platform, MacroState macroState,
    ModulePreProcessor modulePreProcessor, ModulePostProcessor modulePostProcessor)
{
    return new ImmutableContext(compiler, platform, macroState, compiler.nativeWordType(platform),
        new IdCounter, [], modulePreProcessor, modulePostProcessor);
}

Context makeContext(ImmutableContext icontext, ModuleBase compilingModule, Namespace namespace)
{
    return Context(namespace, null, compilingModule, icontext);
}

// TODO Statement, Context multi-return
struct StatementCompileResult
{
    Statement statement;

    Context context;
}

abstract class ASTStatement
{
    LocRange locRange;

    abstract (StatementCompileResult | fail Error) compile(Context context);

    ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTStatement'!"); assert(false); }
}

/**
 * Something that updates a namespace without behavioral side effects:
 *
 * - import
 * - alias
 * - struct decl
 * - class decl
 *
 * Ironically, a variable declaration is not an ASTDeclaration.
 * Find a better name?
 */
abstract class ASTDeclaration
{
    abstract (Context | fail Error) compile(Context context);

    abstract ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTDeclaration'!"); assert(false); }

    // TODO this.classname
    string repr() { return "TODO repr(ASTDeclaration)"; }
}

// Glue between ASTDeclaration and ASTStatement.
class ASTDeclarationStatement : ASTStatement
{
    ASTDeclaration decl;

    this(this.decl) { }

    override (StatementCompileResult | fail Error) compile(Context context) {
        return this.decl.compile(context).case(
            Context ctx: StatementCompileResult(new NoopStatement, ctx),
            Error err: err);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astDeclarationStatement", [
            this.decl.quote(quoter)], __RANGE__);
    }
}

template notNull(T) {
    nonnullable T notNull(nullable T arg) {
        if (auto a = arg) return a;
        assert(false);
    }
}

class ASTIdentifier : ASTSymbol
{
    string name;

    bool moduleLevel; // .name

    this(this.name, this.moduleLevel, this.locRange) { }

    override (Symbol | fail Error) compile(Context context)
    {
        (nullable Symbol | fail Error) resolve() {
            if (this.moduleLevel) {
                auto module_ = findParent!ModuleBase(context.namespace);
                return module_.lookup(this.name, context.withFramePointer(null), locRange);
            } else if (context.namespace.isContextScope) {
                return context.namespace.lookup(this.name, context, locRange);
            } else {
                return context.namespace.lookup(this.name, context.withFramePointer(null), locRange);
            }
        }
        nullable Symbol symbol = resolve?;
        if (!symbol) return this.locRange.fail("'$(this.name)' not found");
        return symbol.notNull;
    }

    override ASTSymbol quote(Quoter quoter) {
        assert(!moduleLevel);
        // $foo is quoted as 'foo'
        if (name[0 .. 1] == "\$") {
            return quoter.compiler.astIdentifier(name[1 .. $], locRange);
        }
        return quoter.compilerCall("astIdentifier", [
            quoter.compiler.astStringLiteral(this.name, locRange)
        ], locRange);
    }

    override string repr() {
        if (this.moduleLevel)
            return ".$(this.name)";
        return this.name;
    }
}

// :name
class ASTSymbolIdentifier : ASTSymbol
{
    string name;

    this(this.name, this.locRange) { }

    override (SymbolIdentifier | fail Error) compile(Context context) {
        return new SymbolIdentifier(this.name);
    }

    override string repr() { return ":$name"; }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTSymbolIdentifier", __RANGE__), [
                quoter.compiler.astStringLiteral(this.name, __RANGE__),
                quoter.quoteLocRange(this.locRange)], __RANGE__);
    }
}

/**
 * Helper class used for quasiquoting.
 * Transforms an AST* into an ASTSymbol representing a CompilerBase call producing this thing.
 */
abstract class Quoter {
    CompilerBase compiler; // for use by quote() methods

    abstract ASTSymbol compilerCall(string name, ASTSymbol[] parameters, LocRange locRange);
    abstract ASTSymbol quoteLocRange(LocRange locRange);
}

abstract class Macro
{
    abstract void apply(MacroArgs args);
}

// macro subclasses are differentiated by args
abstract class MacroArgs
{
    abstract bool done();
}

// hook the ASTCall -> Call transform
class CallMacroArgs : MacroArgs
{
    ASTSymbol target;
    ASTArgument[] args;
    Context context;
    LocRange locRange;
    (nullable Expression | fail Error) transformed; // out
    this() {}
    void set(this.target, this.args, this.context, this.locRange) {
        this.transformed = null;
    }
    override bool done() {
        return this.transformed.case(nullable Expression expr: !!expr, Error: true);
    }
}

// hook parseExpressionBase
class ParseExpressionBaseArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTSymbol | fail Error) symbol; // out
    this(this.parser, this.lexicalContext) {
        this.symbol = null;
    }
    override bool done() {
        return this.symbol.case(nullable ASTSymbol sym: !!sym, Error: true);
    }
}

// hook parseProperties
class ParsePropertyArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTSymbol left;
    (nullable ASTSymbol | fail Error) result; // out
    this(this.parser, this.lexicalContext, this.left) {
        this.result = null;
    }
    override bool done() {
        return this.result.case(nullable ASTSymbol sym: !!sym, Error: true);
    }
}

// hook parseStatement
class ParseStatementArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTStatement | fail Error) statement; // out
    this(this.parser, this.lexicalContext) {
        this.statement = null;
    }
    override bool done() {
        return this.statement.case(nullable ASTStatement stmt: !!stmt, Error: true);
    }
}

// hook "import "
class ParseImportArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    (nullable ASTModuleBase | fail Error) module_; // out
    this(this.parser, this.lexicalContext) {
        this.module_ = null;
    }
    override bool done() {
        return this.module_.case(nullable ASTModuleBase mod: !!mod, Error: true);
    }
}

class Package
{
    string name;
    string path;
    Package[] deps;

    this(this.name, this.path, this.deps) { }

    void addDependency(Package dep) {
        this.deps ~= dep;
    }

    ASTSymbol quote(Quoter quoter) {
        mut ASTSymbol[] deps_;
        for (auto dep in this.deps)
            deps_ ~= dep.quote(quoter);
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("Package", __RANGE__), [
                quoter.compiler.astStringLiteral(this.name, __RANGE__),
                quoter.compiler.astStringLiteral(this.path, __RANGE__),
                quoter.compiler.astArrayLiteral(deps_, __RANGE__)], __RANGE__);
    }

    string repr() {
        mut string depStr;
        for (dep in deps) {
            if (depStr.length) depStr ~= ", ";
            depStr ~= dep.name;
        }
        return "Package($name, $path, [$depStr])";
    }
}

/**
 * A symbol that depends on some sort of expression:
 *
 * - class method (this)
 * - struct method (this) NOT IMPLEMENTED
 * - nested function (stackframe) NOT IMPLEMENTED
 *
 * The symbol is being used in some way, such as a function call. To facilitate this,
 * temporize the contained expression and pass it into resolve() to get a raw
 * function pointer. The temporized possession must be passed as the first parameter
 * to that pointer.
 *
 * LateSymbol may also patch the expression before the call, for instance for interfaces.
 */
abstract class LateSymbol : Symbol
{
    Expression baseExpr;

    abstract Expression resolve(Context context, Expression baseExpr);

    Expression patchContext(Context context, Expression baseExpr) { return baseExpr; }
}

/**
 * A symbol that may be interested in a frame pointer to complete it.
 * When looked up, should be glued together with the frame pointer of the lookup.
 * Usually, LatentSymbol -> LateSymbol, but this whole flow needs reconsideration.
 */
abstract class LatentSymbol : Symbol
{
    abstract Symbol resolve(Context context);
}

// class.member
// here so we can destructure on it later
// TODO fold this into LateSymbol
class ClassMethodPtr : Symbol
{
    Expression funcPtr;

    // must only be evaluated once!
    Expression thisValue;

    // if not, tmpize and take the address
    bool valueIsPtr;

    string name;

    this(this.funcPtr, this.thisValue, this.valueIsPtr, this.name) { }

    override string repr() {
        return name;
    }
}

// here so we can destructure on it later
abstract class FunctionReferenceBase : Expression
{
    abstract FunctionDeclaration getFunction();
}

class StructMemberDeclaration
{
    string name;

    Protection protection;

    Type type;

    this(this.name, this.protection, this.type) { }
}

// here so we can destructure on it later
abstract class StringLiteralBase : Expression
{
    string text;

    this(this.text) { }

    // TODO: escaping
    override string repr() { return "\"$(this.text)\""; }
}

// Helper for quasiquoted AST blocks that need to reference back to an already resolved symbol.
class ASTSymbolHelper : ASTSymbol
{
    Symbol symbol;

    this(this.symbol) { }

    override (Symbol | fail Error) compile(Context context) { return this.symbol; }

    override string repr() { return symbol.repr; }
}

// TODO clear all this up
abstract class FinishedSymbol
{
    abstract void emit(Generator generator);
    abstract void hash(Hash hash);
}

abstract class CompilationVisitor
{
    abstract void visit(FinishedSymbol sym);
}

abstract class ASTModuleVisitor
{
    abstract void visit(ASTModuleBase mod);
}

/**
 * Symbol that is currently being compiled
 */
abstract class PendingSymbol : Symbol
{
    abstract (Symbol | fail Error) resolve();
    // Allow hashing the pending without resolving and potentially triggering a hash loop.
    abstract void hash(Hash hash);
}

enum Protection
{
    public_,
    protected_,
    private_
}
