module neat.expr;

macro import neat.macros.hash;
macro import neat.macros.once;
macro import neat.macros.retfail;

import backend.base;
import helpers;
import neat.array;
import neat.base;
import neat.hash;
import neat.parser;
import neat.parser_base;
import neat.types;

Expression expectImplicitConvertTo(Context context, Expression from, Type to, Loc loc)
{
    loc.assert2s(!!to, "no implconv target type");
    if (auto result = implicitConvertTo(context, from, to)) return result;
    context.assert2(false, loc, "Cannot convert to $(to.repr): $(from.type.repr)");
}

// TODO implicitConvertTo should only require Type - ie. return a Expression function(Expression).
nullable Expression implicitConvertTo(Context context, Expression from, Type to)
{
    auto fromType = from.type;

    if (fromType.same(to)) return from;
    // void* casts to any pointer
    if (to.instanceOf(Pointer) && fromType.same(once new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    if (fromType.instanceOf(Integer) && to.instanceOf(Long))
    {
        return new IntToLong(from);
    }
    if (fromType.instanceOf(Short) && to.instanceOf(Integer))
    {
        return new ShortToInt(from);
    }
    if (fromType.instanceOf(Character) && to.instanceOf(Integer))
    {
        return new CharToInt(from);
    }
    if (fromType.instanceOf(UByte) && to.instanceOf(Integer))
    {
        return new CharToInt(from);
    }
    if (fromType.instanceOf(Boolean) && (to.instanceOf(Integer) || to.instanceOf(Long)))
    {
        // TODO transition to bytes
        if (to.instanceOf(Long)) return new IntToLong(new CastExpr(new Integer, from));
        return new CastExpr(to, from);
        // return new CharToInt(from);
    }
    if (fromType.instanceOf(Short) && to.instanceOf(Long))
    {
        return new IntToLong(new ShortToInt(from));
    }
    if (fromType.instanceOf(Integer) && to.instanceOf(Float) ||
        fromType.instanceOf(Integer) && to.instanceOf(Double) ||
        fromType.instanceOf(Float) && to.instanceOf(Double))
    {
        return new FloatConvert(from, to);
    }
    // short-sized literals shrink to short
    auto literal = from.instanceOf(IntLiteral);

    if (literal && to.instanceOf(Short) && literal.value >= -32768 && literal.value <= 32767)
    {
        return new ShortLiteral(literal.value);
    }
    // FIXME byte
    if (literal && to.instanceOf(Character) && literal.value >= -128 && literal.value <= 127)
    {
        return new CharLiteral(literal.value, :char_);
    }
    if (literal && to.instanceOf(UByte) && literal.value >= 0 && literal.value <= 255)
    {
        return new CharLiteral(literal.value, :ubyte_);
    }
    // any pointer casts to void*
    if (fromType.instanceOf(Pointer) && to.same(once new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    if (from.instanceOf(StringLiteral) && to.same(once new Pointer(new Character)))
    {
        return new ArrayPointer(new Character, from);
    }
    nullable Expression fromImplicit = to.implicitConvertFrom(context, from);
    if (fromImplicit) return fromImplicit;
    nullable Expression toImplicit = fromType.implicitConvertTo(context, from, to);
    if (toImplicit) return toImplicit;
    return null;
}

class BinaryOp : Expression
{
    string op;

    Expression left;

    Expression right;

    Loc loc;

    this(this.op, this.left, this.right, this.loc) {
        string op = this.op;
        bool isFloating(Type type) { return type.instanceOf(Float) || type.instanceOf(Double); }
        if (op == "<<" || op == ">>" || op == ">>>" || op == "&" || op == "|" || op == "^") {
            loc.assert2s(!left.type.isFloating, "cannot use float for bitop");
            loc.assert2s(!right.type.isFloating, "cannot use float for bitop");
            if (right.type.instanceOf(Long)) this.type = right.type;
            else this.type = left.type;
        } else  if (op == "+" || op == "-" || op == "*" || op == "/" || op == "%") {
            // select "biggest" type of the operators
            if (right.type.instanceOf(Long)) this.type = right.type;
            else if (right.type.instanceOf(Double)) this.type = right.type;
            else if (right.type.instanceOf(Float) && !left.type.instanceOf(Double))
                this.type = right.type;
            else this.type = left.type;
        }
        else if (op == "==" || op == "!=" || op == ">=" || op == "<=" || op == ">" || op == "<" || op == "is")
            this.type = once new Boolean;
        else {
            this.loc.fail("unknown op '" ~ op ~ "'");
        }
    }

    override int emit(Generator output)
    {
        mut Expression left = this.left;
        mut Expression right = this.right;
        mut Type ltype = left.type;
        mut Type rtype = right.type;
        // FIXME afaik this is just used for == 0 checks. make those properly generate longs.
        if (ltype.instanceOf(Integer) && rtype.instanceOf(Long)) {
            left = new IntToLong(left);
            ltype = rtype;
        }
        if (ltype.instanceOf(Long) && rtype.instanceOf(Integer)) {
            right = new IntToLong(right);
            rtype = ltype;
        }
        mut string op = this.op;
        if (this.op == "is")
        {
            op = "==";
        }
        else if (this.op != "==") // you can == pointers
        {
            this.loc.assert2s3(
                ltype.instanceOf(Integer) || ltype.instanceOf(Long) ||
                ltype.instanceOf(Character) || ltype.instanceOf(UByte) ||
                ltype.instanceOf(Float) || ltype.instanceOf(Double) ||
                ltype.instanceOf(Boolean),
                this.op, " (l) expected bool/int/float/double/long/char, not ", ltype.repr);
        } else {
            this.loc.assert2s3(
                ltype.instanceOf(Integer) || ltype.instanceOf(Long) ||
                ltype.instanceOf(Character) || ltype.instanceOf(UByte) ||
                ltype.instanceOf(Float) || ltype.instanceOf(Double) ||
                ltype.instanceOf(Boolean) ||
                ltype.instanceOf(Pointer) || ltype.instanceOf(FunctionPointer),
                this.op, " (l) expected bool/int/float/double/long/char/pointer/fp, not ", ltype.repr);
        }
        this.loc.assert2s5(!!ltype.same(rtype),
            this.op, ": types don't match, ", ltype.repr, ", ", rtype.repr);
        int leftreg = left.emit(output);
        int rightreg = right.emit(output);
        return output.fun.binop(op, ltype.emit(output.platform), leftreg, rightreg);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("BinaryOp"); hash.adds(op); left.hash(hash); right.hash(hash); }

    override string repr() { return "($(left.repr) $op $(right.repr))"; }
}

class PointerOffset : Expression
{
    Expression pointer;

    Expression offset;

    this(this.pointer, this.offset)
    {
        assert(!!this.pointer.type.instanceOf(Pointer));
        this.type = this.pointer.type;
    }

    override int emit(Generator output)
    {
        auto type = pointer.type.instanceOf(Pointer);

        int baseReg = pointer.emit(output);
        int offsetReg = offset.emit(output);
        return output.fun.ptrOffset(type.target.emit(output.platform), baseReg, offsetReg);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.owned); }

    override void hash(Hash hash) { hash.adds("PointerOffset"); pointer.hash(hash); offset.hash(hash); }

    override string repr() { return "($(pointer.repr) + $(offset.repr))"; }
}

class IntToLong : Expression
{
    Expression intValue;

    this(this.intValue) {
        this.type = once new Long;
    }

    override int emit(Generator output) {
        assert(!!this.intValue.type.instanceOf(Integer));

        int intValue = this.intValue.emit(output);
        return output.fun.signExtend(intValue, once new BackendLongType);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("IntToLong"); intValue.hash(hash); }

    override string repr() { return intValue.repr; }
}

class ShortToInt : Expression
{
    Expression shortValue;

    this(this.shortValue) {
        this.type = once new Integer;
    }

    override int emit(Generator output) {
        assert(!!this.shortValue.type.instanceOf(Short));

        int shortValue = this.shortValue.emit(output);
        return output.fun.signExtend(shortValue, once new BackendIntType);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("ShortToInt"); shortValue.hash(hash); }

    override string repr() { return shortValue.repr; }
}

class CharToInt : Expression
{
    Expression charValue;

    this(this.charValue) {
        this.type = once new Integer;
    }

    override int emit(Generator output) {
        assert(this.charValue.type.instanceOf(Character)
            || this.charValue.type.instanceOf(UByte)
            || this.charValue.type.instanceOf(Boolean));

        int charValue = this.charValue.emit(output);
        return output.fun.zeroExtend(charValue, once new BackendIntType);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("CharToInt"); charValue.hash(hash); }
}

// (int, float, double) to (int, float, double)
class FloatConvert : Expression
{
    Expression from;

    this(this.from, this.type) {
        assert(this.type.instanceOf(Integer) || this.type.instanceOf(Float) || this.type.instanceOf(Double));
        assert(!this.from.type.same(this.type));
    }

    override int emit(Generator output) {
        int from = this.from.emit(output);
        return output.fun.convert(from, this.type.emit(output.platform));
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("FloatConvert"); from.hash(hash); type.hash(hash); }
}

class BoolOr : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) {
        this.type = once new Boolean;
    }

    override int emit(Generator output)
    {
        /**
         * result = left;
         * if (left) goto past;
         * result = right;
         * past:
         */
        BackendType intType = once new BackendIntType;
        int result = output.fun.staticAlloca(intType);

        int leftValue = this.left.emit(output);
        output.fun.store(intType, result, leftValue);

        auto label = output.fun.getLabel;
        output.fun.testBranch(leftValue, label ~ "_past", label ~ "_right"); // if (left)
        output.fun.setLabel(label ~ "_right");

        int rightValue = this.right.emit(output);
        output.fun.store(intType, result, rightValue);
        output.fun.branch(label ~ "_past");

        output.fun.setLabel(label ~ "_past");
        return output.fun.load(intType, result);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("BoolOr"); left.hash(hash); right.hash(hash); }
}

class BoolAnd : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) {
        this.type = once new Boolean;
    }

    override int emit(Generator output)
    {
        /**
         * result = left;
         * if (left) result = right;
         */
        BackendType intType = once new BackendIntType;
        int result = output.fun.staticAlloca(intType);

        int leftValue = this.left.emit(output);
        output.fun.store(intType, result, leftValue);

        auto label = output.fun.getLabel;
        output.fun.testBranch(leftValue, label ~ "_true", label ~ "_past"); // if (left)
        output.fun.setLabel(label ~ "_true");

        int rightValue = this.right.emit(output);
        output.fun.store(intType, result, rightValue);
        output.fun.branch(label ~ "_past");

        output.fun.setLabel(label ~ "_past");
        return output.fun.load(intType, result);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.global); }

    override void hash(Hash hash) { hash.adds("BoolAnd"); left.hash(hash); right.hash(hash); }
}

class ASTIntLiteral : ASTSymbol
{
    int value;

    Loc loc;

    this(this.value, this.loc) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new IntLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astIntLiteral", [
            quoter.compiler.astIntLiteral(this.value, loc)
        ], loc);
    }

    override string repr() { return itoa(value); }
}

class IntLiteral : Expression
{
    int value;
    this(this.value) { this.type = once new Integer; }
    override int emit(Generator output) { return output.fun.intLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("IntLiteral"); hash.addl(value); }
    override string repr() { return "$value"; }
}

class BoolLiteral : Expression
{
    bool value;
    this(this.value) { this.type = once new Boolean; }
    // FIXME transition to bytes
    override int emit(Generator output) { return output.fun.intLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("BoolLiteral"); hash.addl(value); }
}

class ASTLongLiteral : ASTSymbol
{
    long value;

    Loc loc;

    this(this.value, this.loc) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new LongLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astLongLiteral", [
            quoter.compiler.astLongLiteral(this.value, loc)
        ], loc);
    }
}

class LongLiteral : Expression
{
    long value;
    this(this.value) { this.type = once new Long; }
    override int emit(Generator output) { return output.fun.longLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("LongLiteral"); hash.addl(value); }
    override string repr() { return "$value"; }
}

class ShortLiteral : Expression
{
    int value;
    this(this.value) { this.type = once new Short; }
    override int emit(Generator output) { return output.fun.shortLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("ShortLiteral"); hash.addl(value); }
    override string repr() { return "$value"; }
}

class CharLiteral : Expression
{
    int value;
    this(this.value, (:char_ | :ubyte_) type) {
        this.type = type.case((:char_): once new Character, (:ubyte_): once new UByte);
    }
    override int emit(Generator output) { return output.fun.byteLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("CharLiteral"); hash.addl(value); }
}

class ASTFloatLiteral : ASTSymbol
{
    float value;

    this(this.value) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new FloatLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTFloatLiteral'"); assert(false); }
}

class FloatLiteral : Expression
{
    float value;
    this(this.value) { this.type = once new Float; }
    override int emit(Generator output) { return output.fun.floatLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("FloatLiteral"); hash.adds(ftoa(value)); }
    override string repr() { return "$value"; }
}

class ASTDoubleLiteral : ASTSymbol
{
    double value;

    this(this.value) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new DoubleLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTDoubleLiteral'"); assert(false); }
}

class DoubleLiteral : Expression
{
    double value;
    this(this.value) { this.type = once new Double; }
    override int emit(Generator output) { return output.fun.doubleLiteral(this.value); }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("DoubleLiteral"); hash.adds(ftoa(value)); }
    override string repr() { return "$value"; }
}

class ASTStringLiteral : ASTSymbol
{
    string text;

    Loc loc;

    this(this.text, this.loc) { }

    override (Symbol | fail Error) compile(Context context)
    {
        return new StringLiteral(this.text);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astStringLiteral", [
            quoter.compiler.astStringLiteral(this.text, loc)], loc);
    }

    override string repr() {
        // FIXME escaping
        return "\"$text\"";
    }
}

class StringLiteral : StringLiteralBase
{
    this(this.text) { this.type = once new Array(new Character); }

    override int emit(Generator output)
    {
        int len = output.fun.wordLiteral(output.platform, this.text.length);
        int ptr = output.fun.stringLiteral(this.text ~ "\x00");
        int nullptr = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), output.platform.voidp);

        return makeArray(output, once new Character, len, ptr, nullptr);
    }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("StringLiteral"); hash.adds(text); }
    override string repr() { return "\"$text\""; }
}

class Call : Expression
{
    FunctionDeclaration fun;

    Expression[] args;

    Loc loc;

    this(this.fun, this.args, this.loc)
    {
        if (fun.variadic) {
            if (args.length < fun.numArgs) {
                loc.fail("$(fun.name) expected at least $(fun.numArgs) args, not $(args.length)");
            }
        } else {
            if (args.length != fun.numArgs) {
                loc.fail("$(fun.name) expected $(fun.numArgs) args, not $(args.length)");
            }
        }
        int extra = !!fun.contextType;
        for (i, param in fun.params) {
            if (!args[extra + i].type.same(param.type)) {
                loc.fail("wrong type in call: $(args[extra + i].type.repr) to $(param.type.repr)");
            }
        }
        this.type = this.fun.ret;
    }

    override int emit(Generator output)
    {
        this.fun.declare(output);

        int[] regs = new int[](this.args.length);
        for (i, arg in this.args) {
            regs[i] = arg.emit(output);
        }
        return output.fun.call(this.type.emit(output.platform), this.fun.mangle, regs);
    }

    // we take over the returned value
    override ExprInfo info() { return ExprInfo(false, Ownership.gifted); }

    override void hash(Hash hash) {
        hash.adds("Call");
        hash.adds(fun.mangle);
        hash.addl(args.length);
        for (arg in args) arg.hash(hash);
    }
}

(Expression | fail Error) truthy(Context context, Expression value, Loc loc) {
    Type type = value.type;
    loc.assert2s(!!type, "internal error");
    auto truthyExpr <- type.truthy(context, value, loc);
    if (auto truthyExpr = truthyExpr) return truthyExpr;

    if (type.instanceOf(Boolean))
    {
        return value;
    }
    if (type.instanceOf(Pointer))
    {
        auto sizeT = context.nativeWordType;

        return new BinaryOp("!=", new CastExpr(sizeT, value), once new IntLiteral(0), loc);
    }
    loc.assert2s(type.instanceOf(Integer) || type.instanceOf(Long), "integer or bool expected, not $(type.repr)");
    return new BinaryOp("!=", value, once new IntLiteral(0), loc);
}

(bool | :unknown | fail Error) staticTruthy(Context context, ASTSymbol value) {
    auto test = retfail value.compile(context);
    if (auto boolLit = test.instanceOf(BoolLiteral)) {
        return boolLit.value;
    }
    return :unknown;
}

class ASTBinaryOp : ASTSymbol
{
    string op;

    ASTSymbol left;

    ASTSymbol right;

    Loc loc;

    this(this.op, this.left, this.right, this.loc) { }

    override (Expression | fail Error) compile(Context context)
    {
        mut Expression left <- beExpression3(context, retfail this.left.compile(context), this.loc);
        mut Expression right <- beExpression3(context, retfail this.right.compile(context), this.loc);

        if (auto opOverload = retfail left.type.binaryOp(context, this.op, left, right, this.loc))
            return opOverload;

        if (this.op == "~")
        {
            loc.assert2s2(
                !!left.type.instanceOf(Array),
                "Left hand side of concatenation isn't array, but ", left.type.repr);
            if (auto converted = implicitConvertTo(context, right, left.type.instanceOf(Array).elementType)) {
                return context.compiler.binaryOp("~", context, left, converted, this.loc);
            }

            return context.compiler.binaryOp("~", context, left, right, this.loc);
        }
        if (this.op == "&&")
            return new BoolAnd(
                retfail truthy(context, left, this.loc),
                retfail truthy(context, right, this.loc));
        if (this.op == "||")
            return new BoolOr(
                retfail truthy(context, left, this.loc),
                retfail truthy(context, right, this.loc));

        // try to merge types
        if (auto converted = implicitConvertTo(context, right, left.type)) {
            right = converted;
        }
        if (auto converted = implicitConvertTo(context, left, right.type)) {
            left = converted;
        }

        return new BinaryOp(this.op, left, right, this.loc);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astBinaryOp", [
            quoter.compiler.astStringLiteral(op, loc),
            left.quote(quoter),
            right.quote(quoter)], loc);
    }

    override string repr() { return "($(left.repr) $op $(right.repr))"; }
}

class Dereference : Reference
{
    Expression base;

    Pointer pointerType;

    this(this.base)
    {
        this.pointerType = base.type.instanceOf(Pointer).notNull;
        this.type = this.pointerType.target;
    }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        return this.base.emit(output);
    }

    // avoid doing memory management until we figure out how to handle pointers.
    // (or if we need to at all.)
    // mutable for now, but rethink later
    override ExprInfo info() { return ExprInfo(true, Ownership.owned); }

    override void hash(Hash hash) { hash.adds("Dereference"); base.hash(hash); }

    override string repr() { return "*$(this.base.repr)"; }
}

class ReferenceExpression : Expression
{
    Reference base;

    this(this.base) {
        Type superType = this.base.type;

        this.type = new Pointer(superType);
    }

    override int emit(Generator output)
    {
        return this.base.emitLocation(output);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash) { hash.adds("ReferenceExpression"); base.hash(hash); }

    override string repr() { return "&$(this.base.repr)"; }
}

/**
 * Must be initialized once with a InitializeTemporaryStatement.
 */
class PairedTemporary : Reference
{
    int reg;

    Ownership ownership;

    this(this.type, this.ownership)
    {
        this.reg = -1;
    }

    override int emitLocation(Generator output)
    {
        assert(reg != -1);

        return reg;
    }

    override int emit(Generator output)
    {
        auto type = this.type.emit(output.platform);

        return output.fun.load(type, emitLocation(output));
    }

    override ExprInfo info() {
        return ExprInfo(false, this.ownership);
    }

    // temp value change identified in InitializeTemporaryStatement
    // TODO use label?
    override void hash(Hash hash) {
        hash.adds("PairedTemporary");
        if (this.ownership == Ownership.gifted) hash.adds("gifted");
        else if (this.ownership == Ownership.borrowed) hash.adds("borrowed");
        else if (this.ownership == Ownership.owned) hash.adds("owned");
        else if (this.ownership == Ownership.global) hash.adds("global");
        else assert(false);
        type.hash(hash);
    }

    override string repr() { return "%$reg"; }
}

class UninitializeTemporaryStatement : Statement
{
    PairedTemporary target;

    this(this.target) { }

    override void emit(Generator output)
    {
        // does double-emit ever happen?
        // yes! - macros!
        // TODO figure out a Generator based way (named regs?) to avoid double emit.
        // assert(target.reg == -1);

        auto type = target.type.emit(output.platform);

        target.reg = output.fun.staticAlloca(type);
    }

    // TODO id here?
    override void hash(Hash hash) {
        hash.adds("UninitializeTemporaryStatement");
    }

    override string repr() { return "%$(target.reg) = null"; }
}

// assignment that defines a register
class InitializeTemporaryStatement : Statement
{
    PairedTemporary target;

    Expression value;

    this(this.target, this.value) { }

    override void emit(Generator output)
    {
        // does double-emit ever happen?
        // yes! - macros!
        // TODO figure out a Generator based way (named regs?) to avoid double emit.
        // assert(target.reg == -1);

        auto type = target.type.emit(output.platform);

        target.reg = output.fun.staticAlloca(type);
        int value = value.emit(output);
        output.fun.store(type, target.reg, value);
    }

    // TODO id here?
    override void hash(Hash hash) {
        hash.adds("InitializeTemporaryStatement");
        value.hash(hash);
    }

    override string repr() { return "%$(target.reg) = $(value.repr)"; }
}

class Temporary : Reference
{
    Expression expr;

    string label;

    this(this.expr)
    {
        this.label = ptrId(this);
        this.type = expr.type;
    }

    override int emitLocation(Generator output)
    {
        if (output.fun.hasNamedReg(label))
            return output.fun.getNamedReg(label);

        BackendType type = this.type.emit(output.platform);
        int ptr = output.fun.staticAlloca(type);
        int value = this.expr.emit(output);
        output.fun.store(type, ptr, value);

        output.fun.setNamedReg(label, ptr);
        return ptr;
    }

    override int emit(Generator output)
    {
        auto type = this.type.emit(output.platform);

        return output.fun.load(type, emitLocation(output));
    }

    override ExprInfo info() { return expr.info; }

    override void hash(Hash hash) {
        hash.adds("temporary");
        expr.hash(hash);
    }
}

/**
 * Different from PairedTemporary in that it just uses a reg, not an alloca.
 * Must be initialized once with a InitializePairedTemporaryExprStatement
 * Cleaned up by the allocator.
 */
class PairedTemporaryExpr : Expression
{
    int reg;

    Ownership ownership;

    this(this.type, this.ownership)
    {
        assert(this.ownership != Ownership.gifted); // "gifted" can't be multi-read
        this.reg = -1;
    }

    override int emit(Generator output)
    {
        auto type = this.type.emit(output.platform);
        assert(this.reg != -1);

        return this.reg;
    }

    override ExprInfo info() {
        return ExprInfo(false, this.ownership);
    }

    // temp value change identified in InitializeTemporaryExprStatement
    // TODO use label?
    override void hash(Hash hash) {
        hash.adds("PairedTemporaryExpr");
        type.hash(hash);
    }

    override string repr() { return "%$reg"; }
}

// assignment that defines a register
class InitializeTemporaryExprStatement : Statement
{
    PairedTemporaryExpr target;

    Expression value;

    this(this.target, this.value) { }

    override void emit(Generator output)
    {
        // does double-emit ever happen?
        // yes! - macros!
        // TODO figure out a Generator based way (named regs?) to avoid double emit.
        // assert(target.reg == -1);

        target.reg = value.emit(output);
    }

    // TODO id here?
    override void hash(Hash hash) {
        hash.adds("InitializeTemporaryExprStatement");
        value.hash(hash);
    }
}

Expression castTo(Context context, Type to, Expression from) {
    if (auto implconv = implicitConvertTo(context, from, to)) return implconv;
    if (from.type.instanceOf(Integer) && to.instanceOf(Long))
        return new IntToLong(from);
    if (from.type.instanceOf(Short) && to.instanceOf(Integer))
        return new ShortToInt(from);
    if (from.type.instanceOf(Character) && to.instanceOf(Integer))
        return new CharToInt(from);
    if (from.type.instanceOf(Short) && to.instanceOf(Long))
        return new IntToLong(new ShortToInt(from));
    if (from.type.instanceOf(Integer) && to.instanceOf(Float) ||
        from.type.instanceOf(Integer) && to.instanceOf(Double) ||
        from.type.instanceOf(Float) && to.instanceOf(Double))
        return new FloatConvert(from, to);
    return new CastExpr(to, from);
}

class CastExpr : Expression
{
    Type target;

    Expression value;

    this(this.target, this.value) { this.type = target; }
    override int emit(Generator generator)
    {
        auto type = value.type;
        auto value = this.value.emit(generator);
        auto target = this.target.emit(generator.platform);
        if (type.instanceOf(Long) && this.target.instanceOf(Integer)) {
            return generator.fun.trunc(value, target);
        }
        if (type.instanceOf(Float) && this.target.instanceOf(Integer) ||
            type.instanceOf(Double) && this.target.instanceOf(Integer) ||
            type.instanceOf(Double) && this.target.instanceOf(Float))
        {
            return generator.fun.convert(value, target);
        }
        if (this.value.type.emit(generator.platform).same(target))
        {
            return value;
        }

        return generator.fun.bitcast(value, target);
    }
    override ExprInfo info() { return ExprInfo(false, Ownership.global); }
    override void hash(Hash hash) { hash.adds("CastExpr"); target.hash(hash); value.hash(hash); }
    override string repr() { return "cast($(target.repr)) $(value.repr)"; }
}

class ASTCastExpr : ASTSymbol
{
    ASTSymbol target;

    ASTSymbol value;

    Loc loc;

    this(this.target, this.value, this.loc) { }

    override (Expression | fail Error) compile(Context context)
    {
        auto target = beType(this.loc, retfail this.target.compile(context));
        auto value <- beExpression3(context, retfail this.value.compile(context), loc);

        this.loc.assert2s(!value.type.instanceOf(Array), "what are you doing");

        return castTo(context, target, value);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astCast", [
            target.quote(quoter),
            value.quote(quoter)], loc);
    }
}

class ASTNegation : ASTSymbol
{
    ASTSymbol next;

    Loc loc;

    this(this.next, this.loc) { }

    override (Expression | fail Error) compile(Context context)
    {
        Expression isTrue <- truthy(
            context, retfail beExpression3(context, retfail this.next.compile(context), this.loc), this.loc);

        return new BinaryOp("==", isTrue, new BoolLiteral(false), this.loc);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astNegation", [next.quote(quoter)], loc);
    }
}

class OverrideLifetimeExpr : Expression
{
    Expression value;
    ExprInfo infoVal;
    this(this.value, this.infoVal) { this.type = value.type; }
    override int emit(Generator output) { return value.emit(output); }
    override ExprInfo info() { return this.infoVal; }
    override void hash(Hash hash) {
        hash.adds("OverrideLifetimeExpr");
        if (infoVal.mutable) hash.adds("mutable");
        else hash.adds("nonmutable");
        if (infoVal.ownership == Ownership.gifted) hash.adds("gifted");
        else if (infoVal.ownership == Ownership.owned) hash.adds("owned");
        else if (infoVal.ownership == Ownership.borrowed) hash.adds("borrowed");
        else if (infoVal.ownership == Ownership.global) hash.adds("global");
        else assert(false);
        value.hash(hash);
    }
}

class SizeOf : Expression
{
    Type targetType;

    this(this.targetType) {
        this.type = once new Integer;
    }

    override int emit(Generator output)
    {
        int size = this.targetType.emit(output.platform).size(output.platform);

        return output.fun.intLiteral(size);
    }

    override ExprInfo info() { return ExprInfo(false, Ownership.owned); }

    override void hash(Hash hash) { hash.adds("SizeOf"); targetType.hash(hash); }
}

class ASTSizeOf : ASTSymbol
{
    ASTSymbol target;

    this(this.target) { }

    override (Symbol | fail Error) compile(Context context)
    {
        auto target = retfail target.compile(context);
        if (auto expr = target.instanceOf(Expression))
            return new SizeOf(expr.type);
        if (auto type = target.instanceOf(Type))
            return new SizeOf(type);
        assert(false);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astIdentifier("ASTSizeOf", __HERE__), [
                this.target.quote(quoter)], __HERE__);
    }
}
