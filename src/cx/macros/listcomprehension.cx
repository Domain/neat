module cx.macros.listcomprehension;

macro import cx.macros.quasiquoting;

import cx.array;
import cx.base;
import cx.parser;
import cx.parser_base;
import cx.statements;
import helpers;

class ASTListComprehension : ASTSymbol
{
    string iterationMode; // "", "any", "all"

    ASTSymbol expr;

    string varname;

    ASTSymbol source;

    Loc loc;

    this(this.iterationMode, this.expr, this.varname, this.source, this.loc) { }

    override Symbol compile(Context context) {
        auto compiler = context.compiler;

        auto sourceType = beExpression2(source.compile(context), loc).type();
        loc.assert2s(!!sourceType.instanceOf(Array), "expected array for source of list comprehension");

        auto astType = compiler.$type typeof(({ auto $varname = $source[0]; $expr; }));
        auto type = astType.compile(context);

        if (type.instanceOf(Void)) {
            return (compiler.$expr ({
                auto __source = $source;
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    $expr;
                }
                0;
            })).compile(context);
        } else if (iterationMode == "any") {
            return (compiler.$expr ({
                auto __source = $source;
                auto __result = false;
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    if ($expr) { __result = true; break; }
                }
                __result;
            })).compile(context);
        } else if (iterationMode == "all") {
            return (compiler.$expr ({
                auto __source = $source;
                auto __result = true;
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    if (!$expr) { __result = false; break; }
                }
                __result;
            })).compile(context);
        } else {
            assert(iterationMode == "");
            return (compiler.$expr ({
                auto __source = $source;
                auto __result = new $astType[](__source.length);
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    __result[__i] = $expr;
                }
                __result;
            })).compile(context);
        }
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTListComprehension'"); assert(false); }
}

class ListComprehension : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseExpressionBaseArgs);
        if (args) {
            args.symbol = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTSymbol parse(Parser parser, LexicalContext lexicalContext)
    {
        auto compiler = lexicalContext.compiler;
        auto loc = parser.loc();

        parser.begin();
        if (!parser.accept("[")) {
            parser.revert();
            return null;
        }
        string iterationMode;
        if (acceptIdentifier(parser, "any")) iterationMode = "any";
        else if (acceptIdentifier(parser, "all")) iterationMode = "all";
        auto expr = compiler.parseExpression(parser, lexicalContext);
        if (!expr || !parser.accept("for")) {
            parser.revert();
            return null;
        }
        auto varname = parseIdentifier(parser);
        if (!varname.length) {
            parser.fail("variable name expected");
        }
        parser.expect("in");
        auto source = compiler.parseExpression(parser, lexicalContext);
        if (!source) {
            parser.fail("source expression expected");
        }
        // TODO where
        parser.expect("]");
        parser.commit();
        return new ASTListComprehension(iterationMode, expr, varname, source, loc);
    }
}

void addListComprehensionMacro(MacroState macroState)
{
    macroState.addMacro(new ListComprehension);
}

macro(addListComprehensionMacro);
