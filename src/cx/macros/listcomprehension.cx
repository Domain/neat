module cx.macros.listcomprehension;

macro import cx.macros.quasiquoting;

import cx.base;
import cx.parser;
import cx.parser_base;
import cx.statements;
import helpers;

class ASTListComprehension : ASTSymbol
{
    ASTSymbol expr;

    string varname;

    ASTSymbol source;

    this(this.expr, this.varname, this.source) { }

    override Symbol compile(Context context) {
        auto compiler = context.compiler;

        auto astType = compiler.$type typeof(({ auto $varname = $source[0]; $expr; }));
        auto type = astType.compile(context);
        if (type.instanceOf(Void)) {
            return (compiler.$expr ({
                auto __source = $source;
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    $expr;
                }
                0;
            })).compile(context);
        } else {
            return (compiler.$expr ({
                auto __source = $source;
                auto __result = new $astType[](__source.length);
                for (auto __i = 0; __i < __source.length; __i += 1) {
                    auto $varname = __source[__i];
                    __result[__i] = $expr;
                }
                __result;
            })).compile(context);
        }
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTListComprehension'"); assert(false); }
}

class ListComprehension : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseExpressionBaseArgs);
        if (args) {
            args.symbol = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTSymbol parse(Parser parser, LexicalContext lexicalContext)
    {
        auto compiler = lexicalContext.compiler;

        parser.begin();
        if (!parser.accept("[")) {
            parser.revert();
            return null;
        }
        auto expr = compiler.parseExpression(parser, lexicalContext);
        if (!expr || !parser.accept("for")) {
            parser.revert();
            return null;
        }
        auto varname = parseIdentifier(parser);
        if (!varname.length) {
            parser.fail("variable name expected");
        }
        parser.expect("in");
        auto source = compiler.parseExpression(parser, lexicalContext);
        if (!source) {
            parser.fail("source expression expected");
        }
        // TODO where
        parser.expect("]");
        parser.commit();
        return new ASTListComprehension(expr, varname, source);
    }
}

void addListComprehensionMacro(MacroState macroState)
{
    macroState.addMacro(new ListComprehension);
}

macro(addListComprehensionMacro);
