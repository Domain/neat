module cx.macros.listcomprehension;

macro import cx.macros.quasiquoting;

import cx.base;
import cx.parser;
import cx.parser_base;
import cx.statements;

class ListComprehension : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseExpressionBaseArgs);
        if (args) {
            args.symbol = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTSymbol parse(Parser parser, LexicalContext lexicalContext)
    {
        auto compiler = lexicalContext.compiler;

        parser.begin();
        if (!parser.accept("[")) {
            parser.revert();
            return null;
        }
        auto expr = compiler.parseExpression(parser, lexicalContext);
        if (!expr || !parser.accept("for")) {
            parser.revert();
            return null;
        }
        auto varname = parseIdentifier(parser);
        if (!varname.length) {
            parser.fail("variable name expected");
        }
        parser.expect("in");
        auto source = compiler.parseExpression(parser, lexicalContext);
        if (!source) {
            parser.fail("source expression expected");
        }
        // TODO where
        parser.expect("]");
        parser.commit();
        return compiler.$expr ({
            auto __source = $source;
            auto __result = new typeof(({ auto $varname = __source[0]; $expr; }))[](__source.length);
            for (auto __i = 0; __i < __source.length; __i += 1) {
                auto $varname = __source[__i];
                __result[__i] = $expr;
            }
            __result;
        });
    }
}

void addListComprehensionMacro(MacroState macroState)
{
    macroState.addMacro(new ListComprehension);
}

macro(addListComprehensionMacro);
