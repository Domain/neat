module cx.macros.either;

import package(compiler).backend.base;
import package(compiler).cx.base;
import package(compiler).cx.either;
import package(compiler).cx.parser;
import package(compiler).cx.hash;
import package(compiler).cx.parser_base;
import package(compiler).cx.types;
import package(compiler).helpers;

ASTSymbol parseEither(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    if (!acceptIdentifier(parser, "Either") || !parser.accept("("))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    ASTEitherDeclEntry[] entries;
    while (!parser.accept(")"))
    {
        if (entries.length > 0 && !parser.accept(","))
        {
            parser.fail("',' or ')' expected");
        }
        Loc loc = parser.loc;
        ASTSymbol type = lexicalContext.compiler.parseType(parser, lexicalContext);
        parser.assert_(!!type, "argument type expected");
        entries ~= ASTEitherDeclEntry(loc, type);
    }
    return new ASTEitherDecl(entries);
}

class EitherMacro : Macro
{
    this() { }

    override void apply(MacroArgs args) {
        if (auto typeArgs = args.instanceOf(TypeMacroArgs)) {
            typeArgs.astType = parseEither(typeArgs.parser, typeArgs.lexicalContext);
        }
        if (auto propArgs = args.instanceOf(ParsePropertyArgs)) {
            propArgs.result = parseEitherCaseExpr(propArgs.parser, propArgs.lexicalContext, propArgs.left);
        }
        if (auto stmtArgs = args.instanceOf(ParseStatementArgs)) {
            stmtArgs.statement = parseEitherCaseStmt(stmtArgs.parser, stmtArgs.lexicalContext);
        }
    }
}

void addEitherMacro(MacroState macroState)
{
    macroState.addMacro(new EitherMacro);
}

macro(addEitherMacro);
