module cx.macros.assert;

macro import cx.macros.quasiquoting;

import package(compiler).cx.array;
import package(compiler).cx.base;
import package(compiler).cx.expr;
import package(compiler).cx.parser_base;
import package(compiler).cx.statements;
import package(compiler).cx.stuff;
import package(compiler).cx.types;
import package(compiler).helpers;

class ASTAssertion : ASTStatement
{
    ASTSymbol test;

    string exprText;

    Loc loc;

    this(ASTSymbol test, string exprText, Loc loc) {
        this.test = test;
        this.exprText = exprText;
        this.loc = loc;
    }

    Expression symbolTest(Context context, ASTSymbol sym) {
        auto context = context.withNamespace(context.compiler.exprAlias(
                context.namespace, "identName", context.compiler.stringLiteral(repr(sym))));

        return (
            context.compiler.$expr identName ~ " = " ~ itoa(cast(int) $sym)
        ).compile(context).instanceOf(Expression);
    }

    Expression binopTest(mut Context context, ASTBinaryOp binop) {
        void set(string name, Symbol value) {
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, name, value));
        }
        string leftStr = repr(binop.left), rightStr = repr(binop.right);
        set("leftStr", context.compiler.stringLiteral(leftStr));
        set("rightStr", context.compiler.stringLiteral(rightStr));
        Loc nowhere;
        auto
            left = binop.left.compile(context).instanceOf(Expression),
            right = binop.right.compile(context).instanceOf(Expression);
        if (!left || !right) return null;
        set("left", left);
        set("right", right);

        if (binop.op == "&&") {
            auto leftRecurse = dispatch(context, binop.left);
            auto rightRecurse = dispatch(context, binop.right);
            if (!leftRecurse || !rightRecurse) return null;
            set("leftRecurse", leftRecurse);
            set("rightRecurse", rightRecurse);

            return (context.compiler.$expr ({
                mut string ret;
                if (!left) ret = leftStr ~ " failed, because " ~ leftRecurse;
                else ret = rightStr ~ " failed, because " ~ rightRecurse;
                ret;
            })).compile(context).instanceOf(Expression);
        }
        if (binop.op == "||") {
            auto leftRecurse = dispatch(context, binop.left);
            auto rightRecurse = dispatch(context, binop.right);
            if (!leftRecurse || !rightRecurse) return null;
            set("leftRecurse", leftRecurse);
            set("rightRecurse", rightRecurse);

            return (context.compiler.$expr ({
                mut string ret;
                if (left) ret = rightStr ~ " failed, because " ~ rightRecurse;
                else if (right) ret = leftStr ~ " failed, because " ~ leftRecurse;
                else ret = leftStr ~ " failed (because " ~ leftRecurse ~ ") and "
                    ~ rightStr ~ " failed (because " ~ rightRecurse ~ ")";
                ret;
            })).compile(context).instanceOf(Expression);
        }
        if (left.type.instanceOf(Integer) && right.type.instanceOf(Integer)) {
            if (right.instanceOf(IntLiteral)) {
                return (
                    context.compiler.$expr leftStr ~ " = " ~ itoa(cast(int) left)
                ).compile(context).instanceOf(Expression);
            }
            return (
                context.compiler.$expr
                    leftStr ~ " = " ~ itoa(cast(int) left)
                    ~ " and " ~ rightStr ~ " = " ~ itoa(cast(int) right)
            ).compile(context).instanceOf(Expression);
        }
        return null;
    }

    Expression negTest(mut Context context, ASTNegation astNegation)
    {
        void set(string name, Symbol value) {
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, name, value));
        }

        auto nextRecurse = dispatch(context, astNegation.next);
        if (!nextRecurse) return null;
        set("nextRecurse", nextRecurse);
        string nextStr = repr(astNegation.next);
        set("nextStr", context.compiler.stringLiteral(nextStr));

        return (
            context.compiler.$expr nextRecurse ~ " was true"
        ).compile(context).instanceOf(Expression);
    }

    Expression dispatch(Context context, ASTSymbol sym) {
        if (auto ident = sym.instanceOf(ASTIdentifier))
        {
            return symbolTest(context, ident);
        }
        if (auto member = sym.instanceOf(ASTMember))
        {
            return symbolTest(context, member);
        }
        if (auto binop = sym.instanceOf(ASTBinaryOp))
        {
            return binopTest(context, binop);
        }
        if (auto neg = sym.instanceOf(ASTNegation))
        {
            return negTest(context, neg);
        }
        return null;
    }

    override StatementCompileResult compile(mut Context context)
    {
        auto printFun = new FunctionDeclaration(
            "print", new Void, [Argument(false, "str", false, new Array(new Character))]);
        auto assertFun = new FunctionDeclaration(
            "assert", new Void, [Argument(false, "test", false, new Integer)]);
        auto itoaFun = new FunctionDeclaration(
            "cxruntime_itoa", new Array(new Character), [Argument(false, "value", false, new Integer)]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "print", printFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "assert", assertFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "itoa", itoaFun));
        string failedMsg = loc.location() ~ ": assertion failed: " ~ exprText ~ ", because ";
        auto ifFailed = dispatch(context, test);
        if (ifFailed) {
            context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "ifFailed", ifFailed));
            context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "failedMsg", context.compiler.stringLiteral(failedMsg)));
            auto assertTest = context.compiler.$stmt {
                if (!$test) {
                    print(failedMsg ~ ifFailed);
                    assert(false);
                }
            };
            auto assertTestStmt = assertTest.compile(context);
            return StatementCompileResult(assertTestStmt.statement, context);
        }

        // fallback: old impl
        // TODO quasiquote this
        auto test = this.test.compile(context);
        auto expr = beExpression2(test, this.loc);
        auto texpr = context.compiler.truthy(context, expr, this.loc);
        auto nexpr = context.compiler.binaryOp(
            "==", context, texpr, context.compiler.intLiteral(0), this.loc);

        Expression failStr = context.compiler.binaryOp(
                "~", context,
                context.compiler.stringLiteral(this.loc.location()),
                context.compiler.stringLiteral(": '" ~ this.exprText ~ "' was false"),
                this.loc);
        Expression false_ = context.compiler.intLiteral(0);
        Statement printSt = context.compiler.exprStatement(
            context.compiler.call(printFun, [failStr], this.loc));
        Statement failSt = context.compiler.exprStatement(
            context.compiler.call(assertFun, [false_], this.loc));
        // `if (!$expression) { print($assertLocStr ~ ": '" ~ $exprText ~ "' was false."); assert(false); }`
        return StatementCompileResult(
            context.compiler.ifStatement(
                nexpr,
                context.compiler.sequenceStatement([printSt, failSt]),
                null),
            context);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTAssertion'!"); assert(false); }
}

string repr(ASTSymbol expr) {
    assert(!!expr);
    if (auto ident = expr.instanceOf(ASTIdentifier)) {
        return ident.name;
    }
    if (auto neg = expr.instanceOf(ASTNegation)) {
        return "!" ~ repr(neg.next);
    }
    if (auto member = expr.instanceOf(ASTMemberBase)) {
        return repr(member.base) ~ "." ~ member.member;
    }
    if (auto binop = expr.instanceOf(ASTBinaryOp)) {
        return "(" ~ repr(binop.left) ~ " " ~ binop.op ~ " " ~ repr(binop.right) ~ ")";
    }
    if (auto intl = expr.instanceOf(ASTIntLiteral)) {
        return itoa(intl.value);
    }
    return "TODO";
}

class ParseAssert : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseStatementArgs);
        if (args) {
            args.statement = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTStatement parse(Parser parser, LexicalContext context)
    {
        parser.begin();
        parser.strip();
        auto assertLoc = parser.loc();
        if (!parser.accept("assert"))
        {
            parser.revert();
            return null;
        }
        if (!parser.accept("("))
        {
            parser.revert();
            return null;
        }
        parser.commit();
        auto exprStartLoc = parser.loc();
        auto expression = context.compiler.parseExpression(parser, context);
        auto exprEndLoc = parser.loc();
        auto exprText = exprStartLoc.text()[0 .. exprStartLoc.text().length - exprEndLoc.text().length];

        parser.expect(")");
        parser.expect(";");

        return new ASTAssertion(expression, exprText, exprStartLoc);
    }
}

void assertMacro(MacroState macroState)
{
    macroState.addMacro(new ParseAssert);
}

macro(assertMacro);
