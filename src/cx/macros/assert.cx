module cx.macros.assert;

import package(compiler).cx.base;
import package(compiler).cx.parser_base;
import package(compiler).cx.types;

class ASTAssertion : ASTStatement
{
    ASTSymbol test;

    string exprText;

    Loc loc;

    this(ASTSymbol test, string exprText, Loc loc) {
        this.test = test;
        this.exprText = exprText;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        auto printArgTypes = new Argument[](0) ~ Argument(false, "str", new Array(new Character));
        auto printFun = new FunctionDeclaration("print", new Void, printArgTypes);

        auto assertArgTypes = new Argument[](0) ~ Argument(false, "test", new Integer);
        auto assertFun = new FunctionDeclaration("assert", new Void, assertArgTypes);

        auto test = this.test.compile(context);
        auto expr = beExpression2(test, this.loc);
        auto texpr = context.compiler.truthy(expr, this.loc);
        auto nexpr = context.compiler.binaryOp(
            "==", texpr, context.compiler.intLiteral(0), this.loc);

        Expression failStr = context.compiler.binaryOp(
                "~",
                context.compiler.stringLiteral(this.loc.location()),
                context.compiler.stringLiteral(": '" ~ this.exprText ~ "' was false"),
                this.loc);
        Expression false_ = context.compiler.intLiteral(0);
        Statement printSt = context.compiler.exprStatement(
            context.compiler.call(printFun, new Expression[](0) ~ failStr, this.loc));
        Statement failSt = context.compiler.exprStatement(
            context.compiler.call(assertFun, new Expression[](0) ~ false_, this.loc));
        // `if (!$expression) { print($assertLocStr ~ ": '" ~ $exprText ~ "' was false."); assert(false); }`
        return StatementCompileResult(
            context.compiler.ifStatement(
                nexpr,
                context.compiler.sequenceStatement(new Statement[](0) ~ printSt ~ failSt),
                null),
            context);
    }
}

class ParseAssert : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseStatementArgs);
        if (args) {
            args.statement = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTStatement parse(Parser parser, LexicalContext context)
    {
        parser.begin();
        parser.strip();
        auto assertLoc = parser.loc();
        if (!parser.accept("assert"))
        {
            parser.revert();
            return null;
        }
        if (!parser.accept("("))
        {
            parser.revert();
            return null;
        }
        parser.commit();
        auto exprStartLoc = parser.loc();
        auto expression = context.compiler.parseExpression(parser, context);
        auto exprEndLoc = parser.loc();
        auto exprText = exprStartLoc.text[0 .. exprStartLoc.text.length - exprEndLoc.text.length];

        parser.expect(")");
        parser.expect(";");

        return new ASTAssertion(expression, exprText, exprStartLoc);
    }
}

void assertMacro(MacroState macroState)
{
    macroState.addMacro(new ParseAssert);
}

macro(assertMacro);
