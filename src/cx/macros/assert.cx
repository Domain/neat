module cx.macros.assert;

import cx.array;
import cx.base;
import cx.expr;
import cx.parser_base;
import cx.statements;
import cx.stuff;
import cx.types;
import helpers;

class ASTAssertion : ASTStatement
{
    ASTSymbol test;

    string exprText;

    Loc loc;

    this(ASTSymbol test, string exprText, Loc loc) {
        this.test = test;
        this.exprText = exprText;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        auto printArgTypes = new Argument[](0) ~ Argument("str", new Array(new Character));
        auto printFun = new FunctionDeclaration("print", new Void, printArgTypes);

        auto assertArgTypes = new Argument[](0) ~ Argument("test", new Integer);
        auto assertFun = new FunctionDeclaration("assert", new Void, assertArgTypes);

        auto test = this.test.compile(context);
        auto expr = beExpression2(test, this.loc);
        auto texpr = truthy(expr, this.loc);
        auto nexpr = new BinaryOp("==", texpr, new IntLiteral(0), this.loc);

        Expression failStr = new ArrayCat(
                new StringLiteral(this.loc.location()),
                new StringLiteral(": '" ~ this.exprText ~ "' was false"),
                this.loc);
        Expression false_ = new IntLiteral(0);
        Statement printSt = new ExprStatement(new Call(printFun, new Expression[](0) ~ failStr, this.loc));
        Statement failSt = new ExprStatement(new Call(assertFun, new Expression[](0) ~ false_, this.loc));
        // `if (!$expression) { print($assertLocStr ~ ": '" ~ $exprText ~ "' was false."); assert(false); }`
        return StatementCompileResult(
            new IfStatement(
                nexpr,
                new SequenceStatement(new Statement[](0) ~ printSt ~ failSt),
                null),
            context);
    }
}

class ParseAssert : Macro
{
    this() { }
    override void apply(MacroArgs args) {
        auto args = args.instanceOf(ParseStatementArgs);
        if (args) {
            args.statement = this.parse(args.parser, args.lexicalContext);
        }
    }

    ASTStatement parse(Parser parser, LexicalContext context)
    {
        parser.begin();
        parser.strip();
        auto assertLoc = parser.loc();
        if (!parser.accept("assert"))
        {
            parser.revert();
            return null;
        }
        if (!parser.accept("("))
        {
            parser.revert();
            return null;
        }
        parser.commit();
        auto exprStartLoc = parser.loc();
        auto expression = parseExpression(parser, context);
        auto exprEndLoc = parser.loc();
        auto exprText = exprStartLoc.text[0 .. exprStartLoc.text.length - exprEndLoc.text.length];

        parser.expect(")");
        parser.expect(";");

        return new ASTAssertion(expression, exprText, exprStartLoc);
    }
}

void assertMacro(MacroState macroState)
{
    macroState.addMacro(new ParseAssert);
}

macro(assertMacro);
