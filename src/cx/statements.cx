module cx.statements;

import backend.base;
import cx.base;
import cx.expr;
import cx.parser;
import cx.parser_base;
import helpers;

// TODO Statement, Context
struct StatementCompileResult
{
    Statement statement;

    Context context;
}

class ASTStatement
{
    StatementCompileResult compile(Context context) { assert(false); }
}

class ASTAssignStatement : ASTStatement
{
    ASTSymbol target;

    ASTSymbol value;

    Loc loc;

    this(ASTSymbol target, ASTSymbol value, Loc loc)
    {
        this.target = target;
        this.value = value;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        Symbol target = this.target.compile(context);
        Expression value = beExpression2(this.value.compile(context), this.loc);
        Reference targetref = target.instanceOf(Reference);
        this.loc.assert2s(!!targetref, "target of assignment must be a reference");
        value = implicitConvertTo(value, targetref.type(), this.loc);
        return StatementCompileResult(
            new AssignStatement(targetref, value, this.loc),
            context);
    }
}

class AssignStatement : Statement
{
    Reference target;

    Expression value;

    Loc loc;

    this(Reference target, Expression value, Loc loc) { this.target = target; this.value = value; this.loc = loc; }

    override void emit(Generator output)
    {
        Type targetType = this.target.type();
        Type valueType = this.value.type();

        this.loc.assert2s(targetType.same(valueType), "cannot assign " ~ valueType.repr() ~ " to " ~ targetType.repr());

        int target_reg = this.target.emitLocation(output);
        int value_reg = this.value.emit(output);

        output.fun.store(valueType.emit(output.platform), target_reg, value_reg);
    }
}

class NoopStatement : Statement
{
    this() { }

    override void emit(Generator generator)
    {
    }
}

class ReturnStatement : Statement
{
    Expression value;

    this(Expression value) { this.value = value; }

    override void emit(Generator output)
    {
        int reg = this.value.emit(output);

        output.fun.ret(reg);
    }
}

class IfStatement : Statement
{
    Expression test;

    Statement then;

    Statement else_;

    this(Expression test, Statement then, Statement else_)
    {
        this.test = test;
        this.then = then;
        this.else_ = else_;
    }

    override void emit(Generator output)
    {
        int reg = this.test.emit(output);

        string label = output.fun.getLabel();
        output.fun.testBranch(reg, label ~ "_then", label ~ "_else");

        output.fun.setLabel(label ~ "_then");
        this.then.emit(output);
        output.fun.branch(label ~ "_fin");

        output.fun.setLabel(label ~ "_else");
        if (this.else_)
        {
            this.else_.emit(output);
            output.fun.branch(label ~ "_fin");
        }
        output.fun.setLabel(label ~ "_fin");
    }
}

class ASTBreakStatement : ASTStatement
{
    Loc loc;

    this(Loc loc) { this.loc = loc; }

    override StatementCompileResult compile(Context context)
    {
        auto loopScope = findLoopScope(context.scope_);
        this.loc.assert2s(!!loopScope, "Cannot 'break': not in a loop.");
        // TODO add cleanup statements from intervening scopes
        return StatementCompileResult(loopScope.breakFrom(context), context);
    }
}

class ASTContinueStatement : ASTStatement
{
    Loc loc;

    this(Loc loc) { this.loc = loc; }

    override StatementCompileResult compile(Context context)
    {
        auto loopScope = findLoopScope(context.scope_);
        this.loc.assert2s(!!loopScope, "Cannot 'continue': not in a loop.");
        // TODO add cleanup statements from intervening scopes
        return StatementCompileResult(loopScope.continueFrom(context), context);
    }
}

class Branch : Statement
{
    string label;

    this(string label) { this.label = label; }

    override void emit(Generator output)
    {
        output.fun.branch(this.label);
    }
}

class ASTExprStatement : ASTStatement
{
    ASTSymbol value;

    this(ASTSymbol value) { this.value = value; }

    override StatementCompileResult compile(Context context)
    {
        return StatementCompileResult(
            new ExprStatement(beExpression(this.value.compile(context))),
            context);
    }
}

class ExprStatement : Statement
{
    Expression value;

    this(Expression value) { this.value = value; }

    override void emit(Generator output)
    {
        this.value.emit(output); // discard reg
    }
}

/**
 * Generic loop class, covering For and While.
 *
 *  setup // may be null for while loop
 * start:
 *  if (!condition) goto break
 *  body
 * continue:
 *  loopstep // may be null for while loop
 *  goto start
 * break:
 */
class Loop : Statement
{
    string label;

    Statement setup;

    Expression condition;

    Statement body_;

    Statement loopstep;

    this(string label, Statement setup, Expression condition, Statement body_, Statement loopstep) {
        this.label = label;
        this.setup = setup;
        this.condition = condition;
        this.body_ = body_;
        this.loopstep = loopstep;
    }

    override void emit(Generator output)
    {
        if (this.setup) this.setup.emit(output);

        output.fun.branch(label ~ "_start");

        output.fun.setLabel(label ~ "_start"); // start:
        int condReg = this.condition.emit(output);
        output.fun.testBranch(condReg, label ~ "_body", label ~ "_break");

        output.fun.setLabel(label ~ "_body");
        this.body_.emit(output);
        output.fun.branch(label ~ "_continue");
        output.fun.setLabel(label ~ "_continue");
        if (this.loopstep) this.loopstep.emit(output);
        output.fun.branch(label ~ "_start");
        output.fun.setLabel(label ~ "_break");
    }
}

class LoopScopeImpl : LoopScope
{
    string label;
    this(string label, DeclarationScope parent)
    {
        this.label = label;
        this.parent = parent;
    }
    override Statement breakFrom(Context context) {
        return new Branch(this.label ~ "_break");
    }
    override Statement continueFrom(Context context) {
        return new Branch(this.label ~ "_continue");
    }
}

class SequenceStatement : Statement
{
    Statement[] statements;

    this(Statement[] statements) { this.statements = statements; }

    override void emit(Generator output)
    {
        for (int i = 0; i < this.statements.length; i += 1)
        {
            this.statements[i].emit(output);
        }
    }
}
