module cx.statements;

import backend.base;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser;
import cx.parser_base;
import helpers;

class ASTAssignStatement : ASTStatement
{
    ASTSymbol target;

    ASTSymbol value;

    Loc loc;

    this(this.target, this.value, this.loc) {}

    override StatementCompileResult compile(Context context)
    {
        Symbol target = this.target.compile(context);
        Expression value = beExpression2(this.value.compile(context), this.loc);
        Reference targetref = target.instanceOf(Reference);
        this.loc.assert2s(!!targetref, "target of assignment must be a reference");
        value = expectImplicitConvertTo(value, targetref.type(), this.loc);
        return StatementCompileResult(
            new AssignStatement(targetref, value),
            context);
    }
}

class AssignStatement : Statement
{
    Reference target;

    Expression value;

    this(this.target, this.value) {
        assert(target.type().same(value.type()));
    }

    override void emit(Generator output)
    {
        Type valueType = this.value.type();
        int target_reg = this.target.emitLocation(output);
        int value_reg = this.value.emit(output);

        output.fun.store(valueType.emit(output.platform), target_reg, value_reg);
    }

    override void hash(Hash hash) { hash.adds("AssignStatement"); target.hash(hash); value.hash(hash); }
}

class NoopStatement : Statement
{
    this() { }

    override void emit(Generator generator)
    {
    }

    override void hash(Hash hash) { hash.adds("NoopStatement"); }
}

class ReturnStatement : Statement
{
    Expression value;

    this(this.value) { }

    override void emit(Generator output)
    {
        int reg = this.value.emit(output);

        output.fun.ret(reg);
    }

    override void hash(Hash hash) { hash.adds("ReturnStatement"); value.hash(hash); }
}

class IfStatement : Statement
{
    Expression test;

    Statement then;

    Statement else_;

    this(this.test, this.then, this.else_) { }

    override void emit(Generator output)
    {
        int reg = this.test.emit(output);

        string label = output.fun.getLabel();
        output.fun.testBranch(reg, label ~ "_then", label ~ "_else");

        output.fun.setLabel(label ~ "_then");
        this.then.emit(output);
        output.fun.branch(label ~ "_fin");

        output.fun.setLabel(label ~ "_else");
        if (this.else_)
        {
            this.else_.emit(output);
            output.fun.branch(label ~ "_fin");
        }
        output.fun.setLabel(label ~ "_fin");
    }

    override void hash(Hash hash) {
        hash.adds("IfStatement");
        test.hash(hash);
        then.hash(hash);
        if (else_) else_.hash(hash);
        else hash.adds("no else");
    }
}

class ASTBreakStatement : ASTStatement
{
    Loc loc;

    this(this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto loopScope = findLoopScope(context.scope_);
        this.loc.assert2s(!!loopScope, "Cannot 'break': not in a loop.");
        // TODO add cleanup statements from intervening scopes
        return StatementCompileResult(loopScope.breakFrom(context), context);
    }
}

class ASTContinueStatement : ASTStatement
{
    Loc loc;

    this(this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto loopScope = findLoopScope(context.scope_);
        this.loc.assert2s(!!loopScope, "Cannot 'continue': not in a loop.");
        // TODO add cleanup statements from intervening scopes
        return StatementCompileResult(loopScope.continueFrom(context), context);
    }
}

class Branch : Statement
{
    string label;

    this(this.label) { }

    override void emit(Generator output)
    {
        output.fun.branch(this.label);
    }

    override void hash(Hash hash) { hash.adds("Branch"); hash.adds(label); }
}

class ASTExprStatement : ASTStatement
{
    ASTSymbol value;

    this(this.value) { }

    override StatementCompileResult compile(Context context)
    {
        auto expr = beExpression(this.value.compile(context));
        return StatementCompileResult(discard(expr), context);
    }
}

// see bool temporary in Expression
Statement move(Reference target, Expression source)
{
    auto type = target.type();
    // create referenceable copy for destructor call
    // TODO hasElaborateDestructor
    if (source.temporary() && !source.type().same(new Void))
        source = new Temporary(source);
    auto copyInto = type.copyInto(target, source);
    if (!copyInto) copyInto = new AssignStatement(target, source);
    if (source.temporary()) copyInto = sequence(copyInto, type.endLifetime(source.instanceOf(Reference)));
    return copyInto;
}

class ExprStatement : Statement
{
    Expression value;

    this(this.value) { }

    override void emit(Generator output)
    {
        this.value.emit(output);
    }

    override void hash(Hash hash) { hash.adds("ExprStatement"); value.hash(hash); }
}

Statement discard(Expression expr)
{
    auto type = expr.type();
    // TODO hasElaborateDestructor?
    if (expr.temporary() && !type.same(new Void)) {
        Reference temp = new Temporary(new NullExpr(type));
        // call destructor on result
        return sequence(new AssignStatement(temp, expr), type.endLifetime(temp));
    } else {
        return new ExprStatement(expr);
    }
}

/**
 * Generic loop class, covering For and While.
 *
 *  setup // may be null for while loop
 * start:
 *  if (!condition) goto break
 *  body
 * continue:
 *  loopstep // may be null for while loop
 *  goto start
 * break:
 */
class Loop : Statement
{
    string label;

    Statement setup;

    Expression condition;

    Statement body_;

    Statement loopstep;

    this(this.label, this.setup, this.condition, this.body_, this.loopstep) { }

    override void emit(Generator output)
    {
        if (this.setup) this.setup.emit(output);

        output.fun.branch(label ~ "_start");

        output.fun.setLabel(label ~ "_start"); // start:
        int condReg = this.condition.emit(output);
        output.fun.testBranch(condReg, label ~ "_body", label ~ "_break");

        output.fun.setLabel(label ~ "_body");
        this.body_.emit(output);
        output.fun.branch(label ~ "_continue");
        output.fun.setLabel(label ~ "_continue");
        if (this.loopstep) this.loopstep.emit(output);
        output.fun.branch(label ~ "_start");
        output.fun.setLabel(label ~ "_break");
    }

    override void hash(Hash hash) {
        hash.adds("LoopStatement");
        hash.adds(label);
        if (setup) setup.hash(hash);
        else hash.adds("no setup");
        condition.hash(hash);
        body_.hash(hash);
        if (loopstep) loopstep.hash(hash);
        else hash.adds("no loopstep");
    }
}

class LoopScopeImpl : LoopScope
{
    string label;
    this(this.label, this.parent) { }
    override Statement breakFrom(Context context) {
        return new Branch(this.label ~ "_break");
    }
    override Statement continueFrom(Context context) {
        return new Branch(this.label ~ "_continue");
    }
}

class SequenceStatement : Statement
{
    Statement[] statements;

    this(this.statements) { }

    override void emit(Generator output)
    {
        for (int i = 0; i < this.statements.length; i += 1)
        {
            this.statements[i].emit(output);
        }
    }

    override void hash(Hash hash)
    {
        hash.adds("SequenceStatement");
        hash.addl(statements.length);
        for (int i = 0; i < statements.length; i += 1)
            statements[i].hash(hash);
    }
}

Statement sequence(Statement left, Statement right)
{
    if (!left) return right;
    if (!right) return left;
    auto prevSequence = left.instanceOf(SequenceStatement);
    if (prevSequence) return new SequenceStatement(prevSequence.statements ~ right);
    return new SequenceStatement(new Statement[](0) ~ left ~ right);
}

class StatementExpression : Expression
{
    Statement statement;

    Expression expression;

    this(this.statement, this.expression) { }

    override Type type() { return this.expression.type(); }

    override int emit(Generator generator)
    {
        this.statement.emit(generator);
        return this.expression.emit(generator);
    }

    override void hash(Hash hash) {
        hash.adds("StatementExpression");
        statement.hash(hash);
        expression.hash(hash);
    }
}
