module cx.expr;

macro import cx.macros.hash;

import backend.base;
import cx.array;
import cx.base;
import cx.hash;
import cx.parser;
import cx.parser_base;
import cx.types;
import helpers;

Expression expectImplicitConvertTo(Expression from, Type to, Loc loc)
{
    auto result = implicitConvertTo(from, to);
    if (result) return result;
    loc.assert2s4(false, "todo: cast(", to.repr(), ") ", from.type().repr());
}

Expression implicitConvertTo(Expression from, Type to)
{
    if (from.type().same(to)) return from;
    // void* casts to any pointer
    if (to.instanceOf(Pointer) && from.type().same(new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    if (from.type().instanceOf(Integer) && to.instanceOf(Long))
    {
        return new IntToLong(from);
    }
    if (from.type().instanceOf(Short) && to.instanceOf(Integer))
    {
        return new ShortToInt(from);
    }
    if (from.type().instanceOf(Short) && to.instanceOf(Long))
    {
        return new IntToLong(new ShortToInt(from));
    }
    if (from.type().instanceOf(Integer) && to.instanceOf(Float))
    {
        return new IntToFloat(from);
    }
    // short-sized literals shrink to short
    auto literal = from.instanceOf(IntLiteral);

    if (literal && to.instanceOf(Short) && literal.value >= -32768 && literal.value <= 32767)
    {
        return new ShortLiteral(literal.value);
    }
    // FIXME byte
    if (literal && to.instanceOf(Character) && literal.value >= -128 && literal.value <= 127)
    {
        return new CharLiteral(literal.value);
    }
    // any pointer casts to void*
    if (from.type().instanceOf(Pointer) && to.same(new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    Expression fromImplicit = to.implicitConvertFrom(from);
    if (fromImplicit) return fromImplicit;
    Expression toImplicit = from.type().implicitConvertTo(from, to);
    if (toImplicit) return toImplicit;
    return null;
}

class BinaryOp : Expression
{
    string op;

    Expression left;

    Expression right;

    Loc loc;

    this(this.op, this.left, this.right, this.loc) { }

    override Type type()
    {
        string op = this.op;
        if (op == "+" || op == "-" || op == "*" || op == "/" || op == "&" || op == "|") {
            Type rightType = this.right.type();
            if (rightType.instanceOf(Long)) return rightType;
            if (rightType.instanceOf(Float)) return rightType;
            return this.left.type();
        }
        if (op == "==" || op == ">=" || op == "<=" || op == ">" || op == "<" || op == "is")
            return new Integer;
        assert(false);
    }

    override int emit(Generator output)
    {
        Expression left = this.left;
        Expression right = this.right;
        auto ltype = left.type();
        auto rtype = right.type();
        if (ltype.instanceOf(Integer) && rtype.instanceOf(Long)) {
            left = new IntToLong(left);
            ltype = rtype;
        }
        if (ltype.instanceOf(Long) && rtype.instanceOf(Integer)) {
            right = new IntToLong(right);
            rtype = ltype;
        }
        if (ltype.instanceOf(Integer) && rtype.instanceOf(Float)) {
            left = new IntToFloat(left);
            ltype = rtype;
        }
        if (ltype.instanceOf(Float) && rtype.instanceOf(Integer)) {
            right = new IntToFloat(right);
            rtype = ltype;
        }
        string op = this.op;
        if (this.op == "is")
        {
            op = "==";
        }
        else
        {
            this.loc.assert2s3(
                ltype.instanceOf(Integer) || ltype.instanceOf(Long) ||
                ltype.instanceOf(Float) || ltype.instanceOf(Character),
                this.op, " (l) expected int/float/long/char, not ", ltype.repr());
        }
        this.loc.assert2s5(!!ltype.same(rtype),
            this.op, ": types don't match, ", ltype.repr(), ", ", rtype.repr());
        int leftreg = left.emit(output);
        int rightreg = right.emit(output);
        return output.fun.binop(op, ltype.emit(output.platform), leftreg, rightreg);
    }

    override void hash(Hash hash) { hash.adds("BinaryOp"); hash.adds(op); left.hash(hash); right.hash(hash); }
}

class PointerOffset : Expression
{
    Expression pointer;

    Expression offset;

    this(this.pointer, this.offset)
    {
        assert(!!this.pointer.type().instanceOf(Pointer));
    }

    override Type type()
    {
        return pointer.type();
    }

    override int emit(Generator output)
    {
        auto type = pointer.type().instanceOf(Pointer);

        int baseReg = pointer.emit(output);
        int offsetReg = offset.emit(output);
        return output.fun.ptrOffset(type.target.emit(output.platform), baseReg, offsetReg);
    }

    override void hash(Hash hash) { hash.adds("PointerOffset"); pointer.hash(hash); offset.hash(hash); }
}

class IntToLong : Expression
{
    Expression intValue;

    this(this.intValue) { }

    override Type type() { return new Long; }

    override int emit(Generator output) {
        assert(!!this.intValue.type().instanceOf(Integer));

        int intValue = this.intValue.emit(output);
        return output.fun.signExtend(intValue, new BackendIntType, new BackendLongType);
    }

    override void hash(Hash hash) { hash.adds("IntToLong"); intValue.hash(hash); }
}

class ShortToInt : Expression
{
    Expression shortValue;

    this(this.shortValue) { }

    override Type type() { return new Integer; }

    override int emit(Generator output) {
        assert(!!this.shortValue.type().instanceOf(Short));

        int shortValue = this.shortValue.emit(output);
        return output.fun.signExtend(shortValue, new BackendShortType, new BackendIntType);
    }

    override void hash(Hash hash) { hash.adds("ShortToInt"); shortValue.hash(hash); }
}

class IntToFloat : Expression
{
    Expression intValue;

    this(this.intValue) { }

    override Type type() { return new Float; }

    override int emit(Generator output) {
        assert(!!this.intValue.type().instanceOf(Integer));

        int intValue = this.intValue.emit(output);
        return output.fun.intToFloat(intValue);
    }

    override void hash(Hash hash) { hash.adds("IntToFloat"); intValue.hash(hash); }
}

class BoolOr : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        /**
         * result = left;
         * if (left) goto past;
         * result = right;
         * past:
         */
        auto stack = output.fun.saveStack();
        BackendType intType = new BackendIntType;
        int result = output.fun.alloca(intType);

        int leftValue = this.left.emit(output);
        output.fun.store(intType, result, leftValue);

        auto label = output.fun.getLabel();
        output.fun.testBranch(leftValue, label ~ "_past", label ~ "_right"); // if (left)
        output.fun.setLabel(label ~ "_right");

        int rightValue = this.right.emit(output);
        output.fun.store(intType, result, rightValue);
        output.fun.branch(label ~ "_past");

        output.fun.setLabel(label ~ "_past");
        auto res = output.fun.load(intType, result);
        output.fun.restoreStack(stack);
        return res;
    }

    override void hash(Hash hash) { hash.adds("BoolOr"); left.hash(hash); right.hash(hash); }
}

class BoolAnd : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        /**
         * result = left;
         * if (left) result = right;
         */
        auto stack = output.fun.saveStack();
        BackendType intType = new BackendIntType;
        int result = output.fun.alloca(intType);

        int leftValue = this.left.emit(output);
        output.fun.store(intType, result, leftValue);

        auto label = output.fun.getLabel();
        output.fun.testBranch(leftValue, label ~ "_true", label ~ "_past"); // if (left)
        output.fun.setLabel(label ~ "_true");

        int rightValue = this.right.emit(output);
        output.fun.store(intType, result, rightValue);
        output.fun.branch(label ~ "_past");

        output.fun.setLabel(label ~ "_past");
        auto ret = output.fun.load(intType, result);
        output.fun.restoreStack(stack);
        return ret;
    }

    override void hash(Hash hash) { hash.adds("BoolAnd"); left.hash(hash); right.hash(hash); }
}

class IntLiteral : Expression
{
    int value;
    this(this.value) { }
    override Type type() { return new Integer; }
    override int emit(Generator output) { return output.fun.intLiteral(this.value); }
    override void hash(Hash hash) { hash.adds("IntLiteral"); hash.addl(value); }
}

class LongLiteral : Expression
{
    long value;
    this(this.value) { }
    override Type type() { return new Long; }
    override int emit(Generator output) { return output.fun.longLiteral(this.value); }
    override void hash(Hash hash) { hash.adds("LongLiteral"); hash.addl(value); }
}

class ShortLiteral : Expression
{
    int value;

    this(this.value) { }

    override Type type()
    {
        return new Short;
    }

    override int emit(Generator output)
    {
        return output.fun.shortLiteral(this.value);
    }

    override void hash(Hash hash) { hash.adds("ShortLiteral"); hash.addl(value); }
}

class CharLiteral : Expression
{
    int value;

    this(this.value) { }

    override Type type()
    {
        return new Character;
    }

    override int emit(Generator output)
    {
        return output.fun.byteLiteral(this.value);
    }

    override void hash(Hash hash) { hash.adds("CharLiteral"); hash.addl(value); }
}

class FloatLiteral : Expression
{
    float value;

    this(this.value) { }

    override Type type()
    {
        return new Float;
    }

    override int emit(Generator output)
    {
        return output.fun.floatLiteral(this.value);
    }

    override void hash(Hash hash) { hash.adds("FloatLiteral"); hash.adds(ftoa(value)); }
}

class StringLiteral : StringLiteralBase
{
    this(this.text) { }

    override Type type()
    {
        return new Array(new Character);
    }

    override int emit(Generator output)
    {
        int len = output.fun.wordLiteral(output.platform, this.text.length);
        int ptr = output.fun.stringLiteral(this.text);
        int nullptr = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), output.platform.voidp());

        return makeArray(output, new Character, len, ptr, nullptr);
    }

    override void hash(Hash hash) { hash.adds("StringLiteral"); hash.adds(text); }
}

class Call : Expression
{
    FunctionDeclaration fun;

    Expression[] args;

    Loc loc;

    this(this.fun, this.args, this.loc)
    {
        loc.assert2s5(
            fun.numArgs() == args.length,
            fun.name, " expected ", ltoa(fun.numArgs()), " args, not ", ltoa(args.length));
        int extra = !!fun.thisType;
        // TODO why not thisType?
        if (extra) args[0] = expectImplicitConvertTo(args[0], new Pointer(new Void), loc);
        for (int i = 0; i < fun.args.length; i += 1) {
            args[extra + i] = expectImplicitConvertTo(args[extra + i], fun.args[i].type, loc);
        }
    }

    override Type type()
    {
        return this.fun.ret;
    }

    override int emit(Generator output)
    {
        this.fun.declare(output);

        int[] regs = new int[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) {
            regs[i] = this.args[i].emit(output);
        }
        return output.fun.call(this.type().emit(output.platform), this.fun.mangle(), regs);
    }

    override void hash(Hash hash) {
        hash.adds("Call");
        hash.adds(fun.mangle());
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

Expression truthy(Expression value, Loc loc) {
    Type type = value.type();
    loc.assert2s(!!type, "internal error");
    Expression truthyExpr = type.truthy(value, loc);
    if (truthyExpr) return truthyExpr;

    if (type.instanceOf(Pointer))
    {
        Type voidp = new Pointer(new Void);
        FunctionDeclaration rt_ptr_test = new FunctionDeclaration("cxruntime_ptr_test",
            new Integer,
            [Argument(false, "", voidp)]);
        Expression ptrCast = new PointerCast(voidp, value);
        return new Call(rt_ptr_test, [ptrCast], loc);
    }
    loc.assert2s(type.instanceOf(Integer) || type.instanceOf(Long), "integer expected");
    // (a == 0) == 0
    return new BinaryOp(
        "==",
        new BinaryOp("==", value, new IntLiteral(0), loc),
        new IntLiteral(0), loc);
}

class ASTBinaryOp : ASTSymbol
{
    string op;

    ASTSymbol left;

    ASTSymbol right;

    Loc loc;

    this(this.op, this.left, this.right, this.loc) { }

    override Expression compile(Context context)
    {
        Expression left = beExpression2(this.left.compile(context), this.loc);
        Expression right = beExpression2(this.right.compile(context), this.loc);
        if (this.op == "~")
        {
            auto converted = implicitConvertTo(right, left.type().instanceOf(Array).elementType);
            if (converted)
                return context.compiler.binaryOp2("~", context, left, converted, this.loc);

            return context.compiler.binaryOp2("~", context, left, right, this.loc);
        }
        if (this.op == "&&")
            return new BoolAnd(truthy(left, this.loc), truthy(right, this.loc));
        if (this.op == "||")
            return new BoolOr(truthy(left, this.loc), truthy(right, this.loc));
        if (this.op == "==" && left.type().instanceOf(Array) && right.type().instanceOf(Array))
            return new ArrayEqual(left, right);

        return new BinaryOp(this.op, left, right, this.loc);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astBinaryOp", [
            quoter.compiler.astStringLiteral(op, loc.reloc),
            left.quote(quoter),
            right.quote(quoter)], loc.reloc);
    }
}

class ReferenceExpression : Expression
{
    Reference base;

    this(this.base) { }

    override Type type()
    {
        Type superType = this.base.type();

        return new Pointer(superType);
    }

    override int emit(Generator output)
    {
        return this.base.emitLocation(output);
    }

    override bool temporary() { return base.temporary(); }

    override void hash(Hash hash) { hash.adds("ReferenceExpression"); base.hash(hash); }
}

class UninitializedTemporary : Reference
{
    Type type_;

    string label;

    this(this.type_)
    {
        this.label = ptrId(this);
    }

    override Type type() { return this.type_; }

    override int emitLocation(Generator output)
    {
        if (output.fun.hasNamedReg(label))
            return output.fun.getNamedReg(label);

        BackendType type = this.type_.emit(output.platform);
        int ptr = output.fun.alloca(type);

        output.fun.setNamedReg(label, ptr);
        return ptr;
    }

    override int emit(Generator output)
    {
        auto type = this.type().emit(output.platform);

        return output.fun.load(type, emitLocation(output));
    }

    override void hash(Hash hash) {
        hash.adds("temporary");
        type_.hash(hash);
    }
}

class Temporary : Reference
{
    Expression expr;

    string label;

    this(this.expr)
    {
        this.label = ptrId(this);
    }

    override Type type() { return expr.type(); }

    override int emitLocation(Generator output)
    {
        if (output.fun.hasNamedReg(label))
            return output.fun.getNamedReg(label);

        BackendType type = this.type().emit(output.platform);
        int ptr = output.fun.alloca(type);
        int value = this.expr.emit(output);
        output.fun.store(type, ptr, value);

        output.fun.setNamedReg(label, ptr);
        return ptr;
    }

    override int emit(Generator output)
    {
        auto type = this.type().emit(output.platform);

        return output.fun.load(type, emitLocation(output));
    }

    override void hash(Hash hash) {
        hash.adds("temporary");
        expr.hash(hash);
    }
}

class CleanupStackStmt : Statement
{
    Statement child;

    this(this.child) { }

    override void emit(Generator output) {
        auto stack = output.fun.saveStack();
        child.emit(output);
        output.fun.restoreStack(stack);
    }

    override void hash(Hash hash) {
        hash.adds("cleanupStack");
        child.hash(hash);
    }
}

Statement stmtWithTemporary(Expression value, Statement delegate(Expression) callback) {
    auto temporary = new Temporary(value);
    return new CleanupStackStmt(callback(temporary));
}

class NullExpr : Expression
{
    Type type_;

    this(this.type_) { }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator generator)
    {
        if (type_.instanceOf(Integer))
            return generator.fun.intLiteral(0);
        if (type_.instanceOf(Long))
            return generator.fun.longLiteral(0);
        // TODO allocaless
        // exploit that alloca are zero initialized
        BackendType type = this.type_.emit(generator.platform);
        auto stack = generator.fun.saveStack();
        int reg = generator.fun.alloca(type);

        auto res = generator.fun.load(type, reg);
        generator.fun.restoreStack(stack);
        return res;
    }

    override void hash(Hash hash) { hash.adds("NullExpr"); type_.hash(hash); }
}
