// TODO distribute into more appropriate modules
module cx.stuff;

macro import cx.macros.either;
macro import cx.macros.hash;
macro import cx.macros.listcomprehension;
macro import cx.macros.once;
macro import cx.macros.quasiquoting;

import backend.base;
import cx.array;
import cx.base;
import cx.enums;
import cx.expr;
import cx.hash;
import cx.linenr;
import cx.parser;
import cx.parser_base;
import cx.statements;
import cx.struct_;
import cx.types;
import cx.with_;
import helpers;

struct ASTArgument
{
    string name;

    ASTSymbol type;

    Loc loc;
}

class Function : FunctionDeclaration
{
    Loc loc;

    ASTStatement statement;

    MacroState macroState;

    Namespace parent;

    bool hasThisArg;

    this(this.loc, this.name, this.ret, this.args, this.statement, this.macroState, this.hasThisArg)
    {
        this.contextType = null;
        this.parent = null;
    }

    override string mangle()
    {
        if (this.name == "main") return "_main"; // globally unique
        return this.parent.mangle() ~ "_" ~ this.name;
    }

    string repr()
    {
        string repr = this.name;
        if (hasThisArg) {
            repr = this.contextType.repr ~ "::" ~ repr;
        }
        if (auto mod = this.parent.instanceOf(Module)) repr = mod.name ~ "." ~ repr;
        return repr;
    }

    override void declare(Generator generator)
    {
        string mangle = this.mangle;
        if (generator.mod.declared(mangle)) return;

        Type voidp = once new Pointer(new Void);

        auto argTypes = [arg.type.emit(generator.platform) for arg in this.args];
        if (this.contextType)
            argTypes = [voidp.emit(generator.platform)] ~ argTypes;

        generator.mod.declare(
            mangle,
            this.ret.emit(generator.platform),
            argTypes
        );
    }

    CompiledFunction compile(CompilerBase compiler, Platform platform)
    {
        auto stackframe = new FunctionScope(this.ret, this.contextType, this.parent, this.mangle, this.loc);
        Namespace scope_ = stackframe;
        int extra = 0;
        if (this.contextType)
            extra = 1;

        auto argAssignments = new Statement[](this.args.length + extra);

        VariableDeclaration thisDecl;
        if (this.contextType)
        {
            bool owned = true; // is this right ... ?
            // unnamed variable because of "first field in stackframe is 'this'" logic
            string framePtrName;
            if (this.hasThisArg) framePtrName = "this";
            thisDecl = new VariableDeclaration(scope_, framePtrName, this.contextType, owned);

            Type voidp = once new Pointer(new Void);

            scope_ = thisDecl;

            argAssignments[0] = new AssignStatement(
                thisDecl.accessDecl,
                new PointerCast(this.contextType, new ArgExpr(0, voidp)));
        }

        auto context = makeContext(compiler, platform, scope_, this.macroState);

        for (int i = 0; i < this.args.length; i += 1) {
            Argument arg = this.args[i];
            auto argExpr = new ArgExpr(extra + i, arg.type);

            if (arg.isThisAssignment) {
                this.loc.assert2s(!!thisDecl, "no this. args outside class");

                auto target = accessMemberWithLifetime(context, thisDecl.accessDecl, arg.name, this.loc, false)
                    .instanceOf(Reference);
                this.loc.assert2s2(!!target, "not a reference: ", arg.name);

                auto stmt = arg.type.copyInto(context, target, argExpr);
                if (!stmt) stmt = new AssignStatement(target, argExpr);
                argAssignments[extra + i] = stmt;
            } else {
                auto argDecl = new VariableDeclaration(scope_, arg.name, arg.type, false);

                argAssignments[extra + i] = new AssignStatement(argDecl.accessDecl, argExpr);

                scope_ = argDecl;
            }
        }

        scope_ = new FunctionScopeStart(scope_);
        context = context.withNamespace(scope_);

        auto pair = this.statement.compile(context);
        auto compiledStatement = unwindScope(pair.context, scope_, pair.statement);

        return new CompiledFunction(this, compiledStatement, stackframe, argAssignments);
    }
}

// TODO clear all this up
abstract class FinishedSymbol
{
    abstract void emit(Generator generator) { assert(false); }
    abstract void hash(Hash hash) { assert(false); }
}

// and this
class DefineClass : FinishedSymbol
{
    Class class_;

    this(this.class_) { }

    override void emit(Generator generator)
    {
        class_.define(generator);
    }

    override void hash(Hash hash)
    {
        // only the actual vtable symbol, the methods are also hashed separately
        [hash.adds(method.mangle) for method in class_.vtable_];
    }
}

class CompiledFunction : FinishedSymbol
{
    Function fun;

    Statement compiledStatement;

    FunctionScope stackframe;

    Statement[] argAssignments;

    this(this.fun, this.compiledStatement, this.stackframe, this.argAssignments) { }

    override void emit(Generator generator)
    {
        if (!generator.once(this.fun.mangle)) { print("double-emit " ~ this.fun.mangle); assert(false); }
        // print("emit " ~ this.fun.mangle);

        assert(!generator.fun);
        Type voidp = once new Pointer(new Void);

        auto argTypes = [arg.type.emit(generator.platform) for arg in this.fun.args];
        if (this.fun.contextType)
            argTypes = [voidp.emit(generator.platform)] ~ argTypes;

        generator.fun = generator.mod.define(
            this.fun.mangle,
            this.fun.repr,
            this.fun.ret.emit(generator.platform),
            argTypes,
            this.fun.loc.toBackendLoc
        );

        generator.frameReg = generator.fun.staticAlloca(this.stackframe.structType.emit(generator.platform));

        [assignment.emit(generator) for assignment in this.argAssignments];
        this.compiledStatement.emit(generator);

        generator.fun.ret(generator.fun.voidLiteral);
        generator.fun.done;
        generator.fun = null;
        generator.frameReg = -1;
    }

    override void hash(Hash hash) {
        hash.adds("fndef");
        hash.adds(fun.mangle);
        fun.ret.hash(hash);
        if (fun.contextType) fun.contextType.hash(hash);
        else hash.adds("null");
        hash.addl(fun.args.length);
        [({ hash.adds(arg.name); arg.type.hash(hash); }) for arg in fun.args];
        this.compiledStatement.hash(hash);
    }
}

class ASTFunction
{
    Loc loc;

    string name;

    ASTSymbol ret;

    ASTArgument[] args;

    bool isDeclaration;

    ASTStatement statement;

    MacroState macroState;

    this(this.loc, this.name, this.ret, this.args, this.isDeclaration, this.statement,this.macroState) { }

    FunctionDeclaration compile(Context context)
    {
        auto arguments = [
            Argument(false, arg.name, beType(arg.loc, arg.type.compile(context))) for arg in this.args];

        if (this.isDeclaration)
        {
            return new FunctionDeclaration(
                this.name, beType(this.loc, this.ret.compile(context)), arguments);
        }

        auto fun = new Function(
            this.loc,
            this.name,
            beType(this.loc, this.ret.compile(context)),
            arguments,
            this.statement, this.macroState, false);

        fun.parent = context.namespace;
        return fun;
    }
}

ASTSymbol parseType(Parser parser, LexicalContext lexicalContext)
{
    ASTSymbol current = parseLeafType(parser, lexicalContext);
    if (!current) return null;
    while (true)
    {
        auto loc = parser.loc;
        if (parser.accept("*"))
        {
            current = new ASTPointer(current, loc);
            continue;
        }
        parser.begin;
        string identifier = parseIdentifier(parser);
        if (identifier == "function" || identifier == "delegate")
        {
            parser.expect("(");
            ASTSymbol[] args;
            while (!parser.accept(")"))
            {
                if (args.length)
                {
                    if (!parser.accept(","))
                    {
                        parser.fail("',' or ')' expected");
                    }
                }
                ASTSymbol argType = parseType(parser, lexicalContext);
                assert(!!argType);

                args ~= argType;
            }
            parser.commit;
            if (identifier == "function")
                current = new ASTFunctionPointer(current, args, loc);
            else
                current = new ASTNestedFunctionPointer(current, args, loc);
            continue;
        }
        parser.revert;
        parser.begin;
        if (parser.accept("[") && parser.accept("]"))
        {
            parser.commit;

            current = new ASTArray(current, parser.loc);
            continue;
        }
        parser.revert;
        // what about templates that don't contain types? instead of duplicating this,
        // there should be a function to parse an ast symbol and that symbol should
        // be able to compile to a Type (Symbol).
        // But for now, templates only have types.
        // (this will also be needed to have things like Foo.Bar for nested types.)
        {
            parser.begin;
            auto instanceLoc = parser.loc;
            // TODO better way to exclude all the negated operators
            if (parser.accept("!") && !parser.accept("=") && !acceptIdentifier(parser, "is"))
            {
                auto templateArg = parseType(parser, lexicalContext);
                parser.assert_(!!templateArg, "template argument required");
                parser.commit;
                current = new ASTTemplateInstance(current, templateArg, instanceLoc);
                continue;
            }
            parser.revert;
        }
        return current;
    }
}

ASTArgument[] parseIdentifierList(Parser parser, LexicalContext lexicalContext)
{
    ASTArgument[] args;
    while (!parser.accept(")"))
    {
        if (args.length) {
            if (!parser.accept(",")) {
                parser.fail("',' or ')' expected");
            }
        }
        auto loc = parser.loc;
        ASTSymbol argtype = parseType(parser, lexicalContext);
        if (!argtype) {
            parser.fail("type expected");
        }
        string argname = parseIdentifier(parser);
        args ~= ASTArgument(argname, argtype, loc);
    }
    return args;
}

class ArgExpr : Expression
{
    int index;

    Type type_;

    this(this.index, this.type_) { }

    override int emit(Generator output)
    {
        return output.fun.arg(this.index);
    }

    override Type type()
    {
        return this.type_;
    }

    override ExprInfo info() { return ExprInfo(Ownership.borrowed); }

    override void hash(Hash hash) { hash.adds("ArgExpr"); hash.addl(index); }
}

class FuncPtrCall : Expression
{
    Expression funcPtr;

    Expression[] args;

    Loc loc;

    this(this.funcPtr, this.args, this.loc) { }

    override Type type()
    {
        return this.funcPtr.type.instanceOf(FunctionPointer).ret;
    }

    override int emit(Generator output)
    {
        FunctionPointer type = this.funcPtr.type.instanceOf(FunctionPointer);

        this.loc.assert2s4(
            type.args.length == this.args.length,
            "expected ", ltoa(type.args.length), " args, not ", ltoa(this.args.length));

        int[] regs = new int[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1)
        {
            regs[i] = this.args[i].emit(output);
        }
        return output.fun.callFuncPtr(
            type.emit(output.platform), this.funcPtr.emit(output), regs);
    }

    // we take over the returned value
    override ExprInfo info() { return ExprInfo(Ownership.gifted); }

    override void hash(Hash hash) {
        hash.adds("FuncPtrCall");
        funcPtr.hash(hash);
        hash.addl(args.length);
        [arg.hash(hash) for arg in args];
    }
}

class DelegateExpr : Expression
{
    Expression funcPtr;

    Expression thisPtr;

    this(this.funcPtr, this.thisPtr) { }

    override Type type()
    {
        FunctionPointer type = this.funcPtr.type.instanceOf(FunctionPointer);

        // drop thisptr - implicit!
        assert(type.args.length >= 1);
        // TODO this smells.
        return new NestedFunctionPointer(type.ret, type.args[1 .. $]);
    }

    override int emit(Generator output)
    {
        int thisReg = this.thisPtr.emit(output);
        int funcReg = this.funcPtr.emit(output);
        auto voidp = output.platform.voidp;
        auto thisType = this.type.emit(output.platform);
        int nullReg = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), voidp);
        return output.fun.structLiteral(thisType, [nullReg, thisReg, funcReg]);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("DelegateExpr"); this.funcPtr.hash(hash); this.thisPtr.hash(hash); }
}

class DelegateDataPtr : Expression
{
    Expression dg;

    this(this.dg) { }

    override Type type()
    {
        return once new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        int reg = this.dg.emit(output);

        return output.fun.field(this.dg.type.emit(output.platform), reg, 1);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("DelegateDataPtr"); this.dg.hash(hash); }
}

class DelegateFuncPtr : Expression
{
    Expression dg;

    this(this.dg) { }

    override Type type()
    {
        auto nestfp = this.dg.type.instanceOf(NestedFunctionPointer);
        assert(!!nestfp);
        auto argTypes = [once (new Pointer(new Void)).instanceOf(Type)] ~ nestfp.args;
        return new FunctionPointer(nestfp.ret, argTypes);
    }

    override int emit(Generator output)
    {
        int reg = this.dg.emit(output);

        return output.fun.field(this.dg.type.emit(output.platform), reg, 2);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("DelegateFuncPtr"); this.dg.hash(hash); }
}

Expression call(Context context, Symbol target, Expression[] args, Loc loc, bool autoCall)
{
    Expression[] args = args; // TODO mut Expression[] args,
    if (auto fundecl = target.instanceOf(FunctionDeclaration))
    {
        args = [expectImplicitConvertTo(context, arg, fundecl.args[i].type, loc) for i, arg in args];
        return new Call(fundecl, args, loc);
    }
    if (ClassMethodPtr method = target.instanceOf(ClassMethodPtr))
    {
        if (auto base = method.funcPtr.type.instanceOf(FunctionReferenceBase)) {
            auto fundecl = base.getFunction;
            if (args.length == fundecl.args.length) loc.fail("wrong number of args: " ~ ltoa(args.length));
            args = [expectImplicitConvertTo(context, arg, fundecl.args[i].type, loc) for i, arg in args];
        } else {
            if (auto funcptr = method.funcPtr.type.instanceOf(FunctionPointer)) {
                // this ptr
                if (args.length != funcptr.args.length - 1)
                    loc.fail("wrong number of arguments: expected " ~ ltoa(funcptr.args.length - 1)
                        ~ " but got " ~ ltoa(args.length));
                args = [expectImplicitConvertTo(context, arg, funcptr.args[i+1], loc) for i, arg in args];
            } else {
                loc.fail("function reference or funcptr expected? but is '" ~ method.funcPtr.type.repr ~ "'");
            }
        }
        auto voidp = once new Pointer(new Void);
        Expression[] combinedArgs;
        combinedArgs ~= new PointerCast(voidp, method.thisPtr);
        combinedArgs ~= args;
        return new FuncPtrCall(method.funcPtr, combinedArgs, loc);
    }
    Expression expr = target.instanceOf(Expression);
    // TODO
    // auto funcptr = expr?.type.instanceOf(FunctionPointer);
    FunctionPointer funcptr;
    if (expr) funcptr = expr.type.instanceOf(FunctionPointer);
    if (expr && funcptr && !autoCall)
    {
        args = [expectImplicitConvertTo(context, arg, funcptr.args[i], loc) for i, arg in args];
        return new FuncPtrCall(expr, args, loc);
    }
    NestedFunctionPointer nestedfuncptr;
    if (expr) nestedfuncptr = expr.type.instanceOf(NestedFunctionPointer);
    // TODO unfuck this: nested functions and methods should not be expressions
    if (expr && nestedfuncptr && !autoCall)
    {
        args = [expectImplicitConvertTo(context, arg, nestedfuncptr.args[i], loc) for i, arg in args];
        // TODO cache delegate
        auto funcPtr = new DelegateFuncPtr(expr);
        auto thisPtr = new DelegateDataPtr(expr);
        Expression[] combinedArgs;
        combinedArgs ~= thisPtr;
        combinedArgs ~= args;
        return new FuncPtrCall(funcPtr, combinedArgs, loc);
    }
    if (autoCall) return null;
    if (Struct struct_ = target.instanceOf(Struct))
    {
        loc.assert2s(args.length == struct_.members.length, "invalid number of args for struct constructor");

        auto temp = new PairedTemporary(struct_, true);
        Statement initialize = new UninitializeTemporaryStatement(temp);
        for (int i = 0; i < args.length; i += 1) {
            auto arg = args[i];
            arg = expectImplicitConvertTo(context, arg, struct_.members[i].type, loc);

            auto field = new StructMemberReference(temp, i);
            auto stmt = arg.type.copyInto(context, field, arg);
            if (!stmt) stmt = new AssignStatement(field, arg);

            initialize = sequence(initialize, stmt);
        }
        return new StatementExpression(initialize, temp, false);
    }
    loc.assert2s(false, "unknown call target");
}

class WrapExpression : Expression
{
    Statement pre;
    Expression value;
    Statement post;

    this(this.pre, this.value, this.post) { }

    override Type type() { return value.type; }

    override int emit(Generator generator)
    {
        if (pre) pre.emit(generator);
        int result = value.emit(generator);
        if (post) post.emit(generator);
        return result;
    }

    override ExprInfo info() { return value.info; }

    override void hash(Hash hash) {
        hash.adds("WrapExpression");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        value.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }
}

/**
 * This type is a bit risky.
 * Because result is returned after post() is called,
 * `WrapReference` can leak the location of a value that
 * has no references. As such, it should only be used when
 * `reference` doesn't yield an address managed by `pre`/`post`.
 */
class WrapReference : Reference
{
    Statement pre;
    Reference reference;
    Statement post;

    this(this.pre, this.reference, this.post) { }

    override Type type() { return reference.type; }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        if (pre) pre.emit(output);
        int result = reference.emitLocation(output);
        if (post) post.emit(output);
        return result;
    }

    override ExprInfo info() { return reference.info; }

    override void hash(Hash hash) {
        hash.adds("WrapReference");
        if (pre) pre.hash(hash);
        else hash.adds("null");
        reference.hash(hash);
        if (post) post.hash(hash);
        else hash.adds("null");
    }
}

Expression callWithLifetime(Context context, Symbol target, Expression[] args, Loc loc, bool autoCall) {
    Symbol target = target; // TODO mut Symbol target
    // TODO
    // assert(!target.instanceOf(Expression));
    Statement pre, post;
    for (int i = 0; i < args.length; i += 1) {
        auto arg = args[i];
        // we must free arg after the call, so make a copy
        if (arg.info.ownership == Ownership.gifted) {
            auto temp = new PairedTemporary(arg.type, false);
            // no copyInto() because we're taking ownership.
            auto set = new InitializeTemporaryStatement(temp, arg);
            if (auto destructor = arg.type.endLifetime(context, temp)) {
                pre = sequence(pre, set);
                post = sequence(destructor, post);
                arg = temp;
            }
        }
        args[i] = arg;
    }
    ClassMethodPtr method = target.instanceOf(ClassMethodPtr);
    if (method && method.thisPtr.info.ownership == Ownership.gifted) { // foo().bar()
        auto thisPtrType = method.thisPtr.type;
        // for endLifetime call
        auto tempThisPtr = new PairedTemporary(thisPtrType, true);
        Statement setThisPtr = new InitializeTemporaryStatement(tempThisPtr, method.thisPtr);
        if (Statement cleanupThisPtr = thisPtrType.endLifetime(context, tempThisPtr))
        {
            pre = sequence(pre, setThisPtr);
            post = sequence(cleanupThisPtr, post);
            target = new ClassMethodPtr(method.funcPtr, tempThisPtr);
        }
    }
    auto callResult = call(context, target, args, loc, autoCall);
    if (!callResult) return null;
    return new WrapExpression(pre, callResult, post);
}

class ASTCall : ASTSymbol
{
    ASTSymbol target;

    ASTSymbol[] args;

    Loc loc;

    this(this.target, this.args, this.loc) { }

    override Expression compile(Context context)
    {
        auto callMacroArgs = new CallMacroArgs(this.target, this.args, context, this.loc);
        context.macroState.applyMacro(callMacroArgs);
        if (callMacroArgs.transformed) return callMacroArgs.transformed;

        auto target = this.target.compile(context);
        auto args = [beExpression3(context, arg.compile(context), this.loc) for arg in this.args];

        return callWithLifetime(context, target, args, this.loc, false);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto args = [arg.quote(quoter) for arg in this.args];
        return quoter.compilerCall("astCall", [
            this.target.quote(quoter),
            quoter.compiler.astArrayLiteral(args, this.loc.reloc)
        ], this.loc.reloc);
    }
}

ASTSymbol[] parseSymbolList(Parser parser, LexicalContext lexicalContext)
{
    ASTSymbol[] args;
    while (!parser.accept(")"))
    {
        if (args.length > 0)
            parser.expect(",");

        args ~= parseExpression(parser, lexicalContext);
    }
    return args;
}

ASTCall parseCall(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin;
    if (!parser.accept("("))
    {
        parser.revert;
        return null;
    }
    auto args = parseSymbolList(parser, lexicalContext);
    parser.commit;
    return new ASTCall(base, args, parser.loc);
}

class ASTIndexAccess : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol index;

    Loc loc;

    this(this.base, this.index, this.loc) { }

    override Expression compile(Context context)
    {
        Expression base = beExpression3(context, this.base.compile(context), this.loc);

        Expression do_(Reference base)
        {
            auto type = base.type;
            Expression indexExpr;
            Expression ptrBase;

            if (Array array_ = type.instanceOf(Array)) {
                auto context = context.withNamespace(
                    context.compiler.exprAlias(context.namespace, "__array", base));

                indexExpr = beExpression3(context, this.index.compile(context), this.loc);
                // TODO bounds check
                ptrBase = new ArrayPointer(array_.elementType, base);
            } else {
                if (!type.instanceOf(Pointer)) {
                    this.loc.fail("index access requires pointer or array");
                }
                indexExpr = beExpression3(context, this.index.compile(context), this.loc);
                ptrBase = base;
            }

            indexExpr = expectImplicitConvertTo(context, indexExpr, context.nativeWordType, this.loc);

            assert(indexExpr.type.same(context.nativeWordType));
            return new Dereference(new PointerOffset(ptrBase, indexExpr));
        }
        return context.compiler.consumeTemporary(context, true, base, &do_);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astIndex", [base.quote(quoter), index.quote(quoter)], loc.reloc);
    }
}

class ASTArraySlice : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lower;

    ASTSymbol upper;

    Loc loc;

    this(this.array, this.lower, this.upper, this.loc) { }

    override Symbol compile(Context context)
    {
        Type sizeT = context.nativeWordType;
        auto array = beExpression3(context, this.array.compile(context), this.loc);

        Expression do_(Reference array)
        {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "__array", array));

            return new ArraySlice(
                array,
                expectImplicitConvertTo(
                    context, beExpression3(context, this.lower.compile(context), this.loc), sizeT, this.loc),
                expectImplicitConvertTo(
                    context, beExpression3(context, this.upper.compile(context), this.loc), sizeT, this.loc),
                this.loc);
        }
        return context.compiler.consumeTemporary(context, false, array, &do_);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astArraySlice", [
            this.array.quote(quoter),
            this.lower.quote(quoter),
            this.upper.quote(quoter)], loc.reloc);
    }
}

ASTSymbol parseIndex(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin;
    if (!parser.accept("["))
    {
        parser.revert;
        return null;
    }
    ASTSymbol index = parseExpression(parser, lexicalContext);
    assert(!!index); // "index expected"
    if (parser.accept(".."))
    {
        ASTSymbol lower = index;
        ASTSymbol upper = parseExpression(parser, lexicalContext);
        parser.assert_(!!upper, "slice upper bound expected");
        parser.expect("]");
        parser.commit;
        return new ASTArraySlice(base, lower, upper, parser.loc);
    }
    parser.expect("]");
    parser.commit;
    return new ASTIndexAccess(base, index, parser.loc);
}

Symbol accessMemberWithLifetime(Context context, Symbol base, string member, Loc loc, bool allowUndefined)
{
    if (base.instanceOf(Type))
    {
        return accessMember(context, base, member, loc, allowUndefined);
    }
    Expression baseExpr = beExpression3(context, base, loc);
    Type baseType = baseExpr.type;

    if (baseType.instanceOf(Pointer)) {
        // cannot trace lifetimes through pointers (TODO?)
        return accessMember(context, base, member, loc, allowUndefined);
    }

    // speculative lookup :-(
    // TODO exprWithTemporary that handles symbol returns
    auto ret = accessMember(context, baseExpr, member, loc, allowUndefined);
    if (!ret || !ret.instanceOf(Expression)) return ret;
    /**
     * - temporize lhs
     * - copyInto member
     * - destroy lhs
     */
    Expression do_(Expression baseExpr) {
        auto ret = accessMember(context, baseExpr, member, loc, allowUndefined).instanceOf(Expression);
        auto tempRet = new PairedTemporary(ret.type, true); // temporary since we copyInto
        auto initTemp = new UninitializeTemporaryStatement(tempRet);
        auto copyTemp = ret.type.copyInto(context, tempRet, ret);
        if (!copyTemp) copyTemp = new AssignStatement(tempRet, ret);

        // TODO the callback should take Reference, really
        Statement endLifetime = baseType.endLifetime(context, baseExpr.instanceOf(Reference));

        return new WrapExpression(sequence(initTemp, copyTemp), tempRet, endLifetime);
    }
    // SHIT
    // we need a reference on the lhs for assignments
    // that's fine if it's a struct, but for a class? always force nontemporary, because it's contained in the
    // class lifetime?
    // TODO handle member access of temporaries
    // for instance with an ExprReturnType analogous to StatementReturnType, that gathers temp destructors

    // if lhs is nontemp, just use StructReference
    if (baseExpr.info.ownership != Ownership.gifted) {
        return accessMember(context, baseExpr, member, loc, allowUndefined)
            .instanceOf(Expression);
    }
    return context.compiler.exprWithTemporary(baseExpr, &do_);
}

Symbol accessMember(Context context, Symbol base, string member, Loc loc, bool allowUndefined) {
    if (auto type = base.instanceOf(Type)) {
        return type.accessMember(context, null, member);
    }

    loc.assert2s(!!base.instanceOf(Expression), "expected expression for member access");
    Expression baseExpr = beExpression3(context, base, loc);

    while (baseExpr.type.instanceOf(Pointer)) {
        baseExpr = new Dereference(baseExpr);
    }

    if (auto field = baseExpr.type.accessMember(context, baseExpr, member))
        return field;

    if (allowUndefined) return null;
    loc.assert2s4(false, baseExpr.type.repr, ": no such field '", member, "'");
}

class ASTMember : ASTMemberBase
{
    override Symbol compile(Context context)
    {
        return accessMemberWithLifetime(context, this.base.compile(context), this.member, this.loc, false);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astMember", [
            this.base.quote(quoter),
            quoter.compiler.astStringLiteral(this.member, loc.reloc)], loc.reloc);
    }
}

ASTMember parseMember(Parser parser, ASTSymbol base)
{
    parser.begin;
    if (parser.accept("..") || !parser.accept(".")) // don't accept '..'
    {
        parser.revert;
        return null;
    }
    string name = parseIdentifier(parser);
    parser.assert_(name.length > 0, "member expected");
    parser.commit;
    return new ASTMember(base, name, parser.loc);
}

class ASTInstanceOf : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol target;

    Loc loc;

    this(this.base, this.target, this.loc) { }

    override Symbol compile(Context context)
    {
        Expression base = beExpression3(context, this.base.compile(context), loc);
        auto type = base.type;
        loc.assert2s(!!type.instanceOf(Class), "Base of instanceOf must be a class.");
        Expression do_(Expression base) {
            Class target = target.compile(context).instanceOf(Class);
            loc.assert2s(!!target, "Target of instanceOf must be class.");
            Symbol instanceOf = accessMember(context, base, "__instanceof", loc, false);
            Expression classInfo = new ClassInfo(target);
            return new PointerCast(target, callWithLifetime(context, instanceOf, [classInfo], loc, false));
        }
        return context.compiler.exprWithTemporary(base, &do_);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTInstanceOf'"); assert(false); }
}

ASTSymbol parseInstanceOf(Parser parser, LexicalContext lexicalContext, ASTSymbol left)
{
    parser.begin;
    if (!(parser.accept(".") && parser.accept("instanceOf")))
    {
        parser.revert;
        return null;
    }
    parser.expect("(");
    ASTSymbol type = parseType(parser, lexicalContext);
    parser.expect(")");
    parser.commit;
    return new ASTInstanceOf(left, type, parser.loc);
}

ASTSymbol parseTemplateInstantiation(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin;
    auto instanceLoc = parser.loc;
    // TODO better way to exclude !operator cases
    if (!parser.accept("!") || parser.accept("=") || acceptIdentifier(parser, "is")) {
        parser.revert;
        return null;
    }
    auto templateArg = parseType(parser, lexicalContext);
    parser.assert_(!!templateArg, "template argument required");
    parser.commit;
    return new ASTTemplateInstance(base, templateArg, instanceLoc);
}

ASTSymbol parseProperties(Parser parser, LexicalContext lexicalContext, ASTSymbol current)
{
    ASTSymbol current = current; // TODO mut ASTSymbol current
    while (true)
    {
        if (ASTSymbol instanceOf = parseInstanceOf(parser, lexicalContext, current))
        {
            current = instanceOf;
            continue;
        }
        auto macroArgs = new ParsePropertyArgs(parser, lexicalContext, current);

        lexicalContext.macroState.applyMacro(macroArgs);
        if (macroArgs.result)
        {
            current = macroArgs.result;
            continue;
        }
        if (ASTSymbol call = parseCall(parser, lexicalContext, current))
        {
            current = call;
            continue;
        }
        if (ASTSymbol memberAccess = parseMember(parser, current))
        {
            current = memberAccess;
            continue;
        }
        if (ASTSymbol indexAccess = parseIndex(parser, lexicalContext, current))
        {
            current = indexAccess;
            continue;
        }
        if (ASTSymbol templateInstance = parseTemplateInstantiation(parser, lexicalContext, current))
        {
            current = templateInstance;
            continue;
        }
        return current;
    }
}

class ASTDereference : ASTSymbol
{
    ASTSymbol base;

    Loc loc;

    this(this.base, this.loc) { }

    override Symbol compile(Context context)
    {
        // TODO now that we have symbols, this should not be an expression!
        return new Dereference(beExpression(this.base.compile(context)));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall(
            "astDereference", [this.base.quote(quoter)], loc.reloc);
    }
}

class Dereference : Reference
{
    Expression base;

    Pointer pointerType;

    this(this.base)
    {
        this.pointerType = base.type.instanceOf(Pointer);
        assert(!!this.pointerType);
    }

    override Type type()
    {
        return this.pointerType.target;
    }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        return this.base.emit(output);
    }

    // avoid doing memory management until we figure out how to handle pointers.
    // (or if we need to at all.)
    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("Dereference"); base.hash(hash); }
}

class FunctionReference : FunctionReferenceBase
{
    FunctionDeclaration fun;

    Type type_;

    this(this.fun) {
        auto argTypes = [arg.type for arg in this.fun.args];
        if (this.fun.contextType) argTypes = [once (new Pointer(new Void)).instanceOf(Type)] ~ argTypes;

        this.type_ = new FunctionPointer(this.fun.ret, argTypes);
    }

    override Type type() { return this.type_; }

    override FunctionDeclaration getFunction() { return fun; }

    override int emit(Generator output)
    {
        this.fun.declare(output);

        return output.fun.getFuncPtr(this.fun.mangle);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("FunctionReference"); hash.adds(fun.mangle); }
}

class ASTReference : ASTSymbol
{
    ASTSymbol base;

    Loc loc;

    this(this.base, this.loc) { }

    override Expression compile(Context context)
    {
        // &function
        if (ASTIdentifier ident = this.base.instanceOf(ASTIdentifier)) {
            auto frame = once new ReferenceExpression(new StackFrame(new Void));
            if (Symbol target = context.namespace.lookup(ident.name, context, frame)) {
                if (Function fun = target.instanceOf(Function))
                    return new FunctionReference(fun);
                if (auto nestfn = target.instanceOf(ClassMethodPtr))
                    return new DelegateExpr(nestfn.funcPtr, nestfn.thisPtr);
            }
        }
        Expression baseExpression = beExpression2(this.base.compile(context), this.loc);

        loc.assert2s(!!baseExpression.instanceOf(Reference), "&expr: expr not a reference");

        return new ReferenceExpression(baseExpression.instanceOf(Reference));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall(
            "astReference", [this.base.quote(quoter)], loc.reloc);
    }
}

class SizeOf : Expression
{
    Type type_;

    this(this.type_) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        int size = this.type_.emit(output.platform).size(output.platform);

        return output.fun.intLiteral(size);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("SizeOf"); type_.hash(hash); }
}

class ClassInfo : Expression
{
    Class classType;

    this(this.classType) { }

    override Type type()
    {
        return once new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        this.classType.declare(output);
        // TODO declare weak to ensure they are merged
        return output.fun.symbolList(this.classType.vtableSymbol);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ClassInfo"); classType.hash(hash); }
}

class NewClassExpression : Expression
{
    Class classType;

    this(this.classType) { }

    override Type type()
    {
        return this.classType;
    }

    override int emit(Generator output)
    {
        // oh boy!
        BackendType voidp = once (new Pointer(new Void)).emit(output.platform);
        auto backendClassData = this.classType.dataStruct.emit(output.platform);
        int classDataSize = backendClassData.size(output.platform);
        int classInfoPtr = (new ClassInfo(classType)).emit(output);
        int classPtr = output.fun.call(
            voidp, "cxruntime_alloc", [output.fun.wordLiteral(output.platform, classDataSize)]);
        auto sizeT = output.platform.nativeWordType;
        int classInfoTarget = output.fun.fieldOffset(backendClassData, classPtr, 0);
        output.fun.store(voidp, classInfoTarget, classInfoPtr);
        int refCount = output.fun.fieldOffset(backendClassData, classPtr, 1);
        int one = output.fun.wordLiteral(output.platform, 1);
        output.fun.store(sizeT, refCount, one);

        return classPtr;
    }

    // the archetypal example
    override ExprInfo info() { return ExprInfo(Ownership.gifted); }

    override void hash(Hash hash) { hash.adds("NewClassExpression"); classType.hash(hash); }
}

class IgnoreLifetimeExpr : Expression
{
    Expression value;
    this(this.value) { }
    override Type type() { return value.type; }
    override int emit(Generator output) { return value.emit(output); }
    override ExprInfo info() { return ExprInfo(Ownership.owned); }
    override void hash(Hash hash) { hash.adds("IgnoreLifetimeExpr"); value.hash(hash); }
}

class ASTNewExpression : ASTSymbol
{
    ASTSymbol type;

    ASTSymbol[] args;

    Loc loc;

    this(this.type, this.args, this.loc) { }

    override Symbol compile(Context context)
    {
        Type type = beType(this.loc, this.type.compile(context));

        if (Class classType = type.instanceOf(Class)) {
            Expression classptr = new NewClassExpression(classType);

            auto argExpressions = [beExpression3(context, arg.compile(context), this.loc) for arg in this.args];
            this.loc.assert2s2(!!classType, "expected new <class>, not %s", type.repr);

            auto loc = this.loc; // TODO fix
            Expression do_(Expression classptr) {
                // don't clean up classptr after constructor call, we're continuing its lifetime
                auto ctor = accessMember(
                    context, new IgnoreLifetimeExpr(classptr), "__ctor", loc, false);
                auto ctorCall = context.compiler.exprStatement(
                    callWithLifetime(context, ctor, argExpressions, loc, false));

                return context.compiler.statementExpression(ctorCall, classptr);
            }
            return context.compiler.exprWithTemporary(classptr, &do_);
        }
        if (Array arrayType = type.instanceOf(Array)) {
            this.loc.assert2s(this.args.length == 1, "expected one argument to loc");

            Type sizeT = context.nativeWordType;
            auto length = expectImplicitConvertTo(
                context, beExpression3(context, this.args[0].compile(context), this.loc), sizeT, this.loc);
            return new ArrayAllocation(arrayType.elementType, length);
        }
        this.loc.assert2s2(false, "don't know how to allocate ", type.repr);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto quotedArgs = [arg.quote(quoter) for arg in this.args];
        return quoter.compilerCall("astNewExpression", [
            this.type.quote(quoter),
            quoter.compiler.astArrayLiteral(quotedArgs, loc.reloc)], loc.reloc);
    }
}

ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (parser.accept("*"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTDereference(next, loc);
    }
    if (parser.accept("&"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTReference(next, loc);
    }
    if (acceptIdentifier(parser, "new"))
    {
        ASTSymbol type = parseType(parser, lexicalContext);
        if (!type) {
            parser.fail("type expected");
        }
        ASTSymbol[] args;
        if (parser.accept("("))
        {
            args = parseSymbolList(parser, lexicalContext);
        }

        return new ASTNewExpression(type, args, loc);
    }
    if (acceptIdentifier(parser, "cast"))
    {
        parser.expect("(");
        ASTSymbol target = parseType(parser, lexicalContext);
        if (!target) {
            parser.fail("type expected");
        }
        parser.expect(")");
        ASTSymbol value = parseExpressionLeaf(parser, lexicalContext);

        return new ASTCastExpr(target, value, loc);
    }
    if (parser.accept("!"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTNegation(next, loc);
    }
    if (ASTSymbol expr = parseExpressionBase(parser, lexicalContext))
        return parseProperties(parser, lexicalContext, expr);
    return null;
}

class ASTIdentifier : ASTSymbol
{
    string name;

    bool moduleLevel; // .name

    Loc loc;

    this(this.name, this.moduleLevel, this.loc) { }

    override Symbol compile(Context context)
    {
        Symbol symbol;
        if (this.moduleLevel) {
            auto module_ = findModule(context.namespace);
            symbol = module_.lookup(this.name, context, null);
        } else if (context.namespace.instanceOf(Module)
            || context.namespace.instanceOf(ClassScope)
            || context.namespace.instanceOf(StructScope)) {
            // TODO namespace.isFunctionScope
            symbol = context.namespace.lookup(this.name, context, null);
        } else {
            auto stackframe = once new ReferenceExpression(new StackFrame(new Void));
            symbol = context.namespace.lookup(this.name, context, stackframe);
        }
        this.loc.assert2s2(!!symbol, this.name, " not found");
        return symbol;
    }

    override ASTSymbol quote(Quoter quoter) {
        assert(!moduleLevel);
        // $foo is quoted as 'foo'
        if (name[0 .. 1] == "$") {
            return quoter.compiler.astIdentifier(name[1 .. $], loc.reloc);
        }
        return quoter.compilerCall("astIdentifier", [
            quoter.compiler.astStringLiteral(this.name, loc.reloc)
        ], loc.reloc);
    }
}

class ASTIntLiteral : ASTSymbol
{
    int value;

    Loc loc;

    this(this.value, this.loc) { }

    override Symbol compile(Context context)
    {
        return new IntLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astIntLiteral", [
            quoter.compiler.astIntLiteral(this.value, loc.reloc)
        ], loc.reloc);
    }
}

class ASTLongLiteral : ASTSymbol
{
    long value;

    Loc loc;

    this(this.value, this.loc) { }

    override Symbol compile(Context context)
    {
        return new LongLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astLongLiteral", [
            quoter.compiler.astLongLiteral(this.value, loc.reloc)
        ], loc.reloc);
    }
}

class ASTFloatLiteral : ASTSymbol
{
    float value;

    this(this.value) { }

    override Symbol compile(Context context)
    {
        return new FloatLiteral(this.value);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTFloatLiteral'"); assert(false); }
}

class ASTStringLiteral : ASTSymbol
{
    string text;

    Loc loc;

    this(this.text, this.loc) { }

    override Symbol compile(Context context)
    {
        return new StringLiteral(this.text);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astStringLiteral", [
            quoter.compiler.astStringLiteral(this.text, loc.reloc)], loc.reloc);
    }
}

string replaceEscapes(string text)
{
    string result;
    int i;
    while (i < text.length)
    {
        string ch = text[i .. i + 1];
        i += 1;
        if (ch == "\\")
        {
            string ctl = text[i .. i + 1];
            i += 1;
            if (ctl == "r") {
                result ~= "\r";
            } else if (ctl == "n") {
                result ~= "\n";
            } else if (ctl == "t") {
                result ~= "\t";
            } else if (ctl == "\"") {
                result ~= "\"";
            } else if (ctl == "\\") {
                result ~= "\\";
            } else {
                print("Unknown control sequence \\" ~ ctl);
                assert(false);
            }
        }
        else
        {
            result ~= ch;
        }
    }
    return result;
}

ASTStringLiteral parseStringLiteral(Parser parser, string endMarker)
{
    int matchLen;
    auto loc = parser.loc;
    string start = parser.text;
    while (parser.text.length < endMarker.length || parser.text[0 .. endMarker.length] != endMarker)
    {
        if (parser.text.length == 0)
        {
            parser.fail("expected end of string, got end of file");
        }
        if (parser.text[0 .. 1] == "\\") {
            matchLen = matchLen + 1;
            parser.drop(1);
        }
        matchLen = matchLen + 1;
        parser.drop(1);
    }
    string str = start[0 .. matchLen];
    if (!parser.accept(endMarker))
    {
        parser.fail("this should never happen");
    }

    return new ASTStringLiteral(replaceEscapes(str), loc);
}

ASTSymbol parseExpressionBase(Parser parser, LexicalContext lexicalContext)
{
    {
        auto args = new ParseExpressionBaseArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (args.symbol) return args.symbol;
    }
    {
        if (ASTSymbol destroy_ = parseDestroy(parser, lexicalContext))
            return destroy_;
    }
    auto loc = parser.loc;
    parser.begin;
    if (parser.accept(".")) {
        // .name is module level
        string name = parseIdentifier(parser);
        if (name.length) {
            parser.commit;
            return new ASTIdentifier(name, true, loc);
        }
    }
    parser.revert;
    string name = parseIdentifier(parser);
    if (name.length)
    {
        if (name == "$") {
            return new ASTArrayLength(loc.reloc);
        }
        return new ASTIdentifier(name, false, loc);
    }
    float f;
    if (parseFloat(parser, &f))
    {
        return new ASTFloatLiteral(f);
    }
    int i;
    if (parseNumber(parser, &i))
    {
        return new ASTIntLiteral(i, loc);
    }
    if (parser.accept("\""))
    {
        return parseStringLiteral(parser, "\"");
    }
    if (auto statementExpr = parseStatementExpr(parser, lexicalContext))
        return statementExpr;
    if (parser.accept("("))
    {
        ASTSymbol result = parseExpression(parser, lexicalContext);

        parser.expect(")");
        return result;
    }
    {
        if (ASTSymbol result = parseArrayLiteral(parser, lexicalContext))
            return result;
    }
    return null;
    /*parser.fail("Base expression expected.");
    assert(false);*/
}

ASTSymbol parseBitAnd(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        parser.begin;
        if (parser.accept("&") && !parser.accept("&"))
        {
            parser.commit;
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("&", left, right, parser.loc);
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

ASTSymbol parseBitOr(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        parser.begin;
        if (parser.accept("|") && !parser.accept("|"))
        {
            parser.commit;
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("|", left, right, parser.loc);
        }
        else
        {
            parser.revert;
            return left;
        }
    }
}

ASTSymbol parseAddSubCat(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        if (parser.accept("+"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("+", left, right, parser.loc);
        }
        else if (parser.accept("-"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("-", left, right, parser.loc);
        }
        else if (parser.accept("~"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("~", left, right, parser.loc);
        }
        else return left;
    }
}

ASTSymbol parseMulDiv(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        if (parser.accept("*"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("*", left, right, parser.loc);
        }
        else if (parser.accept("/"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("/", left, right, parser.loc);
        }
        else return left;
    }
}

ASTSymbol parseBoolAnd(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        if (parser.accept("&&"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("&&", left, right, parser.loc);
        } else return left;
    }
}

ASTSymbol parseBoolOr(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    ASTSymbol left = left; // TODO mut ASTSymbol left
    while (true)
    {
        if (parser.accept("||"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("||", left, right, parser.loc);
        } else return left;
    }
}

class ASTNegation : ASTSymbol
{
    ASTSymbol next;

    Loc loc;

    this(this.next, this.loc) { }

    override Expression compile(Context context)
    {
        Expression isTrue = truthy(context, beExpression3(context, this.next.compile(context), this.loc), this.loc);

        return new BinaryOp("==", isTrue, new IntLiteral(0), this.loc);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astNegation", [next.quote(quoter)], loc.reloc);
    }
}

ASTSymbol parseComparison(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    if (parser.accept("=="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("==", left, right, parser.loc);
    }
    if (parser.accept("!=")) // same as !(a == b)
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTNegation(new ASTBinaryOp("==", left, right, parser.loc), parser.loc);
    }
    if (parser.accept("is"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("is", left, right, parser.loc);
    }
    if (parser.accept("!is"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTNegation(new ASTBinaryOp("is", left, right, parser.loc), parser.loc);
    }
    if (parser.accept(">="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp(">=", left, right, parser.loc);
    }
    if (parser.accept(">"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp(">", left, right, parser.loc);
    }
    if (parser.accept("<="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("<=", left, right, parser.loc);
    }
    if (parser.accept("<"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("<", left, right, parser.loc);
    }
    return left;
}

ASTSymbol parseArithmetic(Parser parser, LexicalContext lexicalContext, int level)
{
    ASTSymbol left = parseExpressionLeaf(parser, lexicalContext);

    if (level <= 6) left = parseBitAnd(parser, lexicalContext, left, 6);
    if (level <= 5) left = parseBitOr(parser, lexicalContext, left, 5);
    if (level <= 4) left = parseMulDiv(parser, lexicalContext, left, 4);
    if (level <= 3) left = parseAddSubCat(parser, lexicalContext, left, 3);
    if (level <= 2) left = parseComparison(parser, lexicalContext, left, 2);
    if (level <= 1) left = parseBoolAnd(parser, lexicalContext, left, 1);
    if (level <= 0) left = parseBoolOr(parser, lexicalContext, left, 0);
    return left;
}

ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
{
    return parseArithmetic(parser, lexicalContext, 0);
}

class ASTReturnStatement : ASTStatement
{
    ASTSymbol value;

    Loc loc;

    this(this.value, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        Expression expr = beExpression3(context, this.value.compile(context), this.loc);
        Type ret = findFunctionScope(context.namespace).ret;
        expr = expectImplicitConvertTo(context, expr, ret, this.loc);

        /**
         * - alloca
         *   - copyInto the value
         *   - or assign the value (if it's a temporary and we can steal its reference)
         * - unwind stack
         * - ret the alloca
         */
        auto temp = new PairedTemporary(ret, false);
        auto init = new UninitializeTemporaryStatement(temp);
        Statement escapeValueStmt = ret.copyInto(context, temp, expr);
        if (expr.info.ownership == Ownership.gifted || !escapeValueStmt) {
            escapeValueStmt = new AssignStatement(temp, expr);
        }
        Statement returnStmt = sequence(init, escapeValueStmt);
        returnStmt = unwindScope(context, findFunctionScopeStart(context.namespace), returnStmt);
        returnStmt = sequence(returnStmt, new ReturnStatement(temp));
        // no need for stack cleanup after a return.

        return StatementCompileResult(returnStmt, context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astReturn", [value.quote(quoter)], loc.reloc);
    }
}

// the return expression of "return;"
class ASTVoidExpression : ASTSymbol
{
    Loc loc;

    this(this.loc) { }

    override Expression compile(Context context) { return once new VoidExpression; }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol[] args;
        return quoter.compilerCall("astVoidLiteral", args, loc.reloc);
    }
}

class VoidExpression : Expression
{
    this() { }
    override Type type() { return once new Void; }
    override int emit(Generator generator)
    {
        return generator.fun.voidLiteral;
    }
    override ExprInfo info() { return ExprInfo(Ownership.owned); }
    override void hash(Hash hash) { hash.adds("VoidExpression"); }
}

ASTReturnStatement parseReturn(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    string identifier = parseIdentifier(parser);
    if (identifier != "return")
    {
        parser.revert;
        return null;
    }
    ASTSymbol expr;
    if (parser.accept(";")) // return;
    {
        expr = new ASTVoidExpression(parser.loc);
    }
    else
    {
        expr = parseExpression(parser, lexicalContext);
        parser.expect(";");
    }
    parser.commit;
    return new ASTReturnStatement(expr, parser.loc);
}

class StackFrame : Reference
{
    Type targetType;

    this(this.targetType) { }

    override Type type()
    {
        return this.targetType;
    }

    override int emit(Generator generator)
    {
        assert(false);
    }

    override int emitLocation(Generator generator)
    {
        return generator.frameReg;
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("StackFrame"); targetType.hash(hash); }
}

// variable without stackframe
class LatentVariable
{
    string name;

    Struct stackFrameType;

    int offset;

    bool owned;

    this(this.name, this.stackFrameType, this.offset, this.owned) { }
}

class FunctionScope : Namespace
{
    Type ret;

    Type extra;

    StructMemberDeclaration[] variables;

    string mangle_;

    Loc loc;

    Struct structType;

    this(this.ret, this.extra, this.parent, this.mangle_, this.loc) {
        // TODO dedicated stackframe type so we don't need to keep recreating struct type instances
        this.structType = new Struct("", this.variables, this.loc, this.mangle_);
    }

    LatentVariable declare(string name, Type type, bool owned)
    {
        this.variables ~= new StructMemberDeclaration(name, type);
        this.structType = new Struct("", this.variables, this.loc, this.mangle_);

        return new LatentVariable(name, this.structType, cast(int) this.variables.length - 1, owned);
    }

    override string mangle() { return this.mangle_; }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        assert(!!this.parent);

        Expression nextFrame;
        if (this.extra && frame)
        {
            // first field in stackframe must be parent
            // TODO better?
            auto framePtr = new PointerCast(once new Pointer(new Pointer(new Void)), frame);

            nextFrame = new Dereference(framePtr);
        }

        return this.parent.lookup(name, context, nextFrame);
    }
}

FunctionScope findFunctionScope(Namespace namespace)
{
    if (auto functionScope = namespace.instanceOf(FunctionScope))
        return functionScope;
    assert(!!namespace.parent);
    return findFunctionScope(namespace.parent);
}

// No-op marker namespace: this is the point that Return unrolls to.
class FunctionScopeStart : Namespace
{
    this(this.parent) { }

    override Symbol lookup(string name, Context context, Expression frame) {
        return parent.lookup(name, context, frame);
    }
}

FunctionScopeStart findFunctionScopeStart(Namespace namespace)
{
    Namespace namespace = namespace; // TODO mut Namespace namespace
    while (true) {
        if (auto functionScopeStart = namespace.instanceOf(FunctionScopeStart))
            return functionScopeStart;
        assert(!!namespace.parent);
        namespace = namespace.parent;
    }
}

// helper for binding values for stuff like compiler.$stmt
class SymbolAlias : Namespace
{
    string name;

    Symbol value;

    this(this.parent, this.name, this.value) { }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (this.name == name) return value;
        if (this.parent) return this.parent.lookup(name, context, frame);
        return null;
    }
}

class BorrowedReference : Reference
{
    Reference base;

    this(this.base) { }

    override Type type() { return base.type; }
    override int emit(Generator output) { return base.emit(output); }
    override int emitLocation(Generator output) { return base.emitLocation(output); }
    override void hash(Hash hash) { hash.adds("BorrowedReference"); base.hash(hash); }
    override ExprInfo info() { return ExprInfo(Ownership.borrowed); }
}

class VariableDeclaration : DeclarationHolder
{
    LatentVariable variable;

    this(this.parent, string name, Type type, bool owned)
    {
        this.variable = findFunctionScope(this).declare(name, type, owned);
    }

    override Reference accessDecl()
    {
        Expression frame = new ReferenceExpression(new StackFrame(variable.stackFrameType));
        return access(frame);
    }

    Reference access(Expression frame)
    {
        Type stackFrameType = variable.stackFrameType;
        auto frame = new PointerCast(new Pointer(stackFrameType), frame);
        auto reference = new StructMemberReference(new Dereference(frame), variable.offset);
        // an argument, for instance
        if (!variable.owned) return new BorrowedReference(reference);
        return reference;
    }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (this.variable.name == name)
        {
            return access(frame);
        }
        if (this.parent) return this.parent.lookup(name, context, frame);
        return null;
    }
}

class NestedFunctionDeclaration : Namespace
{
    Function nestedFunction;

    // TODO collision check
    this(this.parent, this.nestedFunction) { }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (this.nestedFunction.name == name)
        {
            auto framePtr = new PointerCast(once new Pointer(new Void), frame);

            return new ClassMethodPtr(new FunctionReference(this.nestedFunction), framePtr);
        }
        if (this.parent) return this.parent.lookup(name, context, frame);
        return null;
    }
}

Statement unwindScope(Context context, Namespace target, Statement body_)
{
    Statement result = body_;
    auto current = context.namespace;
    while (current !is target) {
        if (auto declHolder = current.instanceOf(DeclarationHolder)) {
            auto var = declHolder.accessDecl;
            auto type = var.type;
            auto destroy = type.endLifetime(context, var);
            result = sequence(result, destroy);
        }
        current = current.parent;
    }
    return result;
}

class ASTIfStatement : ASTStatement
{
    Either(ASTSymbol, ASTVarDeclStatement) test;

    ASTStatement then;

    ASTStatement else_;

    Loc loc;

    this(this.test, this.then, this.else_, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        Statement prelude; // var decl statement
        auto testSucceedsContext = context;
        Expression test;
        this.test.case {
            ASTSymbol symbol: {
                test = beExpression3(context, symbol.compile(context), this.loc);
            }
            ASTVarDeclStatement vardecl: {
                auto pair = vardecl.compile(context);
                prelude = pair.statement;
                testSucceedsContext = pair.context;
                // TODO lookup() that handles the stackframe thing
                auto stackframe = once new ReferenceExpression(new StackFrame(new Void));
                test = beExpression3(context,
                    testSucceedsContext.namespace.lookup(vardecl.name, context, stackframe),
                    this.loc);
            }
        }
        auto thenPair = this.then.compile(testSucceedsContext);
        Statement then = unwindScope(thenPair.context, context.namespace, thenPair.statement);
        Statement else_;
        if (this.else_) {
            auto elsePair = this.else_.compile(context);
            else_ = unwindScope(elsePair.context, context.namespace, elsePair.statement);
        }

        auto test = truthy(context, test, this.loc);
        auto ifStmt = new IfStatement(test, then, else_);

        return StatementCompileResult(sequence(prelude, ifStmt), context);
    }

    override ASTSymbol quote(Quoter quoter) {
        if (!else_) {
            return quoter.compilerCall("astIf", [
                test.case(ASTSymbol symbol: symbol.quote(quoter), ASTVarDeclStatement stmt: stmt.quote(quoter)),
                then.quote(quoter),
                quoter.compiler.astIdentifier("null", loc.reloc)], loc.reloc);
        }
        return quoter.compilerCall("astIf", [
            test.case(ASTSymbol symbol: symbol.quote(quoter), ASTVarDeclStatement stmt: stmt.quote(quoter)),
            then.quote(quoter),
            else_.quote(quoter)], loc.reloc);
    }
}

ASTIfStatement parseIf(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    string identifier = parseIdentifier(parser);
    if (identifier != "if")
    {
        parser.revert;
        return null;
    }
    Either(ASTSymbol, ASTVarDeclStatement) test;
    parser.expect("(");
    if (auto vardecl = parseVarDecl(parser, lexicalContext, true))
        test = vardecl;
    else test = parseExpression(parser, lexicalContext);
    parser.expect(")");
    ASTStatement thenStmt = parseStatement(parser, lexicalContext);
    ASTStatement elseStatement;
    if (parser.accept("else"))
    {
        elseStatement = parseStatement(parser, lexicalContext);
    }
    parser.commit;
    return new ASTIfStatement(test, thenStmt, elseStatement, parser.loc);
}

ASTStatement parseBreakCont(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto loc = parser.loc;
    string identifier = parseIdentifier(parser);
    if (identifier == "break")
    {
        parser.expect(";");
        parser.commit;
        return new ASTBreakStatement(loc.reloc);
    }
    if (identifier == "continue")
    {
        parser.expect(";");
        parser.commit;
        return new ASTContinueStatement(loc.reloc);
    }
    parser.revert;
    return null;
}

class ASTScopeStatement : ASTStatement
{
    ASTStatement[] statements;

    Loc loc;

    this(this.statements, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto statements = new Statement[](this.statements.length);
        auto subContext = context;
        for (int i = 0; i < this.statements.length; i += 1)
        {
            auto pair = this.statements[i].compile(subContext);

            subContext = pair.context;
            statements[i] = pair.statement;
        }
        return StatementCompileResult(
            unwindScope(subContext, context.namespace, new SequenceStatement(statements)),
            context); // scope ends here
    }

    override ASTSymbol quote(Quoter quoter) {
        auto statements = [statement.quote(quoter) for statement in this.statements];
        return quoter.compilerCall(
            "astScope", [quoter.compiler.astArrayLiteral(statements, this.loc.reloc)], this.loc.reloc);
    }
}

// just a bunch of statements after each other
// (used for int a, b)
class ASTSequenceStatement : ASTStatement
{
    ASTStatement[] statements;

    Loc loc;

    this(this.statements, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto statements = new Statement[](this.statements.length);
        auto subContext = context;
        for (int i = 0; i < this.statements.length; i += 1)
        {
            auto pair = this.statements[i].compile(subContext);

            subContext = pair.context;
            statements[i] = pair.statement;
        }
        // not a scope!
        return StatementCompileResult(new SequenceStatement(statements), subContext);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto statements = [arg.quote(quoter) for arg in this.statements];
        return quoter.compilerCall(
            "astSequence", [quoter.compiler.astArrayLiteral(statements, this.loc.reloc)], this.loc.reloc);
    }
}

ASTScopeStatement parseScope(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!parser.accept("{"))
    {
        return null;
    }
    ASTStatement[] statements;
    while (!parser.accept("}"))
    {
        ASTStatement stmt = parseStatement(parser, lexicalContext);

        statements ~= stmt;
    }
    return new ASTScopeStatement(statements, loc);
}

ASTAssignStatement parseAssignment(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    ASTSymbol lhs = parseExpressionLeaf(parser, lexicalContext);
    if (!lhs) {
        parser.revert;
        return null;
    }
    auto loc = parser.loc;
    string operator;
    if (parser.accept("=")) { }
    else if (parser.accept("+=")) operator = "+";
    else if (parser.accept("-=")) operator = "-";
    else if (parser.accept("*=")) operator = "*";
    else if (parser.accept("/=")) operator = "/";
    else if (parser.accept("~=")) operator = "~";
    else {
        parser.revert;
        return null;
    }
    ASTSymbol expr = parseExpression(parser, lexicalContext);
    if (!expr) {
        parser.fail("expression expected");
    }
    parser.commit;
    if (operator.length) {
        // TODO separate AST construct - avoid double compiling lhs?
        expr = new ASTBinaryOp(operator, lhs, expr, loc);
    }
    return new ASTAssignStatement(lhs, expr, parser.loc);
}

ASTAssignStatement parseAssignStatement(Parser parser, LexicalContext lexicalContext)
{
    if (auto ret = parseAssignment(parser, lexicalContext))
    {
        parser.expect(";");
        return ret;
    }
    return null;
}

class ASTVarDeclStatement : ASTStatement
{
    string name;

    bool infer;

    ASTSymbol type;

    ASTSymbol initial;

    Loc loc;

    this(this.name, this.infer, this.type, this.initial, this.loc)
    {
        assert(infer == !type);
        assert(!infer || initial);
    }

    override StatementCompileResult compile(Context context)
    {
        Type type;
        if (this.type) type = beType(this.loc, this.type.compile(context));
        if (this.initial)
        {
            auto initial = beExpression3(context, this.initial.compile(context), this.loc);
            if (this.infer) {
                assert(!type);
                type = initial.type;
            } else {
                assert(!!type);
                initial = expectImplicitConvertTo(context, initial, type, this.loc);
            }

            auto decl = new VariableDeclaration(context.namespace, this.name, type, true);

            return StatementCompileResult(
                move(context, decl.accessDecl, initial),
                context.withNamespace(decl));
        }
        else
        {
            auto decl = new VariableDeclaration(context.namespace, this.name, type, true);

            return StatementCompileResult(
                new AssignStatement(decl.accessDecl, new NullExpr(type)),
                context.withNamespace(decl));
        }
    }

    override ASTSymbol quote(Quoter quoter) {
        ASTSymbol varName;
        // auto $foo = 5;
        // -> compiler.astDeclareVar(foo, compiler.astIntLiteral(5))
        if (this.name[0 .. 1] == "$") {
            varName = quoter.compiler.astIdentifier(this.name[1 .. $], this.loc.reloc);
        } else {
            varName = quoter.compiler.astStringLiteral(this.name, this.loc.reloc);
        }
        if (this.infer) {
            return quoter.compilerCall("astDeclareVar", [
                varName,
                this.initial.quote(quoter)], this.loc.reloc);
        }
        if (this.initial) {
            return quoter.compilerCall("astDeclareTypedVar", [
                varName,
                this.type.quote(quoter),
                this.initial.quote(quoter)], this.loc.reloc);
        }
        return quoter.compilerCall("astDeclareTypedVar", [
            varName,
            this.type.quote(quoter),
            quoter.compiler.astIdentifier("null", this.loc.reloc)], this.loc.reloc);
    }
}

ASTVarDeclStatement parseVarInitialization(
    Parser parser, LexicalContext lexicalContext, bool infer, ASTSymbol type, bool requireInitializer)
{
    parser.begin;
    ASTSymbol initial;
    string name;
    if (infer && parser.accept("="))
    {
        initial = parseExpression(parser, lexicalContext);
        if (!initial) parser.fail("variable initializer expected");
    }
    else
    {
        name = parseIdentifier(parser);
        if (!name.length)
        {
            parser.revert;
            return null;
        }
        if (infer) {
            if (!parser.accept("="))
            {
                parser.revert;
                return null;
            }
            initial = parseExpression(parser, lexicalContext);
            if (!initial) parser.fail("variable initializer expected");
        }
        else if (parser.accept("=")) {
            initial = parseExpression(parser, lexicalContext);
            if (!initial) parser.fail("variable initializer expected");
        }
    }
    if (requireInitializer && !initial) {
        parser.revert;
        return null;
    }
    parser.commit;
    return new ASTVarDeclStatement(name, infer, type, initial, parser.loc);
}

ASTVarDeclStatement parseVarDecl(Parser parser, LexicalContext lexicalContext, bool requireInitializer)
{
    parser.begin;
    bool infer = false;
    ASTSymbol type;
    if (acceptIdentifier(parser, "auto")) {
        infer = true;
    } else {
        type = parseType(parser, lexicalContext);
        if (!type)
        {
            parser.revert;
            return null;
        }
    }
    auto decl = parseVarInitialization(parser, lexicalContext, infer, type, requireInitializer);
    if (!decl) {
        parser.revert;
        return null;
    }
    parser.commit;
    return decl;
}

ASTStatement parseMultiVarDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    bool infer = false;
    ASTSymbol type;
    auto loc = parser.loc;
    if (acceptIdentifier(parser, "auto")) {
        infer = true;
    } else {
        type = parseType(parser, lexicalContext);
        if (!type)
        {
            parser.revert;
            return null;
        }
    }
    ASTStatement[] decls;
    while (true) {
        if (decls.length) parser.expect(",");
        ASTStatement decl = parseVarInitialization(parser, lexicalContext, infer, type, false);
        if (!decl) {
            parser.assert_(decls.length == 0, "couldn't parse continuing variable declaration");
            parser.revert;
            return null;
        }
        decls ~= decl;
        if (parser.accept(";")) break;
    }
    parser.commit;
    return new ASTSequenceStatement(decls, loc);
}

class ASTNestedFunctionDeclStatement : ASTStatement
{
    ASTFunction fun;

    this(this.fun) { }

    override StatementCompileResult compile(Context context)
    {
        auto module_ = findModule(context.namespace);
        auto fun_ = this.fun.compile(context).instanceOf(Function);
        auto structType = findFunctionScope(context.namespace).structType;
        auto voidp = once new Pointer(new Void);

        fun_.contextType = new Pointer(structType);
        fun_.parent = context.namespace;

        auto namespace = new NestedFunctionDeclaration(context.namespace, fun_);

        module_.update("__" ~ ptrId(this), fun_);

        return StatementCompileResult(
            new NoopStatement,
            context.withNamespace(namespace));
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTNestedFunctionDeclStatement'"); assert(false); }
}

ASTNestedFunctionDeclStatement parseNestedFunctionDecl(Parser parser, LexicalContext lexicalContext)
{
    if (auto fun_ = parseFunction(parser, lexicalContext))
        return new ASTNestedFunctionDeclStatement(fun_);
    return null;
}

class ASTWhile : ASTStatement
{
    ASTSymbol cond;

    ASTStatement body_;

    Loc loc;

    this(this.cond, this.body_, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto label = context.getLabel;
        auto loopContext = context.withNamespace(new LabelLoopScope(label, context.namespace));
        auto condExpr = truthy(context, beExpression3(context, this.cond.compile(loopContext), this.loc), this.loc);
        auto bodyPair = this.body_.compile(loopContext);
        auto bodyStmt = unwindScope(bodyPair.context, context.namespace, bodyPair.statement);

        return StatementCompileResult(
            new Loop(label, null, condExpr, bodyStmt, null),
            context);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTWhileStatement'"); assert(false); }
}

ASTWhile parseWhile(Parser parser, LexicalContext lexicalContext)
{
    if (!acceptIdentifier(parser, "while"))
    {
        return null;
    }
    parser.expect("(");
    ASTSymbol cond = parseExpression(parser, lexicalContext);
    parser.expect(")");
    ASTStatement body_ = parseStatement(parser, lexicalContext);

    return new ASTWhile(cond, body_, parser.loc);
}

ASTExprStatement parseExprStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    auto loc = parser.loc;
    ASTSymbol value = parseExpression(parser, lexicalContext);
    if (!value)
    {
        parser.revert;
        return null;
    }
    parser.expect(";");
    parser.commit;
    return new ASTExprStatement(value, loc);
}

class ASTStatementExpression : ASTSymbol
{
    ASTStatement[] statements;

    ASTSymbol expr;

    ReLoc reloc;

    this(this.statements, this.expr, this.reloc) {
        for (int i = 0; i < statements.length; i += 1)
            assert(!!statements[i]);
        assert(!!expr);
    }

    override Expression compile(Context context) {
        auto context = context; // TODO mut Context context
        auto loc = Loc(context.compiler.linenr, reloc);
        auto baseNamespace = context.namespace;
        auto statements = new Statement[](this.statements.length);
        for (int i = 0; i < this.statements.length; i += 1) {
            auto result = this.statements[i].compile(context);

            statements[i] = result.statement;
            context = result.context;
        }
        auto resultValue = beExpression3(context, this.expr.compile(context), loc);
        auto resultType = resultValue.type;

        // as ASTReturn
        auto temp = new PairedTemporary(resultType, false);
        auto init = new UninitializeTemporaryStatement(temp);

        Statement escapeValueStmt = resultType.copyInto(context, temp, resultValue);
        if (resultValue.info.ownership == Ownership.gifted || !escapeValueStmt) {
            escapeValueStmt = new AssignStatement(temp, resultValue);
        }
        escapeValueStmt = sequence(init, escapeValueStmt);

        auto sequence = new SequenceStatement(statements ~ escapeValueStmt);
        // unwind variables declared in the ({ })
        auto stmtExpr = unwindScope(context, baseNamespace, sequence);

        return new StatementExpression(stmtExpr, temp, true);
    }

    // TODO on CompilerBase?
    override ASTSymbol quote(Quoter quoter) {
        auto quotedStatements = new ASTSymbol[](this.statements.length);
        for (int i = 0; i < this.statements.length; i += 1)
            quotedStatements[i] = this.statements[i].quote(quoter);
        return quoter.compilerCall("astStatementExpression", [
            quoter.compiler.astArrayLiteral(quotedStatements, reloc),
            this.expr.quote(quoter)
        ], reloc);
    }
}

// ({ ...; ...; })
// value of last expression is value of statement expression
ASTStatementExpression parseStatementExpr(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!parser.accept("({")) return null;
    ASTStatement[] statements;
    while (!parser.accept("})")) {
        statements ~= parseStatement(parser, lexicalContext);
    }
    if (statements.length == 0) parser.fail("expected at least one statement");

    if (auto exprStmt = statements[$ - 1].instanceOf(ASTExprStatement))
        return new ASTStatementExpression(statements[0 .. $ - 1], exprStmt.value, loc.reloc);

    parser.fail("last statement in statement expression must be an expression");
}

class ASTForLoop : ASTStatement
{
    ASTStatement declareLoopVar;

    ASTSymbol condition;

    ASTStatement step;

    ASTStatement body_;

    Loc loc;

    this(this.declareLoopVar, this.condition, this.step, this.body_, this.loc) { }

    override StatementCompileResult compile(Context context)
    {
        auto declPair = this.declareLoopVar.compile(context);
        auto forScope = declPair.context;
        Expression condition = beExpression3(context, this.condition.compile(forScope), this.loc);
        auto stepPair = this.step.compile(forScope);

        string label = context.getLabel;
        Namespace declScope = new LabelLoopScope(label, forScope.namespace);
        Context breakContScope = forScope.withNamespace(declScope);
        auto bodyPair = this.body_.compile(breakContScope);

        return StatementCompileResult(
            new Loop(label, declPair.statement, condition, bodyPair.statement, stepPair.statement),
            context);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astForLoop", [
            declareLoopVar.quote(quoter),
            condition.quote(quoter),
            step.quote(quoter),
            body_.quote(quoter)], loc.reloc);
    }
}

ASTForLoop parseFor(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!acceptIdentifier(parser, "for"))
    {
        return null;
    }
    parser.expect("(");
    ASTVarDeclStatement varDecl = parseVarDecl(parser, lexicalContext, false);
    if (!varDecl) {
        parser.fail("loop declaration expected");
    }
    parser.expect(";");
    ASTSymbol condition = parseExpression(parser, lexicalContext);
    parser.expect(";");
    ASTStatement step = parseAssignment(parser, lexicalContext);
    parser.expect(")");
    ASTStatement body_ = parseStatement(parser, lexicalContext);

    return new ASTForLoop(varDecl, condition, step, body_, loc);
}

class ASTStatementStatement : ASTStatement
{
    Loc loc;

    string variable;

    this(this.loc, this.variable) { }

    override StatementCompileResult compile(Context context) {
        this.loc.fail("$stmt used outside quasiquote");
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astIdentifier(variable, loc.reloc);
    }
}

/**
 * Parse a statement that indicates to the quoter that an ASTStatement variable should be inserted.
 */
ASTStatementStatement parseStatementStatement(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!parser.accept("$stmt")) return null;
    auto variable = parseIdentifier(parser);
    if (!variable.length) parser.fail("ASTStatement variable expected");
    parser.expect(";");
    return new ASTStatementStatement(loc, variable);
}

// This is a placeholder for proper range semantics.
ASTStatement parseExtFor(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    if (!acceptIdentifier(parser, "for") || !parser.accept("(")) {
        parser.revert;
        return null;
    }
    auto compiler = lexicalContext.compiler;
    bool auto_;
    ASTSymbol type;
    if (parser.accept("auto")) auto_ = true;
    else type = parseType(parser, lexicalContext);
    auto identifierLoc = parser.loc;
    auto identifier = parseIdentifier(parser);
    if (!identifier.length || !parser.accept("<-")) {
        parser.revert;
        return null;
    }
    auto source = parseExpression(parser, lexicalContext);
    if (!source) parser.fail("expression expected");
    // range expression loop, for (int i <- 0..10)
    if (parser.accept(".."))
    {
        auto lower = source;
        auto upper = parseExpression(parser, lexicalContext);
        if (!upper) parser.fail("range upper bound expected");
        parser.expect(")");
        auto body_ = parseStatement(parser, lexicalContext);
        parser.commit;

        auto loopvar = compiler.astIdentifier(identifier, identifierLoc.reloc);
        if (auto_)
            return compiler.$stmt {
                for (auto $identifier = $lower; $loopvar < $upper; $loopvar += 1) {
                    $stmt body_;
                }
            };
        return compiler.$stmt {
            for ($type $identifier = $lower; $loopvar < $upper; $loopvar += 1) {
                $stmt body_;
            }
        };
    }
    // array loop, for (auto bla <- array)
    parser.expect(")");
    auto body_ = parseStatement(parser, lexicalContext);
    parser.commit;

    ASTStatement declIdentifier;
    if (auto_) declIdentifier = compiler.$stmt auto $identifier = __source[__loopvar];;
    else declIdentifier = compiler.$stmt $type $identifier = __source[__loopvar];;
    return compiler.$stmt {
        auto __source = $source;
        for (int __loopvar = 0; __loopvar < __source.length; __loopvar += 1) {
            $stmt declIdentifier;
            $stmt body_;
        }
    };
}

class ASTDestroy : ASTSymbol
{
    ASTSymbol target;

    Loc loc;

    this(this.target, this.loc) { }

    override Expression compile(Context context) {
        auto expr = beExpression3(context, this.target.compile(context), loc);
        auto stmt = destroy(context, expr);
        if (!stmt) return once new VoidExpression;
        return new StatementExpression(stmt, once new VoidExpression, false);
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astDestroy", [target.quote(quoter)], loc.reloc);
    }
}

// manually end lifetime of a value
ASTSymbol parseDestroy(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!acceptIdentifier(parser, "__destroy"))
        return null;
    parser.expect("(");
    ASTSymbol target = parseExpression(parser, lexicalContext);
    if (!target) parser.fail("expression expected");
    parser.expect(")");

    return new ASTDestroy(target, loc);
}

ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
{
    if (ASTStatement stmt = parseReturn(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseIf(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseBreakCont(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseWhile(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseExtFor(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseFor(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseScope(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseNestedFunctionDecl(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseStatementStatement(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseMultiVarDecl(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseAssignStatement(parser, lexicalContext))
        return stmt;
    if (ASTStatement stmt = parseWithStatement(parser, lexicalContext))
        return stmt;
    {
        auto args = new ParseStatementArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (args.statement) return args.statement;
    }
    if (ASTStatement stmt = parseExprStatement(parser, lexicalContext))
        return stmt;
    parser.fail("statement expected");
}

ASTFunction parseFunction(Parser parser, LexicalContext lexicalContext)
{
    parser.begin;
    ASTSymbol ret = parseType(parser, lexicalContext);
    if (!ret)
    {
        parser.revert;
        return null;
    }
    string name = parseIdentifier(parser);
    if (!name.length || !parser.accept("("))
    {
        parser.revert;
        return null;
    }
    parser.commit;
    ASTArgument[] args = parseIdentifierList(parser, lexicalContext);
    ASTStatement stmt = parseStatement(parser, lexicalContext);
    return new ASTFunction(parser.loc, name, ret, args, false, stmt, lexicalContext.macroState);
}

class ModuleEntry
{
    string name;

    Symbol value;

    this(this.name, this.value) { }
}

class ASTModule
{
    Loc loc;

    string name;

    Package pak;

    MacroState macroState;

    // separated from this module with a divergent macro state
    // because we hit a macro declaration
    ASTModule parent;

    Either(
        ASTImport, ASTSymbol, ASTExtern, ASTFunction,
        ASTSymbolAlias, ASTTemplateDecl
    )[] entries;

    this(this.loc, this.name, this.pak, this.macroState, this.parent) { }

    void addSymbolAlias(string name, ASTSymbol symbol)
    {
        this.entries ~= new ASTSymbolAlias(name, symbol);
    }
}

string mangleModuleName(string name, Package pak)
{
    // TODO non-nullable by default
    assert(!!pak);
    string mangledName;
    // mangledName = [(a == '.') ? '_' : a for a in name];
    for (int i = 0; i < name.length; i += 1) {
        if (name[i .. i + 1] == ".") mangledName ~= "_";
        else mangledName ~= name[i .. i + 1];
    }
    if (pak.HACK_rename == "") {
        mangledName = pak.name ~ "_module_" ~ mangledName;
    } else {
        mangledName = pak.HACK_rename ~ "_module_" ~ mangledName;
    }
    return mangledName;
}

// TODO separate Module and ASTModule to get rid of macroState
class Module : Namespace
{
    Loc loc;

    string name;

    string mangledName;

    MacroState macroState;

    // whenever macro state changes, we begin a new submodule
    // when this happens, this member references the previous module.
    Module parentModule;

    this(this.loc, this.name, this.mangledName, this.macroState, this.parentModule) { }

    Module[] imports;

    ModuleEntry[] entries;

    void add(string name, Symbol symbol)
    {
        this.entries ~= new ModuleEntry(name, symbol);
    }

    /**
     * Sometimes we add a symbol twice, because the same module
     * can get compiled twice. Then we use update() to avoid
     * double-emitting the same function.
     * The better solution would be to not rely on Module for
     * determining which functions to recursively emit.
     */
    void update(string name, Symbol symbol)
    {
        auto pos = [first i for i, a in entries where a.name == name else -1];
        if (pos == -1) add(name, symbol);
        else entries[pos].value = symbol;
    }

    void addImport(Module module_)
    {
        assert(!!module_);
        // TODO error?
        if ([any a.mangledName == module_.mangledName for a in this.imports])
            return;
        this.imports ~= module_;
    }

    override string mangle() { return this.mangledName; }

    void resolve()
    {
        for (int i = 0; i < this.entries.length; i += 1) {
            if (Class class_ = this.entries[i].value.instanceOf(Class))
                class_.resolve;
        }
    }

    void walkModules(void delegate(Module) cb)
    {
        cb(this);
        if (this.parentModule)
            this.parentModule.walkModules(cb);
        [import_.walkModules(cb) for import_ in imports];
    }

    FinishedSymbol[] compile(CompilerBase compiler, Platform platform)
    {
        FinishedSymbol[] symbols;

        for (int i = 0; i < this.entries.length; i += 1) {
            ModuleEntry entry = this.entries[i];
            if (Function fun = entry.value.instanceOf(Function))
            {
                symbols ~= fun.compile(compiler, platform);
            }
            if (Class class_ = entry.value.instanceOf(Class)) {
                symbols ~= new DefineClass(class_);
                // class_.define(generator);
                symbols ~= [cast(FinishedSymbol) method.compile(compiler, platform) for method in class_.methods];
            }
            if (Struct struct_ = entry.value.instanceOf(Struct)) {
                symbols ~= [
                    cast(FinishedSymbol) method.instanceOf(StructMethod).compile(compiler, platform)
                    for method in struct_.methods];
            }
        }
        return symbols;
    }

    void emit(Generator generator, FinishedSymbol[] symbols)
    {
        if (!generator.once(mangle))
            return;

        assert(!generator.fun);

        [symbol.emit(generator) for symbol in symbols];
    }

    Symbol lookupPublic(string name)
    {
        // not counting imports (non-transitive)
        return [first entry.value for entry in this.entries where entry.name == name else null];
    }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (!!frame) { print("error: lookup with frame propagated to Module"); assert(false); }

        if (Symbol public_ = this.lookupPublic(name)) return public_;
        for (int i = 0; i < this.imports.length; i += 1)
        {
            assert(!!this.imports[i]);
            if (Symbol entry = this.imports[i].lookupPublic(name)) return entry;
        }
        if (this.parent)
            return this.parent.lookup(name, context, frame);
        return null;
    }
}

abstract class ParserHelper
{
    abstract void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        assert(false);
    }
}

Module findModule(Namespace namespace)
{
    if (Module module_ = namespace.instanceOf(Module))
        return module_;
    assert(!!namespace.parent);
    return findModule(namespace.parent);
}

class ASTExtern
{
    string name;

    ASTSymbol ret;

    ASTArgument[] args;

    Loc retLoc;

    this(this.name, this.ret, this.args, this.retLoc) { }

    FunctionDeclaration compile(Context context)
    {
        auto args = [Argument(false, arg.name, beType(arg.loc, arg.type.compile(context))) for arg in this.args];

        return new FunctionDeclaration(this.name, beType(this.retLoc, this.ret.compile(context)), args);
    }
}

ASTExtern parseExtern(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("extern"))
    {
        parser.expect("(");
        parser.expect("C");
        parser.expect(")");
        auto retLoc = parser.loc;
        ASTSymbol ret = parseType(parser, lexicalContext);
        string name = parseIdentifier(parser);
        if (!name.length) parser.fail("identifier expected");
        parser.expect("(");
        ASTArgument[] args = parseIdentifierList(parser, lexicalContext);
        parser.expect(";");
        return new ASTExtern(name, ret, args, retLoc);
    }
    return null;
}

string moduleToFile(string module_)
{
    string modulePath;
    for (int i = 0; i < module_.length; i += 1) {
        if (module_[i .. i + 1] == ".") modulePath ~= "/";
        else modulePath ~= module_[i .. i + 1];
    }
    return modulePath ~ ".cx";
}

string findFileInPackage(string filename, Package pak, Loc loc, void delegate(Package) foundPak)
{
    string fileInPackage = pak.path ~ "/" ~ filename;
    if (cxruntime_file_exists(fileInPackage)) {
        foundPak(pak);
        return fileInPackage;
    }
    for (int i = 0; i < pak.deps.length; i += 1) {
        auto dep = pak.deps[i];
        string fileInDep = dep.path ~ "/" ~ filename;

        if (cxruntime_file_exists(fileInDep)) {
            foundPak(dep);
            return fileInDep;
        }
    }
    loc.assert2s(false, "cannot find file '" ~ filename ~ "' in package '" ~ pak.name ~ "' or dependencies");
}

// TODO rewrite this once we have a std.path
string findResidualFilename(string filename, Package[] packages, void delegate(Package) foundPackage)
{
    // TODO split then check
    assert(cxruntime_file_exists(filename));
    for (int i = 0; i < packages.length; i += 1) {
        string path = packages[i].path;
        if (filename.length >= path.length
            && filename[0 .. path.length] == path) {
            foundPackage(packages[i]);
            return filename[path.length + 1 .. $];
        }
    }
    // TODO handle "../" paths
    for (int i = 0; i < packages.length; i += 1) {
        if (packages[i].path == ".") {
            foundPackage(packages[i]);
            return filename;
        }
    }
    print("file '" ~ filename ~ "' is not in folder of any package");
    assert(false);
}

class ASTImport
{
    string name;

    string pak;

    bool isMacroImport;

    Loc loc;

    this(this.name, this.pak, this.isMacroImport, this.loc) { }
}

ASTImport parseImport(Parser parser)
{
    parser.begin;
    bool isMacroImport = acceptIdentifier(parser, "macro");
    if (!acceptIdentifier(parser, "import"))
    {
        parser.revert;
        return null;
    }
    string pak;
    if (acceptIdentifier(parser, "package"))
    {
        parser.expect("(");
        pak = parseIdentifier(parser);
        parser.expect(")");
        parser.expect(".");
    }

    parser.commit;
    string modname = parseIdentifier2(parser, ".");
    parser.expect(";");
    return new ASTImport(modname, pak, isMacroImport, parser.loc);
}

class ClassMember
{
    string name;

    Type type;

    this(this.name, this.type) { }
}

class ClassMethod : Function
{
    Loc loc;

    bool override_;

    bool abstract_;

    this(this.loc, Class classType, this.override_, this.abstract_, this.name, this.ret, this.args,
         this.statement, this.macroState)
    {
        // TODO super()
        auto classNamespace = new ClassNamespace(classType.context.namespace, classType);

        this.hasThisArg = true;
        this.contextType = classType;
        this.parent = classNamespace;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.parent.mangle ~ "_" ~ this.contextType.instanceOf(Class).name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto argTypes = [this.contextType] ~ [arg.type for arg in this.args];
        return new FunctionPointer(this.ret, argTypes);
    }
}

class ClassNamespace : Namespace
{
    Class class_;

    this(this.parent, this.class_) { }

    override Symbol lookup(string name, Context context, Expression thisPtr)
    {
        auto thisPtr = new PointerCast(this.class_, thisPtr);

        if (auto result = accessMemberWithLifetime(context, thisPtr, name, Loc(null, ReLoc("", 0)), true))
            return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, null);
    }
}

/**
 * Class layout:
 * - super class data OR
 *   - vtable ptr
 *   - reference count
 * - class data
 */
class Class : Type
{
    string name;

    bool final_; // methods may not be overridden

    bool abstract_; // may contain abstract methods

    Class superClass;

    // will resolve members and methods as required
    ASTClassDecl decl;

    // used for resolving
    Context context;

    ClassMember[] members;

    ClassMethod[] methods;

    ClassMethod[] vtable_; // methods appearing in the classinfo struct

    string vtableSymbol;

    string mangledName;

    PolyHashState mangledHash;

    Struct dataStruct;

    this(this.decl, this.superClass, this.context)
    {
        if (superClass && superClass.final_)
            decl.loc.fail("cannot subclass a final class");
        assert(!!decl);
        this.name = decl.name;
        this.final_ = decl.final_;
        this.abstract_ = decl.abstract_;
        this.mangledName = context.namespace.mangle ~ "_class_" ~ this.name;
        auto state = poly_hash_string("Class" ~ this.mangledName);
        this.mangledHash = PolyHashState(state.add, state.mult);
    }

    override string mangle() {
        return this.mangledName;
    }

    override Expression truthy(Context context, Expression value, Loc loc)
    {
        Expression do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy(context, new PointerCast(voidp, value), loc);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override Symbol accessMember(Context context, Expression baseExpr, string member)
    {
        ClassMethod[] vtable = this.vtable;
        Expression asStructPtr = new PointerCast(
            new Pointer(this.dataStruct), baseExpr);
        size_t methodOffset = [first i for i, a in vtable where a.name == member else -1];
        if (methodOffset != -1)
        {
            Reference classInfo = new Dereference(new PointerCast(
                new Pointer(this.classInfoStruct),
                new StructMemberReference(new Dereference(asStructPtr), 0)));
            // TODO dereference-into-symbol so we can '&' it again
            if (this.final_) {
                auto funcPtr = new FunctionReference(vtable[methodOffset]);
                return new ClassMethodPtr(funcPtr, baseExpr);
            }
            Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
            auto funcPtr = funcPtrValue.type.instanceOf(FunctionPointer);

            auto funcPtrWithVoidpThis = new FunctionPointer(funcPtr.ret, [arg for arg in funcPtr.args]);
            funcPtrWithVoidpThis.args[0] = once new Pointer(new Void);
            funcPtrValue = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);

            return new ClassMethodPtr(funcPtrValue, baseExpr);
        }

        ClassMember[] members = this.allMembers(context);
        size_t memberOffset = [first i for i, a in members where a.name == member else -1];
        if (memberOffset != -1)
            return new StructMemberReference(new Dereference(asStructPtr), memberOffset);
    }

    override Expression implicitConvertFrom(Expression from)
    {
        // upcast
        if (from.type.instanceOf(Class))
        {
            Class currentClass = from.type.instanceOf(Class);

            while (currentClass)
            {
                if (currentClass.same(this))
                {
                    return new PointerCast(this, from);
                }
                currentClass = currentClass.superClass;
            }
        }
        // = null
        if (from.instanceOf(NullExpr))
        {
            return new PointerCast(this, from);
        }
        return null;
    }

    override Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);

        if (to.same(voidp))
        {
            if (from.info.ownership == Ownership.gifted)
            {
                print("cannot convert temporary expression to void* - where would the reference go?");
                // TODO return Either(Expression, Error)
                assert(false);
            }
            return new PointerCast(voidp, from);
        }
        return null;
    }

    void resolve()
    {
        assert(this.vtableSymbol == "");
        this.decl.compile2(this.context, this);
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    ClassMember[] allMembers(Context context)
    {
        if (!this.superClass)
        {
            return [
                once new ClassMember("__classinfo", new Pointer(new Void)),
                new ClassMember("__refs", context.nativeWordType),
            ] ~ this.members;
        }
        return this.superClass.allMembers(context) ~ this.members;
    }

    void initDataStruct(Context context)
    {
        ClassMember[] allMembers = this.allMembers(context);

        auto structMembers = [
            new StructMemberDeclaration(member.name, member.type)
            for member in allMembers];

        this.dataStruct = new Struct("", structMembers, this.decl.loc, this.mangle);
    }

    Struct classInfoStructCache;

    Struct classInfoStruct()
    {
        if (classInfoStructCache) {
            assert(classInfoStructCache.members.length == vtable_.length);
            return classInfoStructCache;
        }

        auto vtableMembers = [
            new StructMemberDeclaration(method.name, method.funcPtrType)
            for method in vtable_];

        classInfoStructCache = new Struct("", vtableMembers, this.decl.loc, this.mangle);
        return classInfoStructCache;
    }

    ClassMethod[] vtable()
    {
        return [a for a in this.vtable_];
    }

    void genVtable(Context context)
    {
        if (this.vtableSymbol != "") return;

        assert(this.vtable_.length == 0);

        ClassMethod[] combinedMethods;
        if (this.superClass) {
            this.superClass.genVtable(context);
            combinedMethods = this.superClass.vtable;
        }

        this.genInstanceofMethod(context);
        this.genReleaseMethod(context);

        for (int i = 0; i < this.methods.length; i += 1) {
            ClassMethod method = this.methods[i];

            // TODO match types
            bool isCtor = method.name == "__ctor"; // workaround: no final yet, no proper masking yet
            size_t index = [first i for i, a in combinedMethods where a.name == method.name else -1];
            if (index != -1)
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(method.override_ || isCtor,
                        "Expected 'override' attribute for overriding method.");
                // override
                combinedMethods[index] = method;
            }
            else
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(!method.override_,
                        "'override specified but method does not override a parent method.");
                combinedMethods ~= method;
            }
        }
        if (!this.abstract_)
        {
            for (int i = 0; i < combinedMethods.length; i += 1) {
                auto method = combinedMethods[i];
                if (method.abstract_)
                    this.decl.loc.fail(
                        "Abstract method '" ~ method.name ~ "' not overridden in non-abstract class " ~ this.name);
            }
        }
        this.vtable_ = combinedMethods;
        this.vtableSymbol = this.mangledName ~ "_vtable";
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(vtableSymbol))
            return;

        generator.mod.declareSymbolList(vtableSymbol, vtable_.length);
    }

    void define(Generator generator)
    {
        auto methods = [
            ({ method.declare(generator); method.mangle; })
            for method in vtable_];

        generator.mod.defineSymbolList(vtableSymbol, methods);
    }

    void genInstanceofMethod(Context context)
    {
        ASTStatement[] castStmts;
        Loc nowhere;
        Class current = this;
        while (current)
        {
            auto classinfo = new ASTSymbolHelper(new ClassInfo(current));
            castStmts ~= context.compiler.$stmt if (targetClassinfo is $classinfo) return this;;
            current = current.superClass;
        }
        castStmts ~= context.compiler.$stmt return null;;
        auto stmt = context.compiler.astSequence(castStmts, nowhere.reloc);

        bool override_ = false;
        if (this.superClass) override_ = true;
        this.methods ~= new ClassMethod(
            nowhere, this, override_, false /* abstract */, "__instanceof",
            this, [Argument(false, "targetClassinfo", once new Pointer(new Void))], stmt, new MacroState);
    }

    void genReleaseMethod(Context context)
    {
        ASTStatement[] statements;
        Loc nowhere;
        auto members = this.allMembers(context);
        assert(members.length >= 2);
        members = members[2 .. $]; // drop __classinfo and __refs
        for (int i = 0; i < members.length; i += 1) {
            auto name = context.compiler.astIdentifier(members[i].name, nowhere.reloc);
            statements ~= context.compiler.$stmt __destroy($name);;
        }
        auto stmt = context.compiler.astSequence(statements, nowhere.reloc);

        bool override_ = false;
        if (this.superClass) override_ = true;
        this.methods ~= new ClassMethod(
            nowhere, this, override_, false /* abstract */, "__destroy",
            once new Void, [], stmt, new MacroState);
    }

    override bool same(Type other) {
        Class otherClass = other.instanceOf(Class);

        return otherClass && otherClass.name == this.name; // TODO module
    }

    override string repr() { return this.name; }

    override void hash(Hash hash) {
        hash.apply(mangledHash.add, mangledHash.mult);
        // does there to be more here? I think not; Class is not being emitted as a distinct symbol
        // the vtable is hashed from the class decl
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        Context context = context; // TODO mut Context context
        Statement do_(Expression source) {
            auto sizeT = context.nativeWordType;
            auto refCountViolationFun = once new FunctionDeclaration(
                "cxruntime_refcount_violation", new Void, [
                    Argument(false, "label", new Array(new Character)),
                    Argument(false, "ptr", new Pointer(new Void))]);

            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "this", new IgnoreLifetimeExpr(source)));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "cxruntime_refcount_violation", refCountViolationFun));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "inc_name", new StringLiteral("inc " ~ this.name)));

            auto incref = context.compiler.$stmt
            if (!!this) {
                if ((cast(size_t*) this)[1] <= 0) {
                    cxruntime_refcount_violation(inc_name, &(cast(size_t*) this)[1]);
                }
                (cast(size_t*) this)[1] += 1;
            };
            auto assign = context.compiler.assignStatement(target, source);
            return sequence(incref.compile(context).statement, assign);
        }
        return context.compiler.stmtWithTemporary(source, &do_);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        Context context = context; // TODO mut Context context
        // disable lifetime management
        // (otherwise we get an infinite cycle when the compiler
        // tries to clean up 'this' after the __destroy() call by
        // ending its lifetime (ad infinitum).
        auto tempThis = new PairedTemporary(reference.type, false);
        auto initTemp = new InitializeTemporaryStatement(tempThis, reference);

        auto sizeT = context.nativeWordType;
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "this", tempThis));
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "size_t", sizeT));

        // TODO do in __destroy() once we have function imports
        auto freeFun = once new FunctionDeclaration(
            "free", new Void, [Argument(false, "ptr", new Pointer(new Void))]);
        auto refCountViolationFun = once new FunctionDeclaration(
            "cxruntime_refcount_violation", new Void, [
                Argument(false, "label", new Array(new Character)),
                Argument(false, "ptr", new Pointer(new Void))]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "free", freeFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "cxruntime_refcount_violation", refCountViolationFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "dec_name", new StringLiteral("dec " ~ this.name)));
        auto stmt = context.compiler.$stmt
            if (!!this) {
                if ((cast(size_t*) this)[1] <= 0) {
                    cxruntime_refcount_violation(dec_name, &(cast(size_t*) this)[1]);
                }
                (cast(size_t*) this)[1] -= 1;
                if ((cast(size_t*) this)[1] == 0) {
                    this.__destroy;
                    free(this);
                }
            };
        return sequence(initTemp, stmt.compile(context).statement);
    }
}

class ClassScope : Namespace
{
    Class class_;

    this(this.parent, this.class_) { }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (name == this.class_.name)
        {
            return this.class_;
        }
        return this.parent.lookup(name, context, frame);
    }
}

struct ASTClassDeclMember
{
    string name;

    ASTSymbol type;

    Loc loc;
}

struct ASTThisAssignment
{
    string name;
}

struct ASTClassDeclMethod
{
    Loc loc;

    bool override_;

    bool abstract_;

    string name;

    ASTSymbol ret;

    Either(ASTArgument, ASTThisAssignment)[] args;

    ASTStatement body_;
}

class ASTClassDecl : ASTSymbol
{
    string name;

    string superClass;

    bool final_;

    bool abstract_;

    ASTClassDeclMember[] members;

    ASTClassDeclMethod[] methods;

    MacroState macroState;

    Loc loc;

    this(this.name, this.superClass, this.final_, this.abstract_,
         this.members, this.methods, this.macroState, this.loc) { }

    override Class compile(Context context)
    {
        Class superClass = null;
        if (this.superClass.length)
        {
            Symbol superClassObj = context.namespace.lookup(this.superClass, context, null);
            this.loc.assert2s(!!superClassObj, "super class not found: " ~ this.superClass);
            superClass = superClassObj.instanceOf(Class);
            assert(!!superClass);
        }
        return new Class(this, superClass, context);
    }

    void compile2(Context context, Class target)
    {
        auto classScope = new ClassScope(context.namespace, target);
        Context classContext = context.withNamespace(classScope);

        target.members = [
            new ClassMember(member.name, beType(member.loc, member.type.compile(classContext)))
            for member in this.members];

        target.methods = new ClassMethod[](this.methods.length);
        target.initDataStruct(context);
        for (int i = 0; i < this.methods.length; i += 1)
        {
            ASTClassDeclMethod method = this.methods[i];

            auto methodArgs = new Argument[](method.args.length);
            for (int k = 0; k < method.args.length; k = k + 1)
            {
                auto arg = method.args[k];
                arg.case {
                    ASTThisAssignment arg:
                    {
                        ClassMember[] members = target.allMembers(context);
                        size_t member = [first i for i, a in members where a.name == arg.name else -1];
                        // TODO specific loc
                        method.loc.assert2s2(member != -1, "no such member: ", arg.name);
                        methodArgs[k] = Argument(true, arg.name, members[member].type);
                    }
                    ASTArgument arg:
                        methodArgs[k] = Argument(false, arg.name, beType(arg.loc, arg.type.compile(classContext)));
                }
            }

            target.methods[i] = new ClassMethod(
                method.loc,
                target,
                method.override_,
                method.abstract_,
                method.name,
                beType(method.loc, method.ret.compile(classContext)),
                methodArgs,
                method.body_, this.macroState);
        }
        target.genVtable(context);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTClassDecl'!"); assert(false); }
}

Either(ASTArgument, ASTThisAssignment)[] parseArglist(Parser parser, LexicalContext lexicalContext)
{
    Either(ASTArgument, ASTThisAssignment)[] args;
    while (!parser.accept(")"))
    {
        if (args.length > 0)
        {
            if (!parser.accept(","))
            {
                parser.fail("',' or ')' expected");
            }
        }
        auto loc = parser.loc;
        if (parser.accept("this."))
        {
            string argname = parseIdentifier(parser);
            args ~= ASTThisAssignment(argname);
        }
        else
        {
            ASTSymbol argtype = parseType(parser, lexicalContext);
            parser.assert_(!!argtype, "argument type expected");
            string argname = parseIdentifier(parser);
            parser.assert_(argname.length > 0, "argument name expected");
            args ~= ASTArgument(argname, argtype, loc);
        }
    }
    return args;
}

ASTClassDecl parseClassDecl(Parser parser, LexicalContext lexicalContext)
{
    bool classAbstract = false;
    bool classFinal = false;
    parser.begin;
    parser.strip;
    auto loc = parser.loc;
    while (true) {
        if (acceptIdentifier(parser, "abstract")) {
            classAbstract = true;
            continue;
        }
        if (acceptIdentifier(parser, "final")) {
            classFinal = true;
            continue;
        }
        break;
    }
    if (!acceptIdentifier(parser, "class"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parseIdentifier(parser);
    string superClass;
    if (parser.accept(":")) {
        superClass = parseIdentifier(parser);
        parser.assert_(superClass.length > 0, "expected super class identifier");
    }
    ASTClassDeclMember[] members;
    ASTClassDeclMethod[] methods;
    parser.expect("{");
    Loc nowhere;
    while (!parser.accept("}"))
    {
        parser.strip;

        Loc loc = parser.loc;

        ASTSymbol retType;
        string memberName;
        bool override_ = false;
        bool abstract_ = false;
        while (true) {
            if (acceptIdentifier(parser, "override")) {
                override_ = true;
                continue;
            }
            if (acceptIdentifier(parser, "abstract")) {
                abstract_ = true;
                continue;
            }
            break;
        }

        if (parser.accept("this"))
        {
            parser.assert_(!override_, "cannot override constructor");
            retType = new ASTBasicType("void", nowhere);
            memberName = "__ctor";
        }
        else
        {
            retType = parseType(parser, lexicalContext);
            parser.assert_(!!retType, "expected member type");
            memberName = parseIdentifier(parser);
            parser.assert_(memberName.length > 0, "expected member name");
        }
        if (parser.accept("(")) // method
        {
            auto args = parseArglist(parser, lexicalContext);
            ASTStatement stmt = parseStatement(parser, lexicalContext);
            methods ~= ASTClassDeclMethod(
                parser.loc, override_, abstract_, memberName, retType, args, stmt);
        }
        else
        {
            parser.assert_(!override_, "cannot override class member");
            parser.assert_(!abstract_, "cannot declare class member abstract");
            parser.expect(";");
            members ~= ASTClassDeclMember(memberName, retType, loc);
        }
    }
    return new ASTClassDecl(
        name, superClass, classFinal, classAbstract,
        members, methods, lexicalContext.macroState, loc);
}

class ASTModuleCacheEntry
{
    string path;
    ASTModule mod;
    this(this.path, this.mod) { }
}

class ASTModuleCache
{
    ASTModuleCacheEntry[] modules;
    this() { }
    ASTModule find(string path) {
        return [first a.mod for a in this.modules where a.path == path else null];
    }
    void add(string path, ASTModule mod) {
        this.modules ~= new ASTModuleCacheEntry(path, mod);
    }
}

class ModuleCacheEntry
{
    string key;
    Module mod;
    this(this.key, this.mod) { }
}

class ModuleCache
{
    ModuleCacheEntry[] modules;
    this() { }
    string key(string base, ASTModule mod) {
        return base ~ "_" ~ mod.pak.name ~ "_" ~ mod.name;
    }
    Module find(string base, ASTModule mod) {
        string key = this.key(base, mod);
        return [first a.mod for a in this.modules where a.key == key else null];
    }
    void add(string base, ASTModule astModule, Module module_) {
        this.modules ~= new ModuleCacheEntry(this.key(base, astModule), module_);
    }
}

class ModuleParserConfig
{
    Package[] packages;

    ASTModule[] defaultImports;

    ASTModuleCache astCache;

    ModuleCache cache;

    this(this.packages, this.defaultImports, this.astCache, this.cache) { }
}

ASTModule parseMacroContinuation(CompilerBase compiler, Parser parser, ParserHelper helper, ASTModule astModule,
    ModuleParserConfig config)
{
    parser.begin;
    if (!acceptIdentifier(parser, "macro") || !parser.accept("("))
    {
        parser.revert;
        return null;
    }
    parser.commit;
    string identifier = parseIdentifier(parser);
    parser.expect(")");
    parser.expect(";");

    auto newMacroState = astModule.macroState.dup;

    helper.proxyCall(astModule, identifier, newMacroState, config);

    auto subModule = new ASTModule(astModule.loc, astModule.name, astModule.pak, newMacroState, astModule);

    return parseModuleBody(compiler, parser, helper, subModule, config);
}

class ASTTemplateInstance : ASTSymbol
{
    ASTSymbol templateDecl;

    ASTSymbol type;

    Loc loc;

    this(this.templateDecl, this.type, this.loc) { }

    override Symbol compile(Context context)
    {
        auto symbol = this.templateDecl.compile(context);
        auto type = beType(this.loc, this.type.compile(context));
        auto templDecl = symbol.instanceOf(TemplateDecl);

        loc.assert2s(!!templDecl, "cannot instantiate non-template");

        return templDecl.resolve(context, this.loc, type);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTTemplateInstance'!"); assert(false); }
}

class TemplateInstantiationNamespace : Namespace
{
    string parameterName;

    Type parameterType;

    this(this.parent, this.parameterName, this.parameterType) { }

    override Symbol lookup(string name, Context context, Expression frame) {
        if (name == parameterName) return parameterType;
        return parent.lookup(name, context, frame);
    }

    override string mangle() {
        return this.parent.mangle ~ "_instance_" ~ parameterType.mangle;
    }
}

// very similar to ASTTemplateDecl
// they'll differentiate themselves later, when constraints are added.
class TemplateDecl : Symbol
{
    string name;

    Namespace templateScope;

    string typeParameterName;

    Either(ASTClassDecl, ASTFunction) content;

    this(this.name, this.templateScope, this.typeParameterName, this.content) { }

    Symbol resolve(Context context, Loc loc, Type parameter)
    {
        auto contextModule = findModule(context.namespace);
        // TODO mut context
        auto context = context.withNamespace(
            new TemplateInstantiationNamespace(context.namespace, typeParameterName, parameter));
        auto content = this.content.case(
            ASTClassDecl decl: decl.compile(context),
            ASTFunction fun: fun.compile(context).instanceOf(Function));
        string moduleMangle = name ~ "_instance_" ~ parameter.mangle;

        /*
         * Emit instance into new module.
         * This is so that an instantiation with the same types in different modules
         * gets the same reused symbols.
         */
        Module module_ = new Module(loc, name, moduleMangle, contextModule.macroState, null);
        content.case {
            Class class_:
                module_.add("", class_);
            Function fun:
                module_.add("", fun);
        }
        module_.resolve;
        print("module " ~ contextModule.mangledName ~ ": add " ~ module_.mangledName);
        contextModule.addImport(module_);

        return content.case(Class class_: class_.instanceOf(Symbol), Function fun: fun.instanceOf(Symbol));
    }
}

class ASTTemplateDecl
{
    string name;

    string typeParameterName;

    // TODO generalize
    Either(ASTClassDecl, ASTFunction) content;

    this(this.name, this.typeParameterName, this.content) { }

    Symbol compile(Context context)
    {
        return new TemplateDecl(name, context.namespace, typeParameterName, content);
    }
}

ASTTemplateDecl parseTemplateDecl(Parser parser, LexicalContext lexicalContext)
{
    auto loc = parser.loc;
    if (!acceptIdentifier(parser, "template"))
    {
        return null;
    }
    auto name = parseIdentifier(parser);
    parser.expect("(");
    auto typeParameter = parseIdentifier(parser);
    parser.expect(")");
    parser.expect("{");
    Either(ASTClassDecl, ASTFunction) member;
    if (ASTClassDecl classDecl = parseClassDecl(parser, lexicalContext))
    {
        member = classDecl;
    }
    else if (ASTFunction fun = parseFunction(parser, lexicalContext))
    {
        member = fun;
    }

    parser.expect("}");
    return new ASTTemplateDecl(name, typeParameter, member);
}

struct ASTStructMember
{
    string name;

    ASTSymbol type;
}

struct ASTStructMethod
{
    Loc loc;

    string name;

    ASTSymbol ret;

    Either(ASTArgument, ASTThisAssignment)[] args;

    ASTStatement body_;
}

class StructNamespace : Namespace
{
    Struct struct_;

    this(this.parent, this.struct_) { }

    override Symbol lookup(string name, Context context, Expression thisPtr)
    {
        auto thisPtr = new PointerCast(new Pointer(this.struct_), thisPtr);

        if (auto result = accessMemberWithLifetime(context, thisPtr, name, Loc(null, ReLoc("", 0)), true))
            return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, null);
    }
}

class StructMethod : Function
{
    Loc loc;

    string mangledName;

    this(this.loc, Struct structType, Context context, this.name, this.ret, this.args, this.statement,
         this.macroState)
    {
        // TODO super()
        auto structNamespace = new StructNamespace(context.namespace, structType);
        auto ptr = new Pointer(structType);

        this.hasThisArg = true;
        this.contextType = ptr;
        this.parent = structNamespace;
        // TODO mangle types
        this.mangledName = this.parent.mangle ~ "_" ~ ptr.target.instanceOf(Struct).name ~ "_" ~ this.name;
    }

    override string mangle()
    {
        return mangledName;
    }
}

// TODO merge with ClassScope into AliasScope
class StructScope : Namespace
{
    Struct struct_;

    this(this.parent, this.struct_) { }

    override Symbol lookup(string name, Context context, Expression frame)
    {
        if (name == this.struct_.name)
        {
            return this.struct_;
        }
        return this.parent.lookup(name, context, frame);
    }
}

class ASTStructDecl : ASTSymbol
{
    string name;

    ASTStructMember[] members;

    ASTStructMethod[] methods;

    MacroState macroState;

    Loc loc;

    this(this.name, this.members, this.methods, this.macroState, this.loc) { }

    override Struct compile(Context context)
    {
        auto members = [
            new StructMemberDeclaration(member.name, beType(this.loc, member.type.compile(context)))
            for member in this.members];

        auto struct_ = new Struct(this.name, members, this.loc, context.namespace.mangle);
        auto structScope = new StructScope(context.namespace, struct_); // make S visibile in struct S {}
        auto structContext = context.withNamespace(structScope);

        struct_.methods = new FunctionDeclaration[](this.methods.length);
        for (int i = 0; i < this.methods.length; i += 1)
        {
            auto method = this.methods[i];
            auto methodArgs = new Argument[](method.args.length);

            for (int k = 0; k < method.args.length; k = k + 1) {
                method.args[k].case {
                    ASTArgument arg:
                        methodArgs[k] = Argument(false, arg.name, beType(arg.loc, arg.type.compile(structContext)));
                    ASTThisAssignment arg:
                        assert(false); // TODO this.foo
                }
            }

            struct_.methods[i] = new StructMethod(
                method.loc,
                struct_,
                context,
                method.name,
                beType(this.loc, method.ret.compile(structContext)),
                methodArgs,
                method.body_, this.macroState);
        }
        return struct_;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTStructDecl'!"); assert(false); }
}

ASTStructDecl parseStructDecl(Parser parser, LexicalContext lexicalContext)
{
    Loc loc = parser.loc;
    parser.begin;
    if (parseIdentifier(parser) != "struct")
    {
        parser.revert;
        return null;
    }
    string name = parseIdentifier(parser);
    assert(!!name.length);
    ASTStructMember[] members;
    ASTStructMethod[] methods;
    parser.expect("{");
    while (!parser.accept("}"))
    {
        ASTSymbol memberType;
        string memberName;
        if (parser.accept("this"))
        {
            memberType = new ASTBasicType("void", loc);
            memberName = "__ctor";
        }
        else if (parser.accept("~this"))
        {
            memberType = new ASTBasicType("void", loc);
            memberName = "__dtor";
        }
        else
        {
            memberType = parseType(parser, lexicalContext);
            if (!memberType) parser.fail("expected member type");
            memberName = parseIdentifier(parser);
            if (!memberName.length) parser.fail("expected member name");
        }
        if (parser.accept("(")) // method
        {
            auto args = parseArglist(parser, lexicalContext);
            parser.assert_(
                memberName != "__dtor" || args.length == 0, "destructor cannot take parameters");
            ASTStatement stmt = parseStatement(parser, lexicalContext);
            methods ~= ASTStructMethod(
                parser.loc, memberName, memberType, args, stmt);
        }
        else
        {
            parser.assert_(memberName != "__ctor", "constructor cannot be member");
            parser.assert_(memberName != "__dtor", "destructor cannot be member");
            parser.expect(";");
            members ~= ASTStructMember(memberName, memberType);
        }
    }
    parser.commit;
    return new ASTStructDecl(name, members, methods, lexicalContext.macroState, loc);
}

Package selectPackage(Package[] packages, string name, Loc loc)
{
    auto result = [first a for a in packages where a.name == name else null];
    loc.assert2s(!!result, "Undefined package: '" ~ name ~ "'");
    return result;
}

class ASTSymbolAlias
{
    string name;

    ASTSymbol symbol;

    this(this.name, this.symbol) { }
}

ASTModule parseModuleBody(CompilerBase compiler, Parser parser, ParserHelper helper, ASTModule module_,
    ModuleParserConfig config)
{
    LexicalContext lexicalContext = new LexicalContext(compiler, module_.macroState);

    while (!parser.eof)
    {
        if (ASTImport import_ = parseImport(parser)) {
            if (import_.isMacroImport)
            {
                auto importedModule = resolveImport(compiler, module_, import_, helper, config);

                module_.macroState = module_.macroState.dup;
                lexicalContext = new LexicalContext(compiler, module_.macroState);

                lexicalContext.macroState.addImport(importedModule.macroState);
            }
            else
            {
                module_.entries ~= import_;
            }
            continue;
        }
        if (ASTClassDecl classDecl = parseClassDecl(parser, lexicalContext)) {
            // TODO implconv check
            module_.entries ~= classDecl.instanceOf(ASTSymbol);
            continue;
        }
        if (ASTTemplateDecl templateDecl = parseTemplateDecl(parser, lexicalContext)) {
            module_.entries ~= templateDecl;
            continue;
        }
        if (ASTExtern extern_ = parseExtern(parser, lexicalContext)) {
            module_.entries ~= extern_;
            continue;
        }
        if (ASTStructDecl strct = parseStructDecl(parser, lexicalContext)) {
            // TODO implconv
            module_.entries ~= strct.instanceOf(ASTSymbol);
            continue;
        }
        if (ASTEnumDecl enumDecl = parseEnumDecl(parser, lexicalContext)) {
            // TODO implconv
            module_.entries ~= enumDecl.instanceOf(ASTSymbol);
            continue;
        }
        if (ASTModule submod = parseMacroContinuation(compiler, parser, helper, module_, config))
            return submod;
        if (ASTFunction fun = parseFunction(parser, lexicalContext))
        {
            module_.entries ~= fun;
            continue;
        }

        parser.fail("couldn't parse function or struct");
    }
    assert(parser.level == 0);
    return module_;
}

ASTModule resolveImport(CompilerBase compiler, ASTModule module_, ASTImport import_, ParserHelper helper,
    ModuleParserConfig config)
{
    auto pak = module_.pak;
    // TODO enum SearchMode { Transitive, Direct, Commandline }
    bool transitive = true;
    if (import_.pak.length) {
        pak = selectPackage(config.packages, import_.pak, import_.loc);
        transitive = false;
    }
    return getModule(
        compiler, moduleToFile(import_.name), pak, true, helper, config, import_.loc);
}

Module compileImport(ASTModule module_, ASTImport import_, ParserHelper helper,
                     CompilerBase compiler, ModuleParserConfig config, Platform platform)
{
    auto astModule = resolveImport(compiler, module_, import_, helper, config);

    return compileModule(astModule, helper, config, compiler, platform, true);
}

Module compileModule(ASTModule astModule, ParserHelper helper, ModuleParserConfig config,
                     CompilerBase compiler, Platform platform, bool addDefaultModules)
{
    string baseKey = platform.nativeWordType.repr;
    if (Module mod = config.cache.find(baseKey, astModule))
        return mod;

    Module parent = null;

    if (astModule.parent)
    {
        parent = compileModule(astModule.parent, helper, config, compiler, platform, addDefaultModules);
    }

    string mangledName = mangleModuleName(astModule.name, astModule.pak);
    Module module_ = new Module(astModule.loc, astModule.name, mangledName, astModule.macroState, parent);
    auto context = makeContext(compiler, platform, module_, module_.macroState);
    if (addDefaultModules)
    {
        // TODO add to ASTModule (addImport that handles updating the macro state
        // so that adding default macro imports works)
        // NOTE once these are in ASTModule, we can take out ModuleParserConfig here and also from proxyCall.
        for (int i = 0; i < config.defaultImports.length; i += 1) {
            auto import_ = compileModule(config.defaultImports[i], helper, config, compiler, platform, false);
            module_.addImport(import_);
        }
    }

    for (int i = 0; i < astModule.entries.length; i += 1)
    {
        auto entry = astModule.entries[i];
        // TODO lazily resolve members only once they're looked up
        // (allows compilation in any order)
        entry.case {
            ASTImport import_:
            {
                auto importedModule = compileImport(astModule, import_, helper, compiler, config, platform);

                module_.addImport(importedModule);
            }
            ASTSymbol typeDecl: {
                // TODO ASTSymbolDecl?
                if (auto classDecl = typeDecl.instanceOf(ASTClassDecl)) {
                    module_.add(classDecl.name, classDecl.compile(context));
                }
                else if (auto structDecl = typeDecl.instanceOf(ASTStructDecl)) {
                    module_.add(structDecl.name, structDecl.compile(context));
                }
                else if (auto enumDecl = typeDecl.instanceOf(ASTEnumDecl)) {
                    module_.add(enumDecl.name, enumDecl.compile(context));
                }
                else assert(false);
            }
            ASTExtern extern_:
                module_.add(extern_.name, extern_.compile(context));
            ASTFunction function_:
                module_.add(function_.name, function_.compile(context));
            ASTSymbolAlias symbolAlias:
                module_.add(symbolAlias.name, symbolAlias.symbol.compile(context));
            ASTTemplateDecl astTemplateDecl:
                module_.add(astTemplateDecl.name, astTemplateDecl.compile(context));
        }
    }
    module_.resolve;
    config.cache.add(baseKey, astModule, module_);
    return module_;
}

ASTModule getModule(CompilerBase compiler, string filename, Package pak, bool search, ParserHelper helper,
    ModuleParserConfig config, Loc loc)
{
    auto pak = pak; // TODO mut Package pak
    auto macroState = new MacroState;
    string filename = filename; // TODO mut string filename,
    string path = filename;
    if (search) {
        assert2s(!!pak, "search, but no package");
        // This is very janky and should not work, because it overwrites pak while findFileInPackage has it borrowed.
        // FIXME result(), result()
        void result1(Package resultPak) { pak = resultPak; }
        path = findFileInPackage(filename, pak, loc, &result1);
    } else {
        assert2s(!pak, "no search, but package");
        // This is very janky and should not work, because it overwrites pak while findFileInPackage has it borrowed.
        void result2(Package resultPak) { pak = resultPak; }
        filename = findResidualFilename(filename, config.packages, &result2);
    }
    assert(!!pak);
    if (ASTModule mod = config.astCache.find(path)) return mod;

    Loc nowhere;
    auto basicObjectCache = new BasicObjectCache(
        new ASTBasicType("void", nowhere),
        new ASTBasicType("char", nowhere),
        new ASTBasicType("short", nowhere),
        new ASTBasicType("int", nowhere),
        new ASTBasicType("long", nowhere),
        new ASTBasicType("float", nowhere));

    string code = cxruntime_file_read(path);
    Parser parser = new Parser(path, code, basicObjectCache, compiler.linenr);

    auto locAtModule = parser.loc;
    parser.expect("module");
    string modname = parseIdentifier2(parser, ".");
    parser.expect(";");

    locAtModule.assert2s2(filename == moduleToFile(modname), filename, ": module doesn't match filename");

    ASTModule baseModule = new ASTModule(locAtModule, modname, pak, new MacroState, null);
    ASTModule module_ = parseModuleBody(compiler, parser, helper, baseModule, config);

    config.astCache.add(path, module_);

    return module_;
}
