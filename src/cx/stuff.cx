// TODO distribute into more appropriate modules
module cx.stuff;

import backend.base;
import cx.array;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser;
import cx.parser_base;
import cx.statements;
import cx.struct_;
import cx.types;
import helpers;

extern(C) bool cxruntime_file_exists(string file);
extern(C) string cxruntime_file_read(string file);
extern(C) void cxruntime_file_write(string file, string content);

struct ASTArgument
{
    string name;

    ASTType type;
}

class Function : FunctionDeclaration
{
    Loc loc;

    ASTStatement statement;

    MacroState macroState;

    Statement compiledStatement;

    Namespace parent;

    this(Loc loc, string name, Type ret, Argument[] args, ASTStatement statement, MacroState macroState)
    {
        this.loc = loc;
        this.name = name;
        this.ret = ret;
        this.args = args;
        this.statement = statement;
        this.macroState = macroState;
        this.compiledStatement = null;
        this.thisType = null;
        this.parent = null;
    }

    override string mangle()
    {
        if (this.name == "main") return "_main"; // globally unique
        return this.parent.mangle() ~ "_" ~ this.name;
    }

    override void declare(Generator generator)
    {
        Type voidp = new Pointer(new Void);
        int extra = 0;
        if (this.thisType) extra = 1;
        auto argTypes = new BackendType[](this.args.length + extra);
        if (this.thisType) argTypes[0] = voidp.emit(generator.platform);
        for (int i = 0; i < this.args.length; i += 1)
            argTypes[extra + i] = this.args[i].type.emit(generator.platform);

        generator.mod.declare(
            this.mangle(),
            this.ret.emit(generator.platform),
            argTypes
        );
    }

    CompiledFunction compile(Platform platform)
    {
        auto stackframe = new FunctionScope(this.ret, this.thisType, this.parent);
        Namespace scope_ = stackframe;
        int extra = 0;
        if (this.thisType)
            extra = 1;

        auto argAssignments = new Statement[](this.args.length + extra);

        if (this.thisType)
        {
            auto thisDecl = new VariableDeclaration(scope_, "this", this.thisType);
            Type voidp = new Pointer(new Void);

            scope_ = thisDecl;

            argAssignments[0] = new AssignStatement(
                thisDecl.accessLocal(),
                new PointerCast(this.thisType, new ArgExpr(0, voidp)),
                this.loc);
        }
        for (int i = 0; i < this.args.length; i += 1) {
            Argument arg = this.args[i];
            auto argExpr = new ArgExpr(extra + i, arg.type);
            auto argDecl = new VariableDeclaration(scope_, arg.name, arg.type);

            argAssignments[extra + i] = new AssignStatement(argDecl.accessLocal(), argExpr, this.loc);

            scope_ = argDecl;
        }

        auto compiledStatement = this.compiledStatement;

        if (!compiledStatement)
        {
            auto context = Context(platform, scope_, null, this.macroState, (new int[](1)).ptr);
            auto pair = this.statement.compile(context);

            compiledStatement = pair.statement;
        }

        return new CompiledFunction(this, compiledStatement, stackframe, argAssignments);
    }
}

// TODO clear all this up
abstract class FinishedSymbol
{
    abstract void emit(Generator generator) { assert(false); }
    abstract void hash(Hash hash) { assert(false); }
}

// and this
class DefineClass : FinishedSymbol
{
    Class class_;

    this(Class class_) { this.class_ = class_; }

    override void emit(Generator generator)
    {
        class_.define(generator);
    }

    override void hash(Hash hash)
    {
        // only the actual vtable symbol
        for (int i = 0; i < class_.vtable_.length; i += 1) {
            hash.adds(class_.vtable_[i].mangle());
        }
    }
}

class CompiledFunction : FinishedSymbol
{
    Function fun;

    Statement compiledStatement;

    FunctionScope stackframe;

    Statement[] argAssignments;

    this(Function fun, Statement compiledStatement, FunctionScope stackframe, Statement[] argAssignments)
    {
        this.fun = fun;
        this.compiledStatement = compiledStatement;
        this.stackframe = stackframe;
        this.argAssignments = argAssignments;
    }

    override void emit(Generator generator)
    {
        assert(generator.once(this.fun.mangle()));

        assert(!generator.fun);
        Type voidp = new Pointer(new Void);
        int extra = 0;
        if (this.fun.thisType) extra = 1;
        auto argTypes = new BackendType[](this.fun.args.length + extra);
        if (this.fun.thisType) argTypes[0] = voidp.emit(generator.platform);
        for (int i = 0; i < this.fun.args.length; i += 1)
            argTypes[extra + i] = this.fun.args[i].type.emit(generator.platform);
        generator.fun = generator.mod.define(
            this.fun.mangle(),
            this.fun.ret.emit(generator.platform),
            argTypes
        );

        generator.frameReg = generator.fun.alloca(this.stackframe.structType().emit(generator.platform));

        for (int i = 0; i < this.argAssignments.length; i += 1)
        {
            this.argAssignments[i].emit(generator);
        }

        this.compiledStatement.emit(generator);

        generator.fun.ret(generator.fun.voidLiteral());
        generator.fun.done();
        generator.fun = null;
        generator.frameReg = -1;
    }

    override void hash(Hash hash) {
        hash.adds("fndef");
        hash.adds(fun.name);
        fun.ret.hash(hash);
        hash.addl(fun.args.length);
        for (int i = 0; i < fun.args.length; i += 1) {
            hash.adds(fun.args[i].name);
            fun.args[i].type.hash(hash);
        }
        if (fun.thisType) fun.thisType.hash(hash);
        else hash.adds("null");
        this.compiledStatement.hash(hash);
    }
}

class ASTFunction
{
    Loc loc;

    string name;

    ASTType ret;

    ASTArgument[] args;

    bool isDeclaration;

    ASTStatement statement;

    MacroState macroState;

    this(
        Loc loc, string name, ASTType ret, ASTArgument[] args, bool isDeclaration, ASTStatement statement,
        MacroState macroState)
    {
        this.loc = loc;
        this.name = name;
        this.ret = ret;
        this.args = args;
        this.isDeclaration = isDeclaration;
        this.statement = statement;
        this.macroState = macroState;
    }

    FunctionDeclaration compile(Context context)
    {
        auto arguments = new Argument[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1)
        {
            ASTArgument arg = this.args[i];
            Type type = arg.type.compile(context);
            arguments[i] = Argument(arg.name, type);
        }

        if (this.isDeclaration)
        {
            return new FunctionDeclaration(
                this.name, this.ret.compile(context), arguments);
        }

        auto fun = new Function(
            this.loc,
            this.name,
            this.ret.compile(context),
            arguments,
            this.statement, this.macroState);

        fun.parent = context.namespace;
        return fun;
    }
}

ASTArgument[] parseIdentifierList(Parser parser, LexicalContext lexicalContext)
{
    ASTArgument[] args;
    while (!parser.accept(")"))
    {
        if (args.length) {
            if (!parser.accept(",")) {
                parser.fail("',' or ')' expected");
            }
        }
        ASTType argtype = parseType(parser, lexicalContext);
        if (!argtype) {
            parser.fail("type expected");
        }
        string argname = parseIdentifier(parser);
        args ~= ASTArgument(argname, argtype);
    }
    return args;
}

class ArgExpr : Expression
{
    int index;

    Type type_;

    this(int index, Type type_) { this.index = index; this.type_ = type_; }

    override int emit(Generator output)
    {
        return output.fun.arg(this.index);
    }

    override Type type()
    {
        return this.type_;
    }

    override void hash(Hash hash) { hash.adds("ArgExpr"); hash.addl(index); }
}

class FuncPtrCall : Expression
{
    Expression funcPtr;

    Expression[] args;

    Loc loc;

    this(Expression funcPtr, Expression[] args, Loc loc) {
        this.funcPtr = funcPtr;
        this.args = args;
        this.loc = loc;
    }

    override Type type()
    {
        return this.funcPtr.type().instanceOf(FunctionPointer).ret;
    }

    override int emit(Generator output)
    {
        FunctionPointer type = this.funcPtr.type().instanceOf(FunctionPointer);

        this.loc.assert2s4(
            type.args.length == this.args.length,
            "expected ", ltoa(type.args.length), " args, not ", ltoa(this.args.length));

        int[] regs = new int[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1)
        {
            auto arg = this.args[i];
            arg = implicitConvertTo(arg, type.args[i], this.loc);

            regs[i] = arg.emit(output);
        }
        return output.fun.callFuncPtr(
            type.emit(output.platform), this.funcPtr.emit(output), regs);
    }

    override void hash(Hash hash) {
        hash.adds("FuncPtrCall");
        funcPtr.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

class ClassMethodPtr : Symbol
{
    Expression funcPtr;

    Expression thisPtr;

    this(Expression funcPtr, Expression thisPtr) { this.funcPtr = funcPtr; this.thisPtr = thisPtr; }
}

class StructConstructor : Expression
{
    Struct struct_;

    Expression[] args;

    Loc loc;

    this(Struct struct_, Expression[] args, Loc loc)
    {
        this.struct_ = struct_;
        this.args = args;
        this.loc = loc;
    }

    override Type type()
    {
        return this.struct_;
    }

    override int emit(Generator output)
    {
        this.loc.assert2s(this.args.length == this.struct_.members.length, "invalid number of args for struct constructor");

        auto struct_ = this.struct_.emit(output.platform);
        auto stack = output.fun.saveStack();
        int ptr = output.fun.alloca(struct_);
        for (int i = 0; i < this.args.length; i += 1) {
            auto arg = this.args[i];

            arg = implicitConvertTo(arg, this.struct_.members[i].type, this.loc);

            int valueReg = arg.emit(output);
            int offsetReg = output.fun.fieldOffset(struct_, ptr, i);
            output.fun.store(arg.type().emit(output.platform), offsetReg, valueReg);
        }
        auto ret = output.fun.load(struct_, ptr);
        output.fun.restoreStack(stack);
        return ret;
    }

    override void hash(Hash hash) {
        hash.adds("StructConstructor");
        struct_.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

Expression call(Symbol target, Expression[] args, Loc loc)
{
    if (target.instanceOf(FunctionDeclaration))
    {
        return new Call(target.instanceOf(FunctionDeclaration), args, loc);
    }
    ClassMethodPtr method = target.instanceOf(ClassMethodPtr);
    if (method)
    {
        Expression[] combinedArgs;
        combinedArgs ~= method.thisPtr;
        for (int i = 0; i < args.length; i += 1) combinedArgs ~= args[i];
        return new FuncPtrCall(method.funcPtr, combinedArgs, loc);
    }
    Expression expr = target.instanceOf(Expression);
    if (expr && expr.type().instanceOf(FunctionPointer))
    {
        return new FuncPtrCall(expr, args, loc);
    }
    Struct struct_ = target.instanceOf(Struct);
    if (struct_)
    {
        return new StructConstructor(struct_, args, loc);
    }
    loc.assert2s(false, "unknown call target");
}

class ASTCall : ASTSymbol
{
    ASTSymbol target;

    ASTSymbol[] args;

    Loc loc;

    this(ASTSymbol target, ASTSymbol[] args, Loc loc)
    {
        this.target = target;
        this.args = args;
        this.loc = loc;
    }

    override Expression compile(Context context)
    {
        ASTIdentifier ident = this.target.instanceOf(ASTIdentifier);
        if (ident)
        {
            auto callMacroArgs = new CallMacroArgs(ident.name, this.args, context, this.loc);
            context.macroState.applyMacro(callMacroArgs);
            if (callMacroArgs.transformed) return callMacroArgs.transformed;
        }
        auto target = this.target.compile(context);
        auto args = new Expression[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1)
        {
            args[i] = beExpression2(this.args[i].compile(context), this.loc);
        }
        return call(target, args, this.loc);
    }
}

ASTSymbol[] parseSymbolList(Parser parser, LexicalContext lexicalContext)
{
    ASTSymbol[] args;
    while (!parser.accept(")"))
    {
        if (args.length > 0)
            parser.expect(",");

        args ~= parseExpression(parser, lexicalContext);
    }
    return args;
}

ASTCall parseCall(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin();
    if (!parser.accept("("))
    {
        parser.revert();
        return null;
    }
    auto args = parseSymbolList(parser, lexicalContext);
    parser.commit();
    return new ASTCall(base, args, parser.loc());
}

class ASTIndexAccess : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol index;

    Loc loc;

    this(ASTSymbol base, ASTSymbol index, Loc loc) {
        this.base = base;
        this.index = index;
        this.loc = loc;
    }

    override Expression compile(Context context)
    {
        Type wordType = nativeWordType(context.platform);
        Expression base = beExpression(this.base.compile(context));
        Expression index = beExpression(this.index.compile(context));

        index = implicitConvertTo(index, wordType, this.loc);
        Array array_ = base.type().instanceOf(Array);
        if (array_)
        {
            // TODO bounds check
            base = new ArrayPointer(array_.elementType, base);
        }

        assert(index.type().same(wordType));
        return new Dereference(new PointerOffset(base, index));
    }
}

class ASTArraySlice : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lower;

    ASTSymbol upper;

    Loc loc;

    this(ASTSymbol array, ASTSymbol lower, ASTSymbol upper, Loc loc)
    {
        this.array = array;
        this.lower = lower;
        this.upper = upper;
        this.loc = loc;
    }

    override Symbol compile(Context context)
    {
        Type wordType = nativeWordType(context.platform);

        return new ArraySlice(
            beExpression(this.array.compile(context)),
            implicitConvertTo(beExpression(this.lower.compile(context)), wordType, this.loc),
            implicitConvertTo(beExpression(this.upper.compile(context)), wordType, this.loc),
            this.loc);
    }
}

ASTSymbol parseIndex(Parser parser, LexicalContext lexicalContext, ASTSymbol base)
{
    parser.begin();
    if (!parser.accept("["))
    {
        parser.revert();
        return null;
    }
    ASTSymbol index = parseExpression(parser, lexicalContext);
    assert(!!index); // "index expected"
    if (parser.accept(".."))
    {
        ASTSymbol lower = index;
        ASTSymbol upper = parseExpression(parser, lexicalContext);
        parser.assert_(!!upper, "slice upper bound expected");
        parser.expect("]");
        parser.commit();
        return new ASTArraySlice(base, lower, upper, parser.loc());
    }
    parser.expect("]");
    parser.commit();
    return new ASTIndexAccess(base, index, parser.loc());
}

Symbol accessMember(Symbol base, string member, Loc loc, bool allowUndefined)
{
    if (!base.instanceOf(Expression))
    {
        loc.assert2s(false, "expected expression for member access");
    }
    Expression baseExpr = beExpression(base);

    while (baseExpr.type().instanceOf(Pointer)) {
        baseExpr = new Dereference(baseExpr);
    }
    Struct structType = baseExpr.type().instanceOf(Struct);
    if (structType)
    {
        if (!baseExpr.instanceOf(Reference))
        {
            loc.assert2s(false, "TODO struct member of value");
        }
        int memberOffset = -1;
        for (int i = 0; i < structType.members.length; i += 1)
        {
            if (structType.members[i].name == member) { memberOffset = i; break; }
        }
        if (memberOffset != -1)
            return new StructMember(baseExpr.instanceOf(Reference), memberOffset);
        int methodOffset = -1;
        for (int i = 0; i < structType.methods.length; i += 1)
        {
            if (structType.methods[i].name == member) { methodOffset = i; break; }
        }
        if (methodOffset != -1)
        {
            // TODO dereference-into-symbol so we can '&' it again
            auto funcPtr = new FunctionReference(structType.methods[methodOffset]);
            return new ClassMethodPtr(funcPtr, new ReferenceExpression(baseExpr.instanceOf(Reference)));
        }
        if (allowUndefined) return null;
        loc.assert2s2(false, "no such member or method ", member);
    }
    Class classType = baseExpr.type().instanceOf(Class);
    if (classType)
    {
        ClassMethod[] vtable = classType.vtable();
        int methodOffset = -1;
        for (int i = 0; i < vtable.length; i += 1) {
            if (vtable[i].name == member) { methodOffset = i; break; }
        }
        Expression asStructPtr = new PointerCast(new Pointer(classType.dataStruct()), baseExpr);
        if (methodOffset != -1)
        {
            Reference classInfo = new Dereference(new PointerCast(
                new Pointer(classType.classInfoStruct()), new StructMember(new Dereference(asStructPtr), 0)));
            // TODO dereference-into-symbol so we can '&' it again
            auto funcPtr = new StructMember(classInfo, methodOffset);
            return new ClassMethodPtr(funcPtr, baseExpr);
        }

        ClassMember[] members = classType.allMembers();
        int memberOffset = -1;
        for (int i = 0; i < members.length; i += 1)
            if (members[i].name == member) { memberOffset = i; break; }
        if (memberOffset != -1)
            return new StructMember(new Dereference(asStructPtr), memberOffset);
        if (allowUndefined) return null;
        loc.assert2s4(false, "no such member ", member, " in ", classType.name);
    }
    if (!allowUndefined)
        loc.assert2s2(false, "expected struct/class type for member, not ", baseExpr.type().repr());
    return null;
}

class ASTMember : ASTSymbol
{
    ASTSymbol base;

    string member;

    Loc loc;

    this(ASTSymbol base, string member, Loc loc) {
        this.base = base;
        this.member = member;
        this.loc = loc;
    }

    override Symbol compile(Context context)
    {
        Symbol base = this.base.compile(context);
        Expression expr = base.instanceOf(Expression);

        if (expr && expr.type().instanceOf(Array) && this.member == "length")
        {
            return new ArrayLength(expr, nativeWordType(context.platform));
        }

        if (expr && expr.type().instanceOf(Array) && this.member == "ptr")
        {
            return new ArrayPointer(expr.type().instanceOf(Array).elementType, expr);
        }

        return accessMember(base, this.member, this.loc, false);
    }
}

ASTMember parseMember(Parser parser, ASTSymbol base)
{
    parser.begin();
    if (parser.accept("..") || !parser.accept(".")) // don't accept '..'
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    parser.assert_(name.length > 0, "member expected");
    parser.commit();
    return new ASTMember(base, name, parser.loc());
}

class ASTInstanceOf : ASTSymbol
{
    ASTSymbol base;

    ASTType target;

    Loc loc;

    this(ASTSymbol base, ASTType target, Loc loc) {
        this.base = base;
        this.target = target;
        this.loc = loc;
    }

    override Symbol compile(Context context)
    {
        Expression base = beExpression(this.base.compile(context));
        assert(!!base.type().instanceOf(Class));
        Class target = this.target.compile(context).instanceOf(Class);
        assert(!!target);
        Symbol instanceOf = accessMember(base, "__instanceof", this.loc, false);
        Expression name = new StringLiteral(target.name);
        return new PointerCast(target, call(instanceOf, new Expression[](0) ~ name, this.loc));
    }
}

ASTSymbol parseInstanceOf(Parser parser, LexicalContext lexicalContext, ASTSymbol left)
{
    parser.begin();
    if (!(parser.accept(".") && parser.accept("instanceOf")))
    {
        parser.revert();
        return null;
    }
    parser.expect("(");
    ASTType type = parseType(parser, lexicalContext);
    parser.expect(")");
    parser.commit();
    return new ASTInstanceOf(left, type, parser.loc());
}

ASTSymbol parseProperties(Parser parser, LexicalContext lexicalContext, ASTSymbol current)
{
    while (true)
    {
        ASTSymbol instanceOf = parseInstanceOf(parser, lexicalContext, current);
        if (instanceOf)
        {
            current = instanceOf;
            continue;
        }
        auto macroArgs = new ParsePropertyArgs(parser, lexicalContext, current);

        lexicalContext.macroState.applyMacro(macroArgs);
        if (macroArgs.result)
        {
            current = macroArgs.result;
            continue;
        }
        ASTSymbol call = parseCall(parser, lexicalContext, current);
        if (call)
        {
            current = call;
            continue;
        }
        ASTSymbol memberAccess = parseMember(parser, current);
        if (memberAccess)
        {
            current = memberAccess;
            continue;
        }
        ASTSymbol indexAccess = parseIndex(parser, lexicalContext, current);
        if (indexAccess)
        {
            current = indexAccess;
            continue;
        }
        return current;
    }
}

class ASTDereference : ASTSymbol
{
    ASTSymbol base;

    this(ASTSymbol base) { this.base = base; }

    override Symbol compile(Context context)
    {
        return new Dereference(beExpression(this.base.compile(context)));
    }
}

class Dereference : Reference
{
    Expression base;

    Pointer pointerType;

    this(Expression base)
    {
        this.base = base;
        this.pointerType = base.type().instanceOf(Pointer);
        assert(!!this.pointerType);
    }

    override Type type()
    {
        return this.pointerType.target;
    }

    override int emit(Generator output)
    {
        int reg = this.emitLocation(output);

        return output.fun.load(this.type().emit(output.platform), reg);
    }

    override int emitLocation(Generator output)
    {
        return this.base.emit(output);
    }

    override void hash(Hash hash) { hash.adds("Dereference"); base.hash(hash); }
}

class FunctionReference : Expression
{
    FunctionDeclaration fun;

    this(FunctionDeclaration fun) { this.fun = fun; }

    override Type type()
    {
        int extra = 0;
        if (this.fun.thisType) extra = 1;
        auto argTypes = new Type[](this.fun.args.length + extra);
        if (this.fun.thisType) argTypes[0] = new Pointer(new Void);
        for (int i = 0; i < this.fun.args.length; i += 1)
            argTypes[extra + i] = this.fun.args[i].type;

        return new FunctionPointer(this.fun.ret, argTypes);
    }

    override int emit(Generator output)
    {
        this.fun.declare(output);

        return output.fun.getFuncPtr(this.fun.mangle());
    }

    override void hash(Hash hash) { hash.adds("FunctionReference"); hash.adds(fun.mangle()); }
}

class ASTReference : ASTSymbol
{
    ASTSymbol base;

    this(ASTSymbol base) { this.base = base; }

    override Expression compile(Context context)
    {
        // &function
        ASTIdentifier ident = this.base.instanceOf(ASTIdentifier);
        if (ident) {
            auto frame = new ReferenceExpression(new StackFrame(new Void));
            Symbol target = context.namespace.lookup(ident.name, frame);
            if (target) {
                Function fun = target.instanceOf(Function);

                if (fun) return new FunctionReference(fun);
            }
        }
        Symbol baseExpression = this.base.compile(context);

        assert(!!baseExpression.instanceOf(Reference));

        return new ReferenceExpression(baseExpression.instanceOf(Reference));
    }
}

class ReferenceExpression : Expression
{
    Reference base;

    this(Reference base) { this.base = base; }

    override Type type()
    {
        Type superType = this.base.type();

        return new Pointer(superType);
    }

    override int emit(Generator output)
    {
        return this.base.emitLocation(output);
    }

    override void hash(Hash hash) { hash.adds("ReferenceExpression"); base.hash(hash); }
}

class SizeOf : Expression
{
    Type type_;

    this(Type type_) { this.type_ = type_; }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        int size = this.type_.emit(output.platform).size(output.platform);

        return output.fun.intLiteral(size);
    }

    override void hash(Hash hash) { hash.adds("SizeOf"); type_.hash(hash); }
}

class NewClassExpression : Expression
{
    Class classType;

    this(Class classType) { this.classType = classType; }

    override Type type()
    {
        return this.classType;
    }

    override int emit(Generator output)
    {
        // oh boy!
        this.classType.declare(output);
        Struct classDataStruct = this.classType.dataStruct();
        BackendType voidp = (new Pointer(new Void)).emit(output.platform);
        int classInfoPtr = output.fun.symbolList(this.classType.vtableSymbol);
        int classDataSize = classDataStruct.emit(output.platform).size(output.platform);
        int classPtr = output.fun.call(
            voidp, "cxruntime_alloc", new int[](0) ~ output.fun.wordLiteral(output.platform, classDataSize));
        int classInfoTarget = output.fun.fieldOffset(classDataStruct.emit(output.platform), classPtr, 0);
        output.fun.store(voidp, classInfoTarget, classInfoPtr);

        return classPtr;
    }

    override void hash(Hash hash) { hash.adds("NewClassExpression"); classType.hash(hash); }
}

class CallCtorExpression : Expression
{
    Expression classptr;

    Expression[] args;

    Loc loc;

    this(Expression classptr, Expression[] args, Loc loc) {
        this.classptr = classptr;
        this.args = args;
        this.loc = loc;
    }

    override Type type()
    {
        return this.classptr.type();
    }

    override int emit(Generator output)
    {
        int reg = this.classptr.emit(output);
        RegExpr expr = new RegExpr(this.classptr.type(), reg);

        call(accessMember(expr, "__ctor", this.loc, false), this.args, this.loc).emit(output);
        return reg;
    }

    override void hash(Hash hash) {
        hash.adds("CallCtorExpression");
        classptr.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

class ASTNewExpression : ASTSymbol
{
    ASTType type;

    ASTSymbol[] args;

    Loc loc;

    this(ASTType type, ASTSymbol[] args, Loc loc) {
        this.type = type;
        this.args = args;
        this.loc = loc;
    }

    override Symbol compile(Context context)
    {
        Type type = this.type.compile(context);

        Class classType = type.instanceOf(Class);
        if (classType) {
            Expression classptr = new NewClassExpression(classType);

            auto argExpressions = new Expression[](this.args.length);
            for (int i = 0; i < this.args.length; i += 1)
                argExpressions[i] = beExpression(this.args[i].compile(context));
            this.loc.assert2s2(!!classType, "expected new <class>, not %s", type.repr());
            return new CallCtorExpression(classptr, argExpressions, this.loc);
        }
        Array arrayType = type.instanceOf(Array);
        if (arrayType) {
            this.loc.assert2s(this.args.length == 1, "expected one argument to loc");

            Type wordType = nativeWordType(context.platform);
            auto elementSize = new SizeOf(arrayType.elementType);
            // TODO only compute length once
            auto length = implicitConvertTo(beExpression(this.args[0].compile(context)), wordType, this.loc);
            auto byteLength = new BinaryOp("*", elementSize, length, this.loc);

            auto allocArgs = new Argument[](1);
            allocArgs[0] = Argument("", wordType);
            auto alloc = new FunctionDeclaration("cxruntime_alloc", new Pointer(new Void), allocArgs);

            auto allocParams = new Expression[](1);
            allocParams[0] = byteLength;
            PointerCast dataPtr = new PointerCast(
                new Pointer(arrayType.elementType),
                call(alloc, allocParams, this.loc));

            return new ArrayExpression(dataPtr, length);
        }
        this.loc.assert2s2(false, "don't know how to allocate ", type.repr());
    }
}

ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("*"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTDereference(next);
    }
    if (parser.accept("&"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTReference(next);
    }
    if (acceptIdentifier(parser, "new"))
    {
        ASTType type = parseType(parser, lexicalContext);
        if (!type) {
            parser.fail("type expected");
        }
        ASTSymbol[] args;
        if (parser.accept("("))
        {
            args = parseSymbolList(parser, lexicalContext);
        }

        return new ASTNewExpression(type, args, parser.loc());
    }
    if (parser.accept("!"))
    {
        ASTSymbol next = parseExpressionLeaf(parser, lexicalContext);

        assert(!!next);
        return new ASTNegation(next, parser.loc());
    }
    ASTSymbol currentExpr = parseExpressionBase(parser, lexicalContext);
    if (!currentExpr) return null;
    return parseProperties(parser, lexicalContext, currentExpr);
}

class ASTIdentifier : ASTSymbol
{
    string name;

    Loc loc;

    this(string name, Loc loc) { this.name = name; this.loc = loc; }

    override Symbol compile(Context context)
    {
        auto frame = new ReferenceExpression(new StackFrame(new Void));
        Symbol symbol = context.namespace.lookup(this.name, frame);
        this.loc.assert2s2(!!symbol, this.name, " not found");
        return symbol;
    }
}

class ASTIntLiteral : ASTSymbol
{
    int value;

    this(int value) { this.value = value; }

    override Symbol compile(Context context)
    {
        return new IntLiteral(this.value);
    }
}

class ASTFloatLiteral : ASTSymbol
{
    float value;

    this(float value) { this.value = value; }

    override Symbol compile(Context context)
    {
        return new FloatLiteral(this.value);
    }
}

class ASTStringLiteral : ASTSymbol
{
    string text;

    this(string text) { this.text = text; }

    override Symbol compile(Context context)
    {
        return new StringLiteral(this.text);
    }
}

string replaceEscapes(string text)
{
    string result;
    int i;
    while (i < text.length)
    {
        string ch = text[i .. i + 1];
        i += 1;
        if (ch == "\\")
        {
            string ctl = text[i .. i + 1];
            i += 1;
            if (ctl == "r") {
                result ~= "\r";
            } else if (ctl == "n") {
                result ~= "\n";
            } else if (ctl == "t") {
                result ~= "\t";
            } else if (ctl == "\"") {
                result ~= "\"";
            } else if (ctl == "\\") {
                result ~= "\\";
            } else {
                print("Unknown control sequence \\" ~ ctl);
                assert(false);
            }
        }
        else
        {
            result ~= ch;
        }
    }
    return result;
}

ASTStringLiteral parseStringLiteral(Parser parser, string endMarker)
{
    int matchLen;
    string start = parser.text();
    while (parser.text().length < endMarker.length || parser.text()[0 .. endMarker.length] != endMarker)
    {
        if (parser.text().length == 0)
        {
            parser.fail("expected end of string, got end of file");
        }
        if (parser.text()[0 .. 1] == "\\") {
            matchLen = matchLen + 1;
            parser.drop(1);
        }
        matchLen = matchLen + 1;
        parser.drop(1);
    }
    string str = start[0 .. matchLen];
    if (!parser.accept(endMarker))
    {
        parser.fail("this should never happen");
    }

    return new ASTStringLiteral(replaceEscapes(str));
}

ASTSymbol parseExpressionBase(Parser parser, LexicalContext lexicalContext)
{
    {
        auto args = new ParseExpressionBaseArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (args.symbol) return args.symbol;
    }
    string name = parseIdentifier(parser);
    if (name.length)
    {
        return new ASTIdentifier(name, parser.loc());
    }
    float f;
    if (parseFloat(parser, &f))
    {
        return new ASTFloatLiteral(f);
    }
    int i;
    if (parseNumber(parser, &i))
    {
        return new ASTIntLiteral(i);
    }
    if (parser.accept("\""))
    {
        return parseStringLiteral(parser, "\"");
    }
    if (parser.accept("("))
    {
        ASTSymbol result = parseExpression(parser, lexicalContext);

        parser.expect(")");
        return result;
    }
    return null;
    /*parser.fail("Base expression expected.");
    assert(false);*/
}

ASTSymbol parseBitAnd(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin();
        if (parser.accept("&") && !parser.accept("&"))
        {
            parser.commit();
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("&", left, right, parser.loc());
        }
        else
        {
            parser.revert();
            return left;
        }
    }
}

ASTSymbol parseBitOr(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        parser.begin();
        if (parser.accept("|") && !parser.accept("|"))
        {
            parser.commit();
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("|", left, right, parser.loc());
        }
        else
        {
            parser.revert();
            return left;
        }
    }
}

ASTSymbol parseAddSubCat(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        if (parser.accept("+"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("+", left, right, parser.loc());
        }
        else if (parser.accept("-"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("-", left, right, parser.loc());
        }
        else if (parser.accept("~"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("~", left, right, parser.loc());
        }
        else return left;
    }
}

ASTSymbol parseMulDiv(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        if (parser.accept("*"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("*", left, right, parser.loc());
        }
        else if (parser.accept("/"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("/", left, right, parser.loc());
        }
        else return left;
    }
}

ASTSymbol parseBoolAnd(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        if (parser.accept("&&"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("&&", left, right, parser.loc());
        } else return left;
    }
}

ASTSymbol parseBoolOr(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    while (true)
    {
        if (parser.accept("||"))
        {
            ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

            left = new ASTBinaryOp("||", left, right, parser.loc());
        } else return left;
    }
}

class ASTNegation : ASTSymbol
{
    ASTSymbol next;

    Loc loc;

    this(ASTSymbol next, Loc loc) { this.next = next; this.loc = loc; }

    override Expression compile(Context context)
    {
        Expression isTrue = truthy(beExpression(this.next.compile(context)), this.loc);

        return new BinaryOp("==", isTrue, new IntLiteral(0), this.loc);
    }
}

ASTSymbol parseComparison(Parser parser, LexicalContext lexicalContext, ASTSymbol left, int myLevel)
{
    if (parser.accept("=="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("==", left, right, parser.loc());
    }
    if (parser.accept("!=")) // same as !(a == b)
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTNegation(new ASTBinaryOp("==", left, right, parser.loc()), parser.loc());
    }
    if (parser.accept(">="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp(">=", left, right, parser.loc());
    }
    if (parser.accept(">"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp(">", left, right, parser.loc());
    }
    if (parser.accept("<="))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("<=", left, right, parser.loc());
    }
    if (parser.accept("<"))
    {
        ASTSymbol right = parseArithmetic(parser, lexicalContext, myLevel + 1);

        return new ASTBinaryOp("<", left, right, parser.loc());
    }
    return left;
}

ASTSymbol parseArithmetic(Parser parser, LexicalContext lexicalContext, int level)
{
    ASTSymbol left = parseExpressionLeaf(parser, lexicalContext);

    if (level <= 6) left = parseBitAnd(parser, lexicalContext, left, 6);
    if (level <= 5) left = parseBitOr(parser, lexicalContext, left, 5);
    if (level <= 4) left = parseMulDiv(parser, lexicalContext, left, 4);
    if (level <= 3) left = parseAddSubCat(parser, lexicalContext, left, 3);
    if (level <= 2) left = parseComparison(parser, lexicalContext, left, 2);
    if (level <= 1) left = parseBoolAnd(parser, lexicalContext, left, 1);
    if (level <= 0) left = parseBoolOr(parser, lexicalContext, left, 0);
    return left;
}

ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext)
{
    return parseArithmetic(parser, lexicalContext, 0);
}

class ASTReturnStatement : ASTStatement
{
    ASTSymbol value;

    Loc loc;

    this(ASTSymbol value, Loc loc) { this.value = value; this.loc = loc; }

    override StatementCompileResult compile(Context context)
    {
        Expression expr = beExpression(this.value.compile(context));
        Type ret = findFunctionScope(context.namespace).ret;
        expr = implicitConvertTo(expr, ret, this.loc);

        return StatementCompileResult(
            new ReturnStatement(expr),
            context);
    }
}

class ASTVoidExpression : ASTSymbol
{
    this() { }
    override Expression compile(Context context) { return new VoidExpression; }
}

class VoidExpression : Expression
{
    this() { }
    override Type type() { return new Void; }
    override int emit(Generator generator)
    {
        return generator.fun.voidLiteral();
    }
    override void hash(Hash hash) { hash.adds("VoidExpression"); }
}

ASTReturnStatement parseReturn(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    string identifier = parseIdentifier(parser);
    if (identifier != "return")
    {
        parser.revert();
        return null;
    }
    ASTSymbol expr;
    if (parser.accept(";")) // return;
    {
        expr = new ASTVoidExpression;
    }
    else
    {
        expr = parseExpression(parser, lexicalContext);
        parser.expect(";");
    }
    parser.commit();
    return new ASTReturnStatement(expr, parser.loc());
}

class StackFrame : Reference
{
    Type targetType;

    this(Type targetType) { this.targetType = targetType; }

    override Type type()
    {
        return this.targetType;
    }

    override int emit(Generator generator)
    {
        assert(false);
    }

    override int emitLocation(Generator generator)
    {
        return generator.frameReg;
    }

    override void hash(Hash hash) { hash.adds("StackFrame"); targetType.hash(hash); }
}

// variable without stackframe
class LatentVariable
{
    string name;

    Struct stackFrameType;

    int offset;

    this(string name, Struct stackFrameType, int offset)
    {
        this.name = name;
        this.stackFrameType = stackFrameType;
        this.offset = offset;
    }
}

class FunctionScope : Namespace
{
    Type ret;

    Type extra;

    StructMemberDeclaration[] variables;

    this(Type ret, Type extra, Namespace parent) {
        this.ret = ret;
        this.extra = extra;
        this.parent = parent;
    }

    LatentVariable declare(string name, Type type)
    {
        this.variables ~= new StructMemberDeclaration(name, type);
        // having cast sure would be nice...
        int len;
        while (len < this.variables.length) len = len + 1;

        return new LatentVariable(name, this.structType(), len - 1);
    }

    Struct structType()
    {
        return new Struct("", this.variables);
    }

    override Symbol lookup(string name, Expression frame)
    {
        assert(!!this.parent);

        Expression nextFrame;
        if (this.extra && frame)
        {
            // first field in stackframe must be parent
            // TODO better?
            auto framePtr = new PointerCast(new Pointer(new Pointer(new Void)), frame);

            nextFrame = new Dereference(framePtr);
        }

        return this.parent.lookup(name, nextFrame);
    }
}

FunctionScope findFunctionScope(Namespace namespace)
{
    FunctionScope functionScope = namespace.instanceOf(FunctionScope);
    if (functionScope) return functionScope;
    assert(!!namespace.parent);
    return findFunctionScope(namespace.parent);
}

class VariableDeclaration : Namespace
{
    LatentVariable variable;

    this(Namespace parent, string name, Type type)
    {
        this.parent = parent;
        this.variable = findFunctionScope(this).declare(name, type);
    }

    Reference accessLocal()
    {
        Expression frame = new ReferenceExpression(new StackFrame(variable.stackFrameType));
        return access(frame);
    }

    Reference access(Expression frame)
    {
        Type stackFrameType = variable.stackFrameType;
        frame = new PointerCast(new Pointer(stackFrameType), frame);
        return new StructMember(new Dereference(frame), variable.offset);
    }

    override Symbol lookup(string name, Expression frame)
    {
        if (this.variable.name == name)
        {
            return access(frame);
        }
        if (this.parent) return this.parent.lookup(name, frame);
        return null;
    }
}

class NestedFunctionDeclaration : Namespace
{
    Function nestedFunction;

    this(Namespace parent, Function fun)
    {
        // TODO collision check
        this.parent = parent;
        this.nestedFunction = fun;
    }

    override Symbol lookup(string name, Expression frame)
    {
        if (this.nestedFunction.name == name)
        {
            auto framePtr = new PointerCast(new Pointer(new Void), frame);

            return new ClassMethodPtr(new FunctionReference(this.nestedFunction), framePtr);
        }
        if (this.parent) return this.parent.lookup(name, frame);
        return null;
    }
}

class ASTIfStatement : ASTStatement
{
    ASTSymbol test;

    ASTStatement then;

    ASTStatement else_;

    Loc loc;

    this(ASTSymbol test, ASTStatement then, ASTStatement else_, Loc loc)
    {
        this.test = test;
        this.then = then;
        this.else_ = else_;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        Symbol test = this.test.compile(context);
        auto thenPair = this.then.compile(context);
        Statement then = thenPair.statement;
        Statement else_;
        if (this.else_) {
            auto elsePair = this.else_.compile(context);
            else_ = elsePair.statement;
        }

        return StatementCompileResult(
            new IfStatement(truthy(beExpression(test), this.loc), then, else_),
            context);
    }
}

ASTIfStatement parseIf(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    string identifier = parseIdentifier(parser);
    if (identifier != "if")
    {
        parser.revert();
        return null;
    }
    parser.expect("(");
    ASTSymbol expr = parseExpression(parser, lexicalContext);
    parser.expect(")");
    ASTStatement thenStmt = parseStatement(parser, lexicalContext);
    ASTStatement elseStatement;
    if (parser.accept("else"))
    {
        elseStatement = parseStatement(parser, lexicalContext);
    }
    parser.commit();
    return new ASTIfStatement(expr, thenStmt, elseStatement, parser.loc());
}

ASTStatement parseBreakCont(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    string identifier = parseIdentifier(parser);
    if (identifier == "break")
    {
        parser.expect(";");
        parser.commit();
        return new ASTBreakStatement(parser.loc());
    }
    if (identifier == "continue")
    {
        parser.expect(";");
        parser.commit();
        return new ASTContinueStatement(parser.loc());
    }
    parser.revert();
    return null;
}

class ASTScopeStatement : ASTStatement
{
    ASTStatement[] statements;

    this(ASTStatement[] statements) { this.statements = statements; }

    override StatementCompileResult compile(Context context)
    {
        auto statements = new Statement[](this.statements.length);
        auto subContext = context;
        for (int i = 0; i < this.statements.length; i += 1)
        {
            auto pair = this.statements[i].compile(subContext);

            subContext = pair.context;
            statements[i] = pair.statement;
        }
        return StatementCompileResult(
            new SequenceStatement(statements),
            context); // scope ends here
    }
}

ASTScopeStatement parseScope(Parser parser, LexicalContext lexicalContext)
{
    if (!parser.accept("{"))
    {
        return null;
    }
    ASTStatement[] statements;
    while (!parser.accept("}"))
    {
        ASTStatement stmt = parseStatement(parser, lexicalContext);

        statements ~= stmt;
    }
    return new ASTScopeStatement(statements);
}

ASTAssignStatement parseAssignment(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    ASTSymbol lhs = parseExpressionLeaf(parser, lexicalContext);
    if (!lhs) {
        parser.revert();
        return null;
    }
    auto loc = parser.loc();
    string operator;
    if (parser.accept("=")) { }
    else if (parser.accept("+=")) operator = "+";
    else if (parser.accept("-=")) operator = "-";
    else if (parser.accept("*=")) operator = "*";
    else if (parser.accept("/=")) operator = "/";
    else if (parser.accept("~=")) operator = "~";
    else {
        parser.revert();
        return null;
    }
    ASTSymbol expr = parseExpression(parser, lexicalContext);
    parser.commit();
    if (operator.length) {
        // TODO separate AST construct - avoid double compiling lhs?
        expr = new ASTBinaryOp(operator, lhs, expr, loc);
    }
    return new ASTAssignStatement(lhs, expr, parser.loc());
}

ASTAssignStatement parseAssignStatement(Parser parser, LexicalContext lexicalContext)
{
    ASTAssignStatement ret = parseAssignment(parser, lexicalContext);
    if (ret)
    {
        parser.expect(";");
        return ret;
    }
    return null;
}

class ASTVarDeclStatement : ASTStatement
{
    string name;

    bool infer;

    ASTType type;

    ASTSymbol initial;

    Loc loc;

    this(string name, bool infer, ASTType type, ASTSymbol initial, Loc loc)
    {
        assert(infer == !type);
        assert(!infer || initial);

        this.name = name;
        this.infer = infer;
        this.type = type;
        this.initial = initial;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        Type type;
        if (this.type) type = this.type.compile(context);
        if (this.initial)
        {
            auto initial = beExpression2(this.initial.compile(context), this.loc);
            if (this.infer) {
                assert(!type);
                type = initial.type();
            } else {
                assert(!!type);
                initial = implicitConvertTo(initial, type, this.loc);
            }

            auto decl = new VariableDeclaration(context.namespace, this.name, type);

            return StatementCompileResult(
                new AssignStatement(decl.accessLocal(), initial, this.loc),
                context.withNamespace(decl));
        }
        else
        {
            auto decl = new VariableDeclaration(context.namespace, this.name, type);

            return StatementCompileResult(
                new AssignStatement(decl.accessLocal(), new NullExpr(type), this.loc),
                context.withNamespace(decl));
        }
    }
}

ASTVarDeclStatement parseVarDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    bool infer = false;
    ASTType type;
    if (acceptIdentifier(parser, "auto")) {
        infer = true;
    } else {
        type = parseType(parser, lexicalContext);
        if (!type)
        {
            parser.revert();
            return null;
        }
    }
    ASTSymbol initial;
    string name;
    if (infer && parser.accept("="))
    {
        initial = parseExpression(parser, lexicalContext);
        assert(!!initial);
    }
    else
    {
        name = parseIdentifier(parser);
        if (!name.length)
        {
            parser.revert();
            return null;
        }
        if (infer) {
            parser.expect("=");
            initial = parseExpression(parser, lexicalContext);
            assert(!!initial);
        }
        else if (parser.accept("=")) {
            initial = parseExpression(parser, lexicalContext);
            assert(!!initial);
        }
    }
    parser.expect(";");
    parser.commit();
    return new ASTVarDeclStatement(name, infer, type, initial, parser.loc());
}

class ASTNestedFunctionDeclStatement : ASTStatement
{
    ASTFunction fun;

    this(ASTFunction fun)
    {
        this.fun = fun;
    }

    override StatementCompileResult compile(Context context)
    {
        auto module_ = findModule(context.namespace);
        auto fun_ = this.fun.compile(context).instanceOf(Function);
        auto structType = findFunctionScope(context.namespace).structType();
        auto voidp = new Pointer(new Void);

        fun_.thisType = new Pointer(structType);
        fun_.parent = context.namespace;

        auto namespace = new NestedFunctionDeclaration(context.namespace, fun_);

        module_.add("", fun_);
        return StatementCompileResult(
            new NoopStatement,
            context.withNamespace(namespace));
    }
}

ASTNestedFunctionDeclStatement parseNestedFunctionDecl(Parser parser, LexicalContext lexicalContext)
{
    auto fun_ = parseFunction(parser, lexicalContext);
    if (!fun_) return null;
    return new ASTNestedFunctionDeclStatement(fun_);
}

class ASTWhile : ASTStatement
{
    ASTSymbol cond;

    ASTStatement body_;

    Loc loc;

    this(ASTSymbol cond, ASTStatement body_, Loc loc) {
        this.cond = cond;
        this.body_ = body_;
        this.loc = loc;
    }

    override StatementCompileResult compile(Context context)
    {
        auto label = context.getLabel();
        auto loopContext = context.withDeclScope(new LoopScopeImpl(label, context.scope_));
        auto condExpr = truthy(beExpression(this.cond.compile(loopContext)), this.loc);
        auto bodyPair = this.body_.compile(loopContext);

        return StatementCompileResult(
            new Loop(label, null, condExpr, bodyPair.statement, null),
            context);
    }
}

ASTWhile parseWhile(Parser parser, LexicalContext lexicalContext)
{
    if (!acceptIdentifier(parser, "while"))
    {
        return null;
    }
    parser.expect("(");
    ASTSymbol cond = parseExpression(parser, lexicalContext);
    parser.expect(")");
    ASTStatement body_ = parseStatement(parser, lexicalContext);

    return new ASTWhile(cond, body_, parser.loc());
}

ASTExprStatement parseExprStatement(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    ASTSymbol value = parseExpression(parser, lexicalContext);
    if (!value)
    {
        parser.revert();
        return null;
    }
    parser.expect(";");
    parser.commit();
    return new ASTExprStatement(value);
}

class ASTForLoop : ASTStatement
{
    ASTVarDeclStatement declareLoopVar;

    ASTSymbol condition;

    ASTStatement step;

    ASTStatement body_;

    this(ASTVarDeclStatement declareLoopVar, ASTSymbol condition, ASTStatement step, ASTStatement body_)
    {
        this.declareLoopVar = declareLoopVar;
        this.condition = condition;
        this.step = step;
        this.body_ = body_;
    }

    override StatementCompileResult compile(Context context)
    {
        auto declPair = this.declareLoopVar.compile(context);
        auto forScope = declPair.context;
        Expression condition = beExpression(this.condition.compile(forScope));
        auto stepPair = this.step.compile(forScope);

        string label = context.getLabel();
        DeclarationScope declScope = new LoopScopeImpl(label, context.scope_);
        Context breakContScope = forScope.withDeclScope(declScope);
        auto bodyPair = this.body_.compile(breakContScope);

        return StatementCompileResult(
            new Loop(label, declPair.statement, condition, bodyPair.statement, stepPair.statement),
            context);
    }
}

ASTForLoop parseFor(Parser parser, LexicalContext lexicalContext)
{
    if (!acceptIdentifier(parser, "for"))
    {
        return null;
    }
    parser.expect("(");
    ASTVarDeclStatement varDecl = parseVarDecl(parser, lexicalContext);
    if (!varDecl) {
        parser.fail("loop declaration expected");
    }
    ASTSymbol condition = parseExpression(parser, lexicalContext);
    parser.expect(";");
    ASTStatement step = parseAssignment(parser, lexicalContext);
    parser.expect(")");
    ASTStatement body_ = parseStatement(parser, lexicalContext);

    return new ASTForLoop(varDecl, condition, step, body_);
}

class ParseStatementArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTStatement statement; // out
    this(Parser parser, LexicalContext lexicalContext) {
        this.parser = parser;
        this.lexicalContext = lexicalContext;
        this.statement = null;
    }
    override bool done() { return !!this.statement; }
}

ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext)
{
    {
        ASTStatement stmt = parseReturn(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseIf(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseBreakCont(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseWhile(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseFor(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseScope(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseNestedFunctionDecl(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseVarDecl(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseAssignStatement(parser, lexicalContext);
        if (stmt) return stmt;
    }
    {
        auto args = new ParseStatementArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(args);
        if (args.statement) return args.statement;
    }
    {
        ASTStatement stmt = parseExprStatement(parser, lexicalContext);
        if (stmt) return stmt;
    }
    parser.fail("statement expected");
}

ASTFunction parseFunction(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    ASTType ret = parseType(parser, lexicalContext);
    if (!ret)
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    if (!name.length || !parser.accept("("))
    {
        parser.revert();
        return null;
    }
    parser.commit();
    ASTArgument[] args = parseIdentifierList(parser, lexicalContext);
    ASTStatement stmt = parseStatement(parser, lexicalContext);
    return new ASTFunction(parser.loc(), name, ret, args, false, stmt, lexicalContext.macroState);
}

class ModuleEntry
{
    string name;

    Symbol value;

    this(string name, Symbol value) { this.name = name; this.value = value; }
}

class ASTModule
{
    string name;

    Package pak;

    MacroState macroState;

    // separated from this module with a divergent macro state
    // because we hit a macro declaration
    ASTModule parent;

    ASTModuleEntry[] entries;

    this(string name, Package pak, MacroState macroState, ASTModule parent)
    {
        this.name = name;
        this.pak = pak;
        this.macroState = macroState;
        this.parent = parent;
    }

    void addTypeAlias(string name, ASTType type)
    {
        auto alias_ = new ASTTypeAlias(name, type);

        this.entries ~= ASTModuleEntry(null, null, null, null, null, alias_, null);
    }

    void addExprAlias(string name, ASTSymbol symbol)
    {
        auto alias_ = new ASTSymbolAlias(name, symbol);

        this.entries ~= ASTModuleEntry(null, null, null, null, null, null, alias_);
    }
}

class Module : Namespace
{
    string name;

    string mangledName;

    Package pak;

    MacroState macroState;

    // whenever macro state changes, we begin a new submodule
    // when this happens, this member references the previous module.
    Module parentModule;

    this(string name, Package pak, MacroState macroState, Module parentModule)
    {
        assert(!!pak);
        this.parentModule = parentModule;
        this.name = name;
        this.pak = pak;
        this.macroState = macroState;
        for (int i = 0; i < this.name.length; i += 1) {
            if (name[i .. i + 1] == ".") this.mangledName ~= "_";
            else this.mangledName ~= name[i .. i + 1];
        }
        this.mangledName = this.pak.name ~ "_module_" ~ this.mangledName;
    }

    Module[] imports;

    ModuleEntry[] entries;

    void add(string name, Symbol symbol)
    {
        this.entries ~= new ModuleEntry(name, symbol);
    }

    void addImport(Module module_)
    {
        assert(!!module_);
        this.imports ~= module_;
    }

    override string mangle() { return this.mangledName; }

    void resolve()
    {
        for (int i = 0; i < this.entries.length; i += 1) {
            Class class_ = this.entries[i].value.instanceOf(Class);
            if (class_) class_.resolve();
        }
    }

    Module[] allModules()
    {
        Module[] result;
        if (this.parentModule)
            result = this.parentModule.allModules();
        result ~= this;
        for (int i = 0; i < imports.length; i += 1) {
            auto subModules = imports[i].allModules();
            for (int k = 0; k < subModules.length; k += 1) {
                bool found;
                for (int l = 0; l < result.length; l += 1) {
                    if (result[l].mangledName == subModules[k].mangledName) {
                        found = true;
                        break;
                    }
                }
                if (!found) result ~= subModules[k];
            }
        }
        return result;
    }

    FinishedSymbol[] compile(Platform platform)
    {
        FinishedSymbol[] symbols;

        for (int i = 0; i < this.entries.length; i += 1) {
            ModuleEntry entry = this.entries[i];
            Function fun = entry.value.instanceOf(Function);
            if (fun)
            {
                FinishedSymbol funSymbol = fun.compile(platform);
                symbols ~= funSymbol; // TODO implcast
            }
            Class class_ = entry.value.instanceOf(Class);
            if (class_) {
                FinishedSymbol defineClass = new DefineClass(class_); // TODO implcast
                symbols ~= defineClass;
                // class_.define(generator);
                for (int k = 0; k < class_.methods.length; k += 1) {
                    // TODO implcast
                    FinishedSymbol method = class_.methods[k].compile(platform);
                    symbols ~= method;
                }
            }
            Struct struct_ = entry.value.instanceOf(Struct);
            if (struct_) {
                for (int i = 0; i < struct_.methods.length; i += 1) {
                    // TODO implcast
                    FinishedSymbol method = struct_.methods[i].instanceOf(StructMethod).compile(platform);
                    symbols ~= method;
                }
            }
        }
        return symbols;
    }

    void emit(Generator generator, FinishedSymbol[] symbols)
    {
        if (!generator.once(mangle()))
            return;

        assert(!generator.fun);

        for (int i = 0; i < symbols.length; i += 1)
            symbols[i].emit(generator);
    }

    Symbol lookupPublic(string name)
    {
        // not counting imports (non-transitive)
        for (int i = 0; i < this.entries.length; i += 1)
        {
            if (this.entries[i].name == name)
                return this.entries[i].value;
        }
        return null;
    }

    override Symbol lookup(string name, Expression frame)
    {
        assert(!frame);

        Symbol public_ = this.lookupPublic(name);
        if (public_) return public_;
        for (int i = 0; i < this.imports.length; i += 1)
        {
            assert(!!this.imports[i]);
            Symbol entry = this.imports[i].lookupPublic(name);
            if (entry) return entry;
        }
        if (this.parent)
            return this.parent.lookup(name, frame);
        return null;
    }
}

abstract class ParserHelper
{
    abstract void proxyCall(ASTModule astModule, string function_, MacroState macroState, ModuleParserConfig config)
    {
        assert(false);
    }
}

Module findModule(Namespace namespace)
{
    Module module_ = namespace.instanceOf(Module);
    if (module_) return module_;
    assert(!!namespace.parent);
    return findModule(namespace.parent);
}

class NullExpr : Expression
{
    Type type_;

    this(Type type_) { this.type_ = type_; }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator generator)
    {
        // TODO allocaless
        // exploit that alloca are zero initialized
        BackendType type = this.type_.emit(generator.platform);
        auto stack = generator.fun.saveStack();
        int reg = generator.fun.alloca(type);

        auto res = generator.fun.load(type, reg);
        generator.fun.restoreStack(stack);
        return res;
    }

    override void hash(Hash hash) { hash.adds("NullExpr"); type_.hash(hash); }
}

class ASTExtern
{
    string name;

    ASTType ret;

    ASTArgument[] args;

    this(string name, ASTType ret, ASTArgument[] args)
    {
        this.name = name;
        this.ret = ret;
        this.args = args;
    }

    FunctionDeclaration compile(Context context)
    {
        auto args = new Argument[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1)
            args[i] = Argument(this.args[i].name, this.args[i].type.compile(context));

        return new FunctionDeclaration(this.name, this.ret.compile(context), args);
    }
}

ASTExtern parseExtern(Parser parser, LexicalContext lexicalContext)
{
    if (parser.accept("extern"))
    {
        parser.expect("(");
        parser.expect("C");
        parser.expect(")");
        ASTType ret = parseType(parser, lexicalContext);
        string name = parseIdentifier(parser);
        if (!name.length) parser.fail("identifier expected");
        parser.expect("(");
        ASTArgument[] args = parseIdentifierList(parser, lexicalContext);
        parser.expect(";");
        return new ASTExtern(name, ret, args);
    }
    return null;
}

string moduleToFile(string module_)
{
    string modulePath;
    for (int i = 0; i < module_.length; i += 1) {
        if (module_[i .. i + 1] == ".") modulePath ~= "/";
        else modulePath ~= module_[i .. i + 1];
    }
    return modulePath ~ ".cx";
}

string findFileInPackage(string filename, Package pak, Loc loc, Package* foundPak)
{
    string fileInPackage = pak.path ~ "/" ~ filename;
    if (cxruntime_file_exists(fileInPackage)) {
        *foundPak = pak;
        return fileInPackage;
    }
    for (int i = 0; i < pak.deps.length; i += 1) {
        auto dep = pak.deps[i];
        string fileInDep = dep.path ~ "/" ~ filename;

        if (cxruntime_file_exists(fileInDep)) {
            *foundPak = dep;
            return fileInDep;
        }
    }
    loc.assert2s(false, "cannot find file '" ~ filename ~ "' in package '" ~ pak.name ~ "' or dependencies");
}

// TODO rewrite this once we have a std.path
string findResidualFilename(string filename, Package[] packages, Package* foundPackage)
{
    // TODO split then check
    assert(cxruntime_file_exists(filename));
    for (int i = 0; i < packages.length; i += 1) {
        string path = packages[i].path;
        if (filename.length >= path.length
            && filename[0 .. path.length] == path) {
            *foundPackage = packages[i];
            return filename[path.length + 1 .. filename.length];
        }
    }
    // TODO handle "../" paths
    for (int i = 0; i < packages.length; i += 1) {
        if (packages[i].path == ".") {
            *foundPackage = packages[i];
            return filename;
        }
    }
    print("file '" ~ filename ~ "' is not in folder of any package");
    assert(false);
}

class ASTImport
{
    string name;

    string pak;

    bool isMacroImport;

    Loc loc;

    this(string name, string pak, bool isMacroImport, Loc loc)
    {
        this.name = name;
        this.pak = pak;
        this.isMacroImport = isMacroImport;
        this.loc = loc;
    }
}

ASTImport parseImport(Parser parser)
{
    parser.begin();
    bool isMacroImport = acceptIdentifier(parser, "macro");
    if (!acceptIdentifier(parser, "import"))
    {
        parser.revert();
        return null;
    }
    string pak;
    if (acceptIdentifier(parser, "package"))
    {
        parser.expect("(");
        pak = parseIdentifier(parser);
        parser.expect(")");
        parser.expect(".");
    }

    parser.commit();
    string modname = parseIdentifier2(parser, ".");
    parser.expect(";");
    return new ASTImport(modname, pak, isMacroImport, parser.loc());
}

class ClassMember
{
    string name;

    Type type;

    this(string name, Type type) { this.name = name; this.type = type; }
}

class ClassMethod : Function
{
    Loc loc;

    bool override_;

    bool abstract_;

    this(Loc loc, Class classType, bool override_, bool abstract_, string name, Type ret, Argument[] args,
         ASTStatement statement, Statement compiledStatement, MacroState macroState)
    {
        // TODO super()
        this.name = name;
        this.ret = ret;
        this.args = args;
        this.statement = statement;
        this.compiledStatement = compiledStatement;
        this.macroState = macroState;

        auto classNamespace = new ClassNamespace(classType.context.namespace, classType);

        this.loc = loc;
        this.thisType = classType;
        this.parent = classNamespace;
        this.override_ = override_;
        this.abstract_ = abstract_;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.parent.mangle() ~ "_" ~ this.thisType.instanceOf(Class).name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto argTypes = new Type[](this.args.length + 1);
        argTypes[0] = this.thisType;
        for (int i = 0; i < this.args.length; i += 1) argTypes[i + 1] = this.args[i].type;
        return new FunctionPointer(this.ret, argTypes);
    }
}

// TODO .truthy
Expression truthy_(Expression value, Loc loc)
{
    return truthy(value, loc);
}

class ClassNamespace : Namespace
{
    Class class_;

    this(Namespace parent, Class class_)
    {
        this.parent = parent;
        this.class_ = class_;
    }

    override Symbol lookup(string name, Expression thisPtr)
    {
        thisPtr = new PointerCast(this.class_, thisPtr);

        auto result = accessMember(thisPtr, name, Loc(null, ""), true);

        if (result) return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, null);
    }
}

class Class : Type
{
    string name;

    bool abstract_; // may contain abstract methods

    Class superClass;

    // will resolve members and methods as required
    ASTClassDecl decl;

    // used for resolving
    Context context;

    ClassMember[] members;

    ClassMethod[] methods;

    ClassMethod[] vtable_; // methods appearing in the classinfo struct

    string vtableSymbol;

    this(ASTClassDecl decl, Class superClass, Context context)
    {
        assert(!!decl);
        this.name = decl.name;
        this.abstract_ = decl.abstract_;
        this.superClass = superClass;
        this.decl = decl;
        this.context = context;
    }

    string mangle() {
        return context.namespace.mangle() ~ "_class_" ~ this.name;
    }

    override Expression truthy(Expression value, Loc loc)
    {
        Type voidp = new Pointer(new Void);
        return truthy_(new PointerCast(voidp, value), loc);
    }

    override Expression implicitConvertFrom(Expression from)
    {
        // upcast
        if (from.type().instanceOf(Class))
        {
            Class currentClass = from.type().instanceOf(Class);

            while (currentClass)
            {
                if (currentClass.same(this))
                {
                    return new PointerCast(this, from);
                }
                currentClass = currentClass.superClass;
            }
        }
        // = null
        if (from.instanceOf(NullExpr))
        {
            return new PointerCast(this, from);
        }
        return null;
    }

    override Expression implicitConvertTo(Expression from, Type to)
    {
        // (void*) class
        auto voidp = new Pointer(new Void);

        if (to.same(voidp))
        {
            return new PointerCast(voidp, from);
        }
        return null;
    }

    void resolve()
    {
        // TODO per-backend info?
        if (this.vtableSymbol.length > 0) return;
        this.decl.compile2(this.context, this);
        this.decl = null;
    }

    override BackendType emit(Platform platform)
    {
        return new BackendPointerType(new BackendVoidType);
    }

    ClassMember[] allMembers()
    {
        if (!this.superClass)
        {
            auto members = new ClassMember[](this.members.length + 1);
            members[0] = new ClassMember("__classinfo", new Pointer(new Void));
            for (int i = 0; i < this.members.length; i += 1)
                members[i + 1] = this.members[i];
            return members;
        }
        ClassMember[] members = this.superClass.allMembers();
        for (int i = 0; i < this.members.length; i += 1)
            members ~= this.members[i];
        return members;
    }

    Struct dataStruct()
    {
        ClassMember[] allMembers = this.allMembers();

        auto structMembers = new StructMemberDeclaration[](allMembers.length);
        for (int i = 0; i < allMembers.length; i += 1)
            structMembers[i] = new StructMemberDeclaration(allMembers[i].name, allMembers[i].type);

        return new Struct("", structMembers);
    }

    Struct classInfoStruct()
    {
        ClassMethod[] vtable = this.vtable();

        auto vtableMembers = new StructMemberDeclaration[](vtable.length);
        for (int i = 0; i < vtable.length; i += 1)
            vtableMembers[i] = new StructMemberDeclaration(vtable[i].name, vtable[i].funcPtrType());

        return new Struct("", vtableMembers);
    }

    ClassMethod[] vtable()
    {
        auto copy = new ClassMethod[](this.vtable_.length);
        for (int i = 0; i < this.vtable_.length; i += 1)
            copy[i] = this.vtable_[i];
        return copy;
    }

    void genVtable()
    {
        if (this.vtableSymbol.length > 0) return;

        assert(this.vtable_.length == 0);

        ClassMethod[] combinedMethods;
        if (this.superClass) {
            this.superClass.genVtable();
            combinedMethods = this.superClass.vtable();
        }

        this.genInstanceofMethod();

        for (int i = 0; i < this.methods.length; i += 1) {
            ClassMethod method = this.methods[i];

            // TODO match types
            int index = -1;
            for (int i = 0; i < combinedMethods.length; i += 1)
            {
                if (combinedMethods[i].name == method.name) index = i;
            }
            bool isCtor = method.name == "__ctor"; // workaround: no final yet, no proper masking yet
            if (index != -1)
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(method.override_ || isCtor,
                        "Expected 'override' attribute for overriding method.");
                // override
                combinedMethods[index] = method;
            }
            else
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(!method.override_,
                        "'override specified but method does not override a parent method.");
                combinedMethods ~= method;
            }
        }
        if (!this.abstract_)
        {
            for (int i = 0; i < combinedMethods.length; i += 1) {
                auto method = combinedMethods[i];
                if (method.abstract_)
                    this.decl.loc.fail("Abstract method not overridden in non-abstract class " ~ this.name);
            }
        }
        this.vtable_ = combinedMethods;
        this.vtableSymbol = this.mangle() ~ "_vtable";
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(vtableSymbol))
            return;

        generator.mod.declareSymbolList(vtableSymbol, vtable_.length);
    }

    void define(Generator generator)
    {
        auto methods = new string[](vtable_.length);
        for (int i = 0; i < vtable_.length; i += 1)
        {
            vtable_[i].declare(generator);
            methods[i] = vtable_[i].mangle();
        }
        generator.mod.defineSymbolList(vtableSymbol, methods);
    }

    void genInstanceofMethod()
    {
        Type voidp = new Pointer(new Void);
        Array stringType = new Array(new Character);

        Statement[] castStmts;
        ArgExpr thisptr = new ArgExpr(0, voidp);
        ArgExpr target = new ArgExpr(1, stringType);
        auto nullptr = new NullExpr(voidp);
        Class current = this;
        while (current)
        {
            auto test = new ArrayEqual(target, new StringLiteral(current.name));
            Statement cmp = new IfStatement(test, new ReturnStatement(thisptr), null);

            castStmts ~= cmp;
            current = current.superClass;
        }
        Statement ret = new ReturnStatement(nullptr);
        castStmts ~= ret;

        auto stmt = new SequenceStatement(castStmts);

        bool override_ = false;
        if (this.superClass) override_ = true;

        this.methods ~= new ClassMethod(
            Loc(null, ""), this, override_, false /* abstract */, "__instanceof",
            voidp, new Argument[](0) ~ Argument("target", stringType), null, stmt, null);
    }

    override bool same(Type other) {
        Class otherClass = other.instanceOf(Class);

        return otherClass && otherClass.name == this.name; // TODO module
    }

    override string repr() { return this.name; }

    override void hash(Hash hash) {
        hash.adds("Class");
        hash.adds(mangle());
        // does there to be more here? I think not; Class is not being emitted as a distinct symbol
    }
}

class ClassScope : Namespace
{
    Class class_;

    this(Namespace parent, Class class_)
    {
        this.parent = parent;
        this.class_ = class_;
    }

    override Symbol lookup(string name, Expression frame)
    {
        if (name == this.class_.name)
        {
            return this.class_;
        }
        return this.parent.lookup(name, frame);
    }
}

struct ASTClassDeclMember
{
    string name;

    ASTType type;
}

struct ASTClassDeclMethod
{
    Loc loc;

    bool override_;

    bool abstract_;

    string name;

    ASTType ret;

    ASTArgument[] args;

    ASTStatement body_;
}

class ASTClassDecl : ASTType
{
    string name;

    string superClass;

    bool abstract_;

    ASTClassDeclMember[] members;

    ASTClassDeclMethod[] methods;

    MacroState macroState;

    Loc loc;

    this(string name, string superClass, bool abstract_, ASTClassDeclMember[] members, ASTClassDeclMethod[] methods,
         MacroState macroState, Loc loc)
    {
        this.name = name;
        this.superClass = superClass;
        this.abstract_ = abstract_;
        this.members = members;
        this.methods = methods;
        this.macroState = macroState;
        this.loc = loc;
    }

    override Class compile(Context context)
    {
        Class superClass = null;
        if (this.superClass.length)
        {
            Symbol superClassObj = context.namespace.lookup(this.superClass, null);
            if (!superClassObj) print("super class not found: " ~ this.superClass);
            assert(!!superClassObj); // , format!"super class %s not found"(this.superClass));
            superClass = superClassObj.instanceOf(Class);
            assert(!!superClass);
        }
        return new Class(this, superClass, context);
    }

    void compile2(Context context, Class target)
    {
        auto classScope = new ClassScope(context.namespace, target);
        Context classContext = context.withNamespace(classScope);

        target.members = new ClassMember[](this.members.length);
        for (int i = 0; i < this.members.length; i += 1)
            target.members[i] = new ClassMember(this.members[i].name, this.members[i].type.compile(classContext));

        target.methods = new ClassMethod[](this.methods.length);
        for (int i = 0; i < this.methods.length; i += 1)
        {
            ASTClassDeclMethod method = this.methods[i];

            auto methodArgs = new Argument[](method.args.length);
            for (int k = 0; k < method.args.length; k = k + 1)
                methodArgs[k] = Argument(method.args[k].name, method.args[k].type.compile(classContext));

            target.methods[i] = new ClassMethod(
                method.loc,
                target,
                method.override_,
                method.abstract_,
                method.name,
                method.ret.compile(classContext),
                methodArgs,
                method.body_, null, this.macroState);
        }
        target.genVtable();
    }
}

ASTArgument[] parseArglist(Parser parser, LexicalContext lexicalContext)
{
    ASTArgument[] args;
    while (!parser.accept(")"))
    {
        if (args.length > 0)
        {
            if (!parser.accept(","))
            {
                parser.fail("',' or ')' expected");
            }
        }
        ASTType argtype = parseType(parser, lexicalContext);
        parser.assert_(!!argtype, "argument type expected");
        string argname = parseIdentifier(parser);
        parser.assert_(argname.length > 0, "argument name expected");
        args ~= ASTArgument(argname, argtype);
    }
    return args;
}

ASTClassDecl parseClassDecl(Parser parser, LexicalContext lexicalContext)
{
    bool classAbstract = false;
    auto loc = parser.loc();
    parser.begin();
    if (acceptIdentifier(parser, "abstract"))
        classAbstract = true;
    if (!acceptIdentifier(parser, "class"))
    {
        parser.revert();
        return null;
    }
    parser.commit();

    string name = parseIdentifier(parser);
    string superClass;
    if (parser.accept(":")) {
        superClass = parseIdentifier(parser);
        parser.assert_(superClass.length > 0, "expected super class identifier");
    }
    ASTClassDeclMember[] members;
    ASTClassDeclMethod[] methods;
    parser.expect("{");
    while (!parser.accept("}"))
    {
        parser.strip();

        Loc methodLoc = parser.loc();

        ASTType retType;
        string memberName;
        bool override_ = false;
        bool abstract_ = false;
        while (true) {
            if (acceptIdentifier(parser, "override")) {
                override_ = true;
                continue;
            }
            if (acceptIdentifier(parser, "abstract")) {
                abstract_ = true;
                continue;
            }
            break;
        }

        if (parser.accept("this"))
        {
            parser.assert_(!override_, "cannot override constructor");
            retType = new ASTVoid;
            memberName = "__ctor";
        }
        else
        {
            retType = parseType(parser, lexicalContext);
            parser.assert_(!!retType, "expected member type");
            memberName = parseIdentifier(parser);
            parser.assert_(memberName.length > 0, "expected member name");
        }
        if (parser.accept("(")) // method
        {
            ASTArgument[] args = parseArglist(parser, lexicalContext);
            ASTStatement stmt = parseStatement(parser, lexicalContext);
            methods ~= ASTClassDeclMethod(
                parser.loc(), override_, abstract_, memberName, retType, args, stmt);
        }
        else
        {
            parser.assert_(!override_, "cannot override class member");
            parser.assert_(!abstract_, "cannot declare class member abstract");
            parser.expect(";");
            members ~= ASTClassDeclMember(memberName, retType);
        }
    }
    return new ASTClassDecl(name, superClass, classAbstract, members, methods, lexicalContext.macroState, loc);
}

class ASTModuleCacheEntry
{
    string path;
    ASTModule mod;
    this(string path, ASTModule mod) { this.path = path; this.mod = mod; }
}

class ASTModuleCache
{
    ASTModuleCacheEntry[] modules;
    this() { }
    ASTModule find(string path) {
        for (int i = 0; i < this.modules.length; i += 1)
            if (this.modules[i].path == path) return this.modules[i].mod;
        return null;
    }
    void add(string path, ASTModule mod) {
        this.modules ~= new ASTModuleCacheEntry(path, mod);
    }
}

class ModuleCacheEntry
{
    string key;
    Module mod;
    this(string key, Module mod) {
        this.key = key;
        this.mod = mod;
    }
}

class ModuleCache
{
    ModuleCacheEntry[] modules;
    this() { }
    string key(ASTModule mod, Platform platform) {
        // TODO platform.key()
        return nativeWordType(platform).repr() ~ "_" ~ mod.pak.name ~ "_" ~ mod.name;
    }
    Module find(ASTModule mod, Platform platform) {
        string key = this.key(mod, platform);
        for (int i = 0; i < this.modules.length; i += 1)
            if (this.modules[i].key == key) return this.modules[i].mod;
        return null;
    }
    void add(ASTModule astModule, Platform platform, Module module_) {
        this.modules ~= new ModuleCacheEntry(this.key(astModule, platform), module_);
    }
}

class ModuleParserConfig
{
    Package[] packages;

    ASTModule[] defaultImports;

    ASTModuleCache astCache;

    ModuleCache cache;

    this(Package[] packages, ASTModule[] defaultImports, ASTModuleCache astCache, ModuleCache cache)
    {
        this.packages = packages;
        this.defaultImports = defaultImports;
        this.astCache = astCache;
        this.cache = cache;
    }
}

ASTModule parseMacroContinuation(Parser parser, ParserHelper helper, ASTModule astModule, ModuleParserConfig config)
{
    parser.begin();
    if (!acceptIdentifier(parser, "macro") || !parser.accept("("))
    {
        parser.revert();
        return null;
    }
    parser.commit();
    string identifier = parseIdentifier(parser);
    parser.expect(")");
    parser.expect(";");

    auto newMacroState = astModule.macroState.dup();

    helper.proxyCall(astModule, identifier, newMacroState, config);

    auto subModule = new ASTModule(astModule.name, astModule.pak, newMacroState, astModule);

    return parseModuleBody(parser, helper, subModule, config);
}

struct ASTStructMember
{
    string name;

    ASTType type;
}

struct ASTStructMethod
{
    Loc loc;

    string name;

    ASTType ret;

    ASTArgument[] args;

    ASTStatement body_;
}

class StructNamespace : Namespace
{
    Struct struct_;

    this(Namespace parent, Struct struct_)
    {
        this.parent = parent;
        this.struct_ = struct_;
    }

    override Symbol lookup(string name, Expression thisPtr)
    {
        thisPtr = new PointerCast(new Pointer(this.struct_), thisPtr);

        auto result = accessMember(thisPtr, name, Loc(null, ""), true);

        if (result) return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, null);
    }
}

class StructMethod : Function
{
    Loc loc;

    this(Loc loc, Struct structType, Context context, string name, Type ret, Argument[] args, ASTStatement statement,
         Statement compiledStatement, MacroState macroState)
    {
        // TODO super()
        this.name = name;
        this.ret = ret;
        this.args = args;
        this.statement = statement;
        this.compiledStatement = compiledStatement;
        this.macroState = macroState;

        auto structNamespace = new StructNamespace(context.namespace, structType);

        this.loc = loc;
        this.thisType = new Pointer(structType);
        this.parent = structNamespace;
    }

    override string mangle()
    {
        auto ptr = this.thisType.instanceOf(Pointer);
        // TODO mangle types
        return this.parent.mangle() ~ "_" ~ ptr.target.instanceOf(Struct).name ~ "_" ~ this.name;
    }
}

// TODO merge with ClassScope into AliasScope
class StructScope : Namespace
{
    Struct struct_;

    this(Namespace parent, Struct struct_)
    {
        this.parent = parent;
        this.struct_ = struct_;
    }

    override Symbol lookup(string name, Expression frame)
    {
        if (name == this.struct_.name)
        {
            return this.struct_;
        }
        return this.parent.lookup(name, frame);
    }
}

class ASTStructDecl : ASTType
{
    string name;

    ASTStructMember[] members;

    ASTStructMethod[] methods;

    MacroState macroState;

    this(string name, ASTStructMember[] members, ASTStructMethod[] methods, MacroState macroState)
    {
        this.name = name;
        this.members = members;
        this.methods = methods;
        this.macroState = macroState;
    }

    override Struct compile(Context context)
    {
        auto members = new StructMemberDeclaration[](this.members.length);

        for (int i = 0; i < this.members.length; i += 1)
            members[i] = new StructMemberDeclaration(this.members[i].name, this.members[i].type.compile(context));

        auto struct_ = new Struct(this.name, members);
        auto structScope = new StructScope(context.namespace, struct_); // make S visibile in struct S {}
        auto structContext = context.withNamespace(structScope);

        struct_.methods = new FunctionDeclaration[](this.methods.length);
        for (int i = 0; i < this.methods.length; i += 1)
        {
            auto method = this.methods[i];
            auto methodArgs = new Argument[](method.args.length);

            for (int k = 0; k < method.args.length; k = k + 1)
                methodArgs[k] = Argument(method.args[k].name, method.args[k].type.compile(structContext));

            struct_.methods[i] = new StructMethod(
                method.loc,
                struct_,
                context,
                method.name,
                method.ret.compile(structContext),
                methodArgs,
                method.body_, null, this.macroState);
        }
        return struct_;
    }
}

ASTStructDecl parseStructDecl(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    if (parseIdentifier(parser) != "struct")
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    assert(!!name.length);
    ASTStructMember[] members;
    ASTStructMethod[] methods;
    parser.expect("{");
    while (!parser.accept("}"))
    {
        auto memberType = parseType(parser, lexicalContext);
        if (!memberType) parser.fail("expected member type");
        auto memberName = parseIdentifier(parser);
        if (!memberName.length) parser.fail("expected member name");
        if (parser.accept("(")) // method
        {
            ASTArgument[] args = parseArglist(parser, lexicalContext);
            ASTStatement stmt = parseStatement(parser, lexicalContext);
            methods ~= ASTStructMethod(
                parser.loc(), memberName, memberType, args, stmt);
        }
        else
        {
            parser.expect(";");
            members ~= ASTStructMember(memberName, memberType);
        }
    }
    parser.commit();
    return new ASTStructDecl(name, members, methods, lexicalContext.macroState);
}

Package selectPackage(Package[] packages, string name, Loc loc)
{
    for (int i = 0; i < packages.length; i += 1) {
        if (packages[i].name == name) return packages[i];
    }
    loc.assert2s(false, "Undefined package: '" ~ name ~ "'");
}

class ASTTypeAlias
{
    string name;

    ASTType type;

    this(string name, ASTType type) {
        this.name = name;
        this.type = type;
    }
}

class ASTSymbolAlias
{
    string name;

    ASTSymbol symbol;

    this(string name, ASTSymbol symbol) {
        this.name = name;
        this.symbol = symbol;
    }
}

// TODO Either
struct ASTModuleEntry
{
    ASTImport import_;

    ASTClassDecl classDecl;

    ASTStructDecl structDecl;

    ASTExtern extern_;

    ASTFunction function_;

    ASTTypeAlias typeAlias;

    ASTSymbolAlias symbolAlias;
}

ASTModule parseModuleBody(Parser parser, ParserHelper helper, ASTModule module_, ModuleParserConfig config)
{
    LexicalContext lexicalContext = new LexicalContext(module_.macroState);

    while (!parser.eof())
    {
        ASTImport import_ = parseImport(parser);
        if (import_) {
            module_.entries ~= ASTModuleEntry(
                import_, null, null, null, null, null, null);
            if (import_.isMacroImport)
            {
                auto importedModule = resolveImport(module_, import_, helper, config);

                module_.macroState = module_.macroState.dup();
                lexicalContext = new LexicalContext(module_.macroState);

                lexicalContext.macroState.addImport(importedModule.macroState);
            }
            continue;
        }
        ASTClassDecl classDecl = parseClassDecl(parser, lexicalContext);
        if (classDecl) {
            module_.entries ~= ASTModuleEntry(
                null, classDecl, null, null, null, null, null);
            continue;
        }
        ASTExtern extern_ = parseExtern(parser, lexicalContext);
        if (extern_) {
            module_.entries ~= ASTModuleEntry(
                null, null, null, extern_, null, null, null);
            continue;
        }
        auto strct = parseStructDecl(parser, lexicalContext);
        if (strct) {
            module_.entries ~= ASTModuleEntry(
                null, null, strct, null, null, null, null);
            continue;
        }
        ASTModule submod = parseMacroContinuation(parser, helper, module_, config);
        if (submod)
            return submod;
        ASTFunction fun = parseFunction(parser, lexicalContext);
        if (fun)
        {
            module_.entries ~= ASTModuleEntry(
                null, null, null, null, fun, null, null);
            continue;
        }

        parser.fail("couldn't parse function or struct");
    }
    assert(parser.level == 0);
    return module_;
}

ASTModule resolveImport(ASTModule module_, ASTImport import_, ParserHelper helper, ModuleParserConfig config)
{
    auto pak = module_.pak;
    // TODO enum SearchMode { Transitive, Direct, Commandline }
    bool transitive = true;
    if (import_.pak.length) {
        pak = selectPackage(config.packages, import_.pak, import_.loc);
        transitive = false;
    }
    return getModule(
        moduleToFile(import_.name), pak, true, helper, config, import_.loc);
}

Module compileImport(ASTModule module_, ASTImport import_, ParserHelper helper,
                     ModuleParserConfig config, Platform platform)
{
    auto astModule = resolveImport(module_, import_, helper, config);

    return compileModule(astModule, helper, config, platform, true);
}

Module compileModule(ASTModule astModule, ParserHelper helper, ModuleParserConfig config,
                     Platform platform, bool addDefaultModules)
{
    Module mod = config.cache.find(astModule, platform);
    if (mod) return mod;

    Module parent = null;

    if (astModule.parent)
    {
        parent = compileModule(astModule.parent, helper, config, platform, addDefaultModules);
    }

    Module module_ = new Module(astModule.name, astModule.pak, astModule.macroState, parent);
    Context context = Context(platform, module_, null, module_.macroState, (new int[](1)).ptr);
    if (addDefaultModules)
    {
        // TODO add to ASTModule (addImport that handles updating the macro state
        // so that adding default macro imports works)
        // NOTE once these are in ASTModule, we can take out ModuleParserConfig here and also from proxyCall.
        for (int i = 0; i < config.defaultImports.length; i += 1) {
            auto import_ = compileModule(config.defaultImports[i], helper, config, platform, false);
            module_.addImport(import_);
        }
    }

    for (int i = 0; i < astModule.entries.length; i += 1)
    {
        auto entry = astModule.entries[i];
        // TODO lazily resolve members only once they're looked up
        // (allows compilation in any order)
        if (entry.import_)
        {
            auto importedModule = compileImport(astModule, entry.import_, helper, config, platform);

            module_.addImport(importedModule);
        }
        else if (entry.classDecl)
        {
            module_.add(entry.classDecl.name, entry.classDecl.compile(context));
        }
        else if (entry.structDecl)
        {
            module_.add(entry.structDecl.name, entry.structDecl.compile(context));
        }
        else if (entry.extern_)
        {
            module_.add(entry.extern_.name, entry.extern_.compile(context));
        }
        else if (entry.function_)
        {
            module_.add(entry.function_.name, entry.function_.compile(context));
        }
        else if (entry.typeAlias)
        {
            module_.add(entry.typeAlias.name, entry.typeAlias.type.compile(context));
        }
        else if (entry.symbolAlias)
        {
            module_.add(entry.symbolAlias.name, entry.symbolAlias.symbol.compile(context));
        }
        else assert(false);
    }
    module_.resolve();
    config.cache.add(astModule, platform, module_);
    return module_;
}

ASTModule getModule(string filename, Package pak, bool search, ParserHelper helper, ModuleParserConfig config, Loc loc)
{
    auto macroState = new MacroState;
    string path = filename;
    if (search) {
        assert2s(!!pak, "search, but no package");
        path = findFileInPackage(filename, pak, loc, &pak);
    } else {
        assert2s(!pak, "no search, but package");
        filename = findResidualFilename(filename, config.packages, &pak);
    }
    assert(!!pak);
    ASTModule mod = config.astCache.find(path);
    if (mod) return mod;

    auto basicObjectCache = new BasicObjectCache(
        new ASTVoid, new ASTCharacter, new ASTShort, new ASTInteger, new ASTLong, new ASTFloat);

    string code = cxruntime_file_read(path);
    Parser parser = new Parser(path, code, basicObjectCache);

    parser.expect("module");
    string modname = parseIdentifier2(parser, ".");
    parser.expect(";");

    auto locAtModule = parser.loc();

    locAtModule.assert2s2(filename == moduleToFile(modname), filename, ": module doesn't match filename");

    ASTModule baseModule = new ASTModule(modname, pak, new MacroState, null);
    ASTModule module_ = parseModuleBody(parser, helper, baseModule, config);

    config.astCache.add(path, module_);

    return module_;
}
