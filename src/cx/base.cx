module cx.base;

import backend.base;
import cx.hash;
import cx.parser_base;
import helpers;

void assert2s(int test, string msg) { if (!test) { print(msg); assert(false); } }
void assert2s2(int test, string a, string b) { if (!test) { print(a ~ b); assert(false); } }
void assert2s3(int test, string a, string b, string c) { if (!test) { print(a ~ b ~ c); assert(false); } }
void assert2s4(int test, string a, string b, string c, string d) {
    if (!test) { print(a ~ b ~ c ~ d); assert(false); } }
void assert2s5(int test, string a, string b, string c, string d, string e) {
    if (!test) { print(a ~ b ~ c ~ d ~ e); assert(false); } }

// something that can be referenced by a name
abstract class Symbol
{
}

/**
 * A namespace is a lexical environment that supports identifier lookup.
 * Note that this means "foo", not "a.foo".
 */
abstract class Namespace
{
    Namespace parent; // lexical parent

    this(this.parent) { }

    // frame is a pointer to the stack frame or what was in the 'this'/'context' parameter.
    abstract Symbol lookup(string name, Expression frame) { assert(false); }

    string mangle() { return this.parent.mangle(); }
}

class LexicalContext
{
    CompilerBase compiler;

    MacroState macroState;

    this(this.compiler, this.macroState) { }
}

/**
 * Delineates a region of control flow in which scoped variables may be allocated and freed again.
 * Not currently used.
 */
class DeclarationScope
{
    DeclarationScope parent;

    Statement cleanup(Context context) { return null; }
}

/**
 * Delineates a region of control flow in which 'break;' and 'continue;' may be used.
 */
abstract class LoopScope : DeclarationScope
{
    abstract Statement breakFrom(Context context) { assert(false); }
    abstract Statement continueFrom(Context context) { assert(false); }
}

LoopScope findLoopScope(DeclarationScope scope_)
{
    if (!scope_) return null;
    auto loopScope = scope_.instanceOf(LoopScope);
    if (loopScope) return loopScope;
    if (scope_.parent) return findLoopScope(scope_.parent);
    return null;
}

abstract class ASTSymbol
{
    abstract Symbol compile(Context context) { assert(false); }
}

abstract class ASTMemberBase : ASTSymbol
{
    ASTSymbol base;

    string member;

    Loc loc;

    this(this.base, this.member, this.loc) { }
}

abstract class Statement
{
    abstract void emit(Generator output) { assert(false); }
    abstract void hash(Hash hash) { assert(false); }
}

abstract class Type : Symbol
{
    abstract BackendType emit(Platform platform) { assert(false); }
    abstract bool same(Type type) { assert(false); }
    abstract string repr() { assert(false); }
    abstract void hash(Hash hash) { assert(false); }

    Expression implicitConvertFrom(Expression source)
    {
        return null;
    }

    Expression implicitConvertTo(Expression source, Type target)
    {
        return null;
    }

    Expression truthy(Expression expr, Loc loc)
    {
        return null;
    }

    /**
     * Called to create a copy of an expression in a target.
     */
    Statement copyInto(Reference target, Expression source)
    {
        return null;
    }

    /**
     * Called when a scoped expression goes out of scope.
     */
    Statement endLifetime(Reference expr)
    {
        return null;
    }
}

abstract class ASTType
{
    abstract Type compile(Context context) { assert(false); }
}

class Void : Type
{
    BackendType type;
    this() { this.type = new BackendVoidType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Void); }

    override string repr() { return "void"; }

    override void hash(Hash hash) { hash.adds("void"); }
}

class Pointer : Type
{
    Type target;

    this(this.target) { }

    override BackendType emit(Platform platform)
    {
        return new BackendPointerType(this.target.emit(platform));
    }

    override bool same(Type other)
    {
        Pointer otherPtr = other.instanceOf(Pointer);

        return otherPtr && this.target.same(otherPtr.target);
    }

    override string repr() { return this.target.repr() ~ "*"; }

    override void hash(Hash hash) { hash.adds("pointer"); target.hash(hash); }
}

class Generator
{
    BackendModule mod;

    BackendFunction fun;

    Platform platform;

    int frameReg;

    this(this.platform, this.mod)
    {
        this.fun = null;
    }

    bool once(string name)
    {
        return this.mod.once(name);
    }
}

abstract class Expression : Symbol
{
    abstract Type type() { assert(false); }
    abstract int emit(Generator output) { assert(false); }
    /**
     * "Anything not in the stackframe."
     * If we are given a temporary expression, we have responsibility for managing its lifetime.
     */
    bool temporary() { return true; }
    abstract void hash(Hash hash) { assert(false); }
}

Expression beExpression(Symbol symbol)
{
    Expression expr = symbol.instanceOf(Expression);
    assert(!!expr);
    return expr;
}

Expression beExpression2(Symbol symbol, Loc loc)
{
    Expression expr = symbol.instanceOf(Expression);
    loc.assert2s(!!expr, "expression expected");
    return expr;
}

abstract class Reference : Expression
{
    int emitLocation(Generator output) { assert(false); }
}

class PointerCast : Expression
{
    Type target;

    Expression value;

    this(this.target, this.value) { }

    override Type type()
    {
        return this.target;
    }

    override int emit(Generator output)
    {
        int reg = this.value.emit(output);
        return output.fun.bitcast(reg, this.target.emit(output.platform));
    }

    override bool temporary() { return value.temporary(); }

    override void hash(Hash hash) { hash.adds("ptrcast"); target.hash(hash); value.hash(hash); }
}

/*
 * TODO: Right now we mix "callsite" and "function site" arguments.
 * If we separate these, we don't need isThisAssignment here.
 * Possibly separate FunctionDeclaration from FunctionImpl entirely.
 */
struct Argument
{
    // int i; this(this.i) { }  =>  this(int i) { this.i = i; }
    bool isThisAssignment;

    string name;

    Type type;
}

class FunctionDeclaration : Symbol
{
    string name;

    Type ret;

    Argument[] args;

    Type thisType; // must be a pointer

    this(this.name, this.ret, this.args)
    {
        this.thisType = null;
    }

    size_t numArgs()
    {
        if (!!thisType) return this.args.length + 1;
        return this.args.length;
    }

    string mangle() { return this.name; } // TODO extern

    void declare(Generator generator)
    {
        if (generator.mod.declared(this.mangle()))
            return;

        Type voidp = new Pointer(new Void);
        int extra = 0;
        if (this.thisType) extra = 1;
        auto argTypes = new BackendType[](this.numArgs());
        if (this.thisType) argTypes[0] = voidp.emit(generator.platform);
        for (int i = 0; i < this.args.length; i += 1)
            argTypes[extra + i] = this.args[i].type.emit(generator.platform);

        generator.mod.declare(
            this.mangle(),
            this.ret.emit(generator.platform),
            argTypes
        );
    }
}

/**
 * This is in base because it's circular with Context.
 */
class MacroState
{
    Macro[] macros;

    MacroState[] imports;

    this() { }

    MacroState dup() {
        auto newState = new MacroState;
        newState.macros = new Macro[](this.macros.length);
        for (int i = 0; i < this.macros.length; i += 1)
            newState.macros[i] = this.macros[i];
        newState.imports = new MacroState[](this.imports.length);
        for (int i = 0; i < this.imports.length; i += 1)
            newState.imports[i] = this.imports[i];
        return newState;
    }

    void applyMacro(MacroArgs args) {
        this.applyMacroExported(args);
        if (args.done()) return;
        for (int i = 0; i < this.imports.length; i += 1) {
            this.imports[i].applyMacroExported(args);
            if (args.done()) return;
        }
    }

    void applyMacroExported(MacroArgs args) {
        for (int i = 0; i < this.macros.length; i += 1) {
            this.macros[i].apply(args);
            if (args.done()) return;
        }
    }

    void addImport(MacroState target) {
        this.imports ~= target;
    }

    void addMacro(Macro macro_) {
        this.macros ~= macro_;
    }
}

abstract class VariableDeclarationBase : Namespace
{
    abstract Reference accessLocal() { assert(false); }
}

/**
 * Helper class used to break dependency loops between cx.base, macros and the rest of the compiler.
 */
abstract class CompilerBase
{
    // parser
    abstract ASTSymbol parseExpression(Parser parser, LexicalContext lexicalContext) { assert(false); }

    abstract ASTSymbol parseExpressionLeaf(Parser parser, LexicalContext lexicalContext) { assert(false); }

    abstract ASTStatement parseStatement(Parser parser, LexicalContext lexicalContext) { assert(false); }

    // expressions and statements
    abstract Expression implicitConvertToOptional(Expression from, Type to) { assert(false); }

    abstract Expression binaryOp(string op, Expression left, Expression right, Loc loc) { assert(false); }

    abstract Expression intLiteral(int value) { assert(false); }

    abstract Expression truthy(Expression value, Loc loc) { assert(false); }

    abstract Expression stringLiteral(string value) { assert(false); }

    abstract Expression call(FunctionDeclaration fun, Expression[] args, Loc loc) { assert(false); }

    abstract Statement assignStatement(Reference target, Expression value) { assert(false); }

    abstract Statement sequenceStatement(Statement[] stmts) { assert(false); }

    abstract Statement ifStatement(Expression test, Statement then, Statement else_) { assert(false); }

    abstract Statement exprStatement(Expression test) { assert(false); }

    abstract VariableDeclarationBase variableDeclaration(Namespace parent, string name, Type type) { assert(false); }

    Expression implicitConvertTo(Expression from, Type to, Loc loc)
    {
        auto result = implicitConvertToOptional(from, to);
        if (result) return result;
        loc.assert2s4(false, "todo: cast(", to.repr(), ") ", from.type().repr());
    }

    Expression expectImplicitConvertTo(Expression from, Type to, Loc loc)
    {
        auto result = implicitConvertToOptional(from, to);
        if (result) return result;
        loc.assert2s4(false, "todo: cast(", to.repr(), ") ", from.type().repr());
    }
}

// TODO document where exactly this is used
struct Context
{
    // all members should be treated as immutable

    CompilerBase compiler;

    Platform platform;

    Namespace namespace;

    DeclarationScope scope_;

    MacroState macroState;

    int* idCounter;

    Context withNamespace(Namespace namespace)
    {
        return Context(this.compiler, this.platform, namespace, this.scope_, this.macroState, this.idCounter);
    }

    Context withDeclScope(DeclarationScope scope_)
    {
        return Context(this.compiler, this.platform, this.namespace, scope_, this.macroState, this.idCounter);
    }

    string getLabel() { int i = *this.idCounter; *this.idCounter += 1; return "uniq" ~ itoa(i); }
}

// TODO Statement, Context multi-return
struct StatementCompileResult
{
    Statement statement;

    Context context;
}

abstract class ASTStatement
{
    StatementCompileResult compile(Context context) { assert(false); }
}

abstract class Macro
{
    abstract void apply(MacroArgs args) { assert(false); }
}

// macro subclasses are differentiated by args
abstract class MacroArgs
{
    abstract bool done() { assert(false); }
}

// hook the ASTCall (with ASTIdentifier) -> Call transform
class CallMacroArgs : MacroArgs
{
    string name;
    ASTSymbol[] symbols;
    Context context;
    Loc loc;
    Expression transformed; // out
    this(this.name, this.symbols, this.context, this.loc) {
        this.transformed = null;
    }
    override bool done() { return !!this.transformed; }
}

// hook parseExpressionBase
class ParseExpressionBaseArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTSymbol symbol; // out
    this(this.parser, this.lexicalContext) {
        this.symbol = null;
    }
    override bool done() { return !!this.symbol; }
}

// hook parseProperties
class ParsePropertyArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTSymbol left;
    ASTSymbol result; // out
    this(this.parser, this.lexicalContext, this.left) {
        this.result = null;
    }
    override bool done() { return !!this.result; }
}

// hook parseStatement
class ParseStatementArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTStatement statement; // out
    this(this.parser, this.lexicalContext) {
        this.statement = null;
    }
    override bool done() { return !!this.statement; }
}

class Package
{
    string name;
    string path;
    Package[] deps;

    this(this.name, this.path) { }

    void addDependency(Package dep) {
        this.deps ~= dep;
    }
}

class BasicObjectCache : IBasicObjectCache
{
    this(this.astvoid, this.astchar, this.astshort, this.astint, this.astlong, this.astfloat) { }
    ASTType astvoid;
    ASTType astchar;
    ASTType astshort;
    ASTType astint;
    ASTType astlong;
    ASTType astfloat;
}
