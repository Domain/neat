module cx.types;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser;
import cx.parser_base;
import helpers;

class Character : Type
{
    BackendType type;
    this() { this.type = new BackendCharType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other)
    {
        return !!other.instanceOf(Character);
    }

    override string repr() { return "char"; }

    override string mangle() { return "char"; }

    override void hash(Hash hash) { hash.adds("char"); }
}

class Integer : Type
{
    BackendType type;
    this() { this.type = new BackendIntType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Integer); }

    override string repr() { return "int"; }

    override string mangle() { return "int"; }

    override void hash(Hash hash) { hash.adds("int"); }
}

class Long : Type
{
    BackendType type;
    this() { this.type = new BackendLongType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Long); }

    override string repr() { return "long"; }

    override string mangle() { return "long"; }

    override void hash(Hash hash) { hash.adds("long"); }
}

class Short : Type
{
    BackendType type;
    this() { this.type = new BackendShortType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Short); }

    override string repr() { return "short"; }

    override string mangle() { return "short"; }

    override void hash(Hash hash) { hash.adds("short"); }
}

class Float : Type
{
    BackendType type;
    this() { this.type = new BackendFloatType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Float); }

    override string repr() { return "float"; }

    override string mangle() { return "float"; }

    override void hash(Hash hash) { hash.adds("float"); }
}

class ASTPointer : ASTType
{
    ASTType subType;

    this(this.subType) { }

    override Type compile(Context context)
    {
        Type subType = this.subType.compile(context);

        return new Pointer(subType);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTPointer'!"); assert(false); }
}

class ASTNamedType : ASTType
{
    string name;

    Loc loc;

    this(this.name, this.loc) {
        assert(name.length > 0);
    }

    override Type compile(Context context)
    {
        if (name == "int") return new Integer;
        if (name == "long") return new Long;
        if (name == "short") return new Short;
        if (name == "char") return new Character;
        if (name == "void") return new Void;
        if (name == "float") return new Float;

        Symbol target = context.namespace.lookup(this.name, null);

        this.loc.assert2s2(target && target.instanceOf(Type), this.name, " is not a type");
        return target.instanceOf(Type);
    }

    override ASTSymbol quote(Quoter quoter) {
        // $foo is quoted as 'foo'
        if (name[0 .. 1] == "$") {
            return quoter.compiler.astIdentifier(name[1 .. name.length], loc.reloc);
        }
        return quoter.compilerCall("astNamedType", [quoter.compiler.astStringLiteral(name, loc.reloc)], loc.reloc);
    }
}

class ASTTypeof : ASTType
{
    ASTSymbol value;

    Loc loc;

    this(this.value, this.loc) { }

    override Type compile(Context context)
    {
        // right now, declarations in typeof() will be tracked in the stackframe and take up space,
        // even if they're never initialized.
        // TODO prevent this.
        auto value = beExpression2(this.value.compile(context), this.loc);
        return value.type();
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astTypeOf", [value.quote(quoter)], loc.reloc);
    }
}

// hook type parsing
class TypeMacroArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTType astType;
    this(this.parser, this.lexicalContext) {
        this.astType = null;
    }
    override bool done() { return !!this.astType; }
}

ASTType parseLeafType(Parser parser, LexicalContext lexicalContext)
{
    {
        auto typeMacroArgs = new TypeMacroArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(typeMacroArgs);
        if (typeMacroArgs.astType) return typeMacroArgs.astType;
    }
    auto loc = parser.loc();
    parser.begin();

    if (parser.accept("typeof"))
    {
        parser.expect("(");
        auto expr = lexicalContext.compiler.parseExpression(parser, lexicalContext);
        if (!expr) parser.fail("expression expected");
        parser.expect(")");
        parser.commit();
        return new ASTTypeof(expr, loc);
    }

    string identifier = parseIdentifier(parser);

    if (!identifier.length)
    {
        parser.revert();
        return null;
    }

    if (identifier == "long")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astlong;
    }

    if (identifier == "int")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astint;
    }

    if (identifier == "short")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astshort;
    }

    if (identifier == "char")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astchar;
    }

    if (identifier == "void")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astvoid;
    }

    if (identifier == "float")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astfloat;
    }

    parser.commit();
    return new ASTNamedType(identifier, parser.loc());
}

class ASTFunctionPointer : ASTType
{
    ASTType ret;

    ASTType[] args;

    this(this.ret, this.args) { }

    override Type compile(Context context)
    {
        Type ret = this.ret.compile(context);
        Type[] args = new Type[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) args[i] = this.args[i].compile(context);

        return new FunctionPointer(ret, args);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTFunctionPointer'!"); assert(false); }
}

class FunctionPointer : Type
{
    Type ret;

    Type[] args;

    this(this.ret, this.args) { }

    override BackendType emit(Platform platform)
    {
        auto args = new BackendType[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) args[i] = this.args[i].emit(platform);
        return new BackendFunctionPointerType(this.ret.emit(platform), args);
    }

    override bool same(Type other)
    {
        FunctionPointer otherPtr = other.instanceOf(FunctionPointer);
        if (!otherPtr) return false;
        if (!this.ret.same(otherPtr.ret)) return false;
        if (this.args.length != otherPtr.args.length) return false;
        for (int i = 0; i < this.args.length; i += 1)
            if (!this.args[i].same(otherPtr.args[i])) return false;
        return true;
    }

    override string repr() { return this.ret.repr() ~ "(...)"; }

    override string mangle() {
        // return "fp_" ~ this.ret.repr() ~ "_" ~ this.args.map!repr.join("_");
        string ret = "fp_" ~ this.ret.repr();
        for (int i = 0; i < this.args.length; i += 1)
            ret ~= "_" ~ this.args[i].mangle();
        return ret;
    }

    override void hash(Hash hash) {
        hash.adds("funcptr");
        ret.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

class ASTNestedFunctionPointer : ASTType
{
    ASTType ret;

    ASTType[] args;

    this(this.ret, this.args) { }

    override Type compile(Context context)
    {
        Type ret = this.ret.compile(context);
        Type[] args = new Type[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) args[i] = this.args[i].compile(context);

        return new NestedFunctionPointer(ret, args);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTNestedFunctionPointer'!"); assert(false); }
}

/**
 * { void *base; void *data; Ret(Args...) funcptr; }
 * base is held in reserve for when we reference count delegates
 */
class NestedFunctionPointer : Type
{
    Type ret;

    Type[] args;

    this(this.ret, this.args) { }

    override BackendType emit(Platform platform)
    {
        auto args = new BackendType[](this.args.length + 1);
        args[0] = platform.voidp();
        for (int i = 0; i < this.args.length; i += 1) args[i + 1] = this.args[i].emit(platform);
        auto fp = new BackendFunctionPointerType(this.ret.emit(platform), args);
        return new BackendStructType([platform.voidp(), platform.voidp(), fp]);
    }

    override bool same(Type other)
    {
        NestedFunctionPointer otherPtr = other.instanceOf(NestedFunctionPointer);
        if (!otherPtr) return false;
        if (!this.ret.same(otherPtr.ret)) return false;
        if (this.args.length != otherPtr.args.length) return false;
        for (int i = 0; i < this.args.length; i += 1)
            if (!this.args[i].same(otherPtr.args[i])) return false;
        return true;
    }

    override string repr() {
        string ret = this.ret.repr() ~ " delegate(";
        for (int i = 0; i < this.args.length; i += 1) {
            if (i) ret ~= ", ";
            ret ~= this.args[i].repr();
        }
        return ret ~ ")";
    }

    override string mangle() {
        // return "fp_" ~ this.ret.repr() ~ "_" ~ this.args.map!repr.join("_");
        string ret = "dg_" ~ this.ret.repr();
        for (int i = 0; i < this.args.length; i += 1)
            ret ~= "_" ~ this.args[i].mangle();
        return ret;
    }

    override void hash(Hash hash) {
        hash.adds("dgptr");
        ret.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

Type nativeWordType(Platform platform)
{
    BackendType type = platform.nativeWordType;
    if (type.instanceOf(BackendIntType)) return new Integer;
    if (type.instanceOf(BackendLongType)) return new Long;
    assert(false);
}
