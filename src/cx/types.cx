module cx.types;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser;
import cx.parser_base;
import helpers;

class ASTCharacter : ASTType
{
    Type type;
    this() { this.type = new Character; }
    override Type compile(Context context) { return this.type; }
}

class Character : Type
{
    BackendType type;
    this() { this.type = new BackendCharType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other)
    {
        return !!other.instanceOf(Character);
    }

    override string repr() { return "char"; }

    override void hash(Hash hash) { hash.adds("char"); }
}

class ASTInteger : ASTType
{
    Type type;
    this() { this.type = new Integer; }
    override Type compile(Context context) { return this.type; }
}

class Integer : Type
{
    BackendType type;
    this() { this.type = new BackendIntType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Integer); }

    override string repr() { return "int"; }

    override void hash(Hash hash) { hash.adds("int"); }
}

class ASTLong : ASTType
{
    Type type;
    this() { this.type = new Long; }

    override Type compile(Context context) { return this.type; }
}

class Long : Type
{
    BackendType type;
    this() { this.type = new BackendLongType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Long); }

    override string repr() { return "long"; }

    override void hash(Hash hash) { hash.adds("long"); }
}

class ASTShort : ASTType
{
    Type type;
    this() { this.type = new Short; }

    override Type compile(Context context) { return this.type; }
}

class Short : Type
{
    BackendType type;
    this() { this.type = new BackendShortType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Short); }

    override string repr() { return "short"; }

    override void hash(Hash hash) { hash.adds("short"); }
}

class ASTVoid : ASTType
{
    Type type;
    this() { this.type = new Void; }

    override Type compile(Context context) { return this.type; }
}

class ASTFloat : ASTType
{
    Type type;
    this() { this.type = new Float; }

    override Type compile(Context context) { return this.type; }
}

class Float : Type
{
    BackendType type;
    this() { this.type = new BackendFloatType; }

    override BackendType emit(Platform platform) { return this.type; }

    override bool same(Type other) { return !!other.instanceOf(Float); }

    override string repr() { return "float"; }

    override void hash(Hash hash) { hash.adds("float"); }
}

class ASTPointer : ASTType
{
    ASTType subType;

    this(this.subType) { }

    override Type compile(Context context)
    {
        Type subType = this.subType.compile(context);

        return new Pointer(subType);
    }
}

class NamedType : ASTType
{
    string name;

    Loc loc;

    this(this.name, this.loc) {
        assert(name.length > 0);
    }

    override Type compile(Context context)
    {
        Symbol target = context.namespace.lookup(this.name, null);

        this.loc.assert2s2(target && target.instanceOf(Type), this.name, " is not a type");
        return target.instanceOf(Type);
    }
}

// hook type parsing
class TypeMacroArgs : MacroArgs
{
    Parser parser;
    LexicalContext lexicalContext;
    ASTType astType;
    this(this.parser, this.lexicalContext) {
        this.astType = null;
    }
    override bool done() { return !!this.astType; }
}

ASTType parseLeafType(Parser parser, LexicalContext lexicalContext)
{
    {
        auto typeMacroArgs = new TypeMacroArgs(parser, lexicalContext);
        lexicalContext.macroState.applyMacro(typeMacroArgs);
        if (typeMacroArgs.astType) return typeMacroArgs.astType;
    }
    parser.begin();

    string identifier = parseIdentifier(parser);

    if (!identifier.length)
    {
        parser.revert();
        return null;
    }

    if (identifier == "long")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astlong;
    }

    if (identifier == "int")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astint;
    }

    if (identifier == "short")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astshort;
    }

    if (identifier == "char")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astchar;
    }

    if (identifier == "void")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astvoid;
    }

    if (identifier == "float")
    {
        parser.commit();
        return parser.cache.instanceOf(BasicObjectCache).astfloat;
    }

    parser.commit();
    return new NamedType(identifier, parser.loc());
}

// length, ptr, base: see array.cx
class Array : Type
{
    Type elementType;

    this(this.elementType) { }

    override BackendType emit(Platform platform)
    {
        BackendType[] types;
        if (platform.newArrays) {
            types = new BackendType[](3);
            types[0] = platform.nativeWordType;
            types[1] = new BackendPointerType(this.elementType.emit(platform));
            types[2] = platform.voidp();
        } else {
            types = new BackendType[](2);
            types[0] = platform.nativeWordType;
            types[1] = new BackendPointerType(this.elementType.emit(platform));
        }
        return new BackendStructType(types);
    }

    override bool same(Type other)
    {
        Array otherArray = other.instanceOf(Array);

        return otherArray && otherArray.elementType.same(this.elementType);
    }

    override string repr() { return this.elementType.repr() ~ "[]"; }

    override void hash(Hash hash) { hash.adds("array"); this.elementType.hash(hash); }
}

class ASTArray : ASTType
{
    ASTType elementType;

    this(this.elementType) { }

    override Type compile(Context context)
    {
        return new Array(this.elementType.compile(context));
    }
}

class ASTFunctionPointer : ASTType
{
    ASTType ret;

    ASTType[] args;

    this(this.ret, this.args) { }

    override Type compile(Context context)
    {
        Type ret = this.ret.compile(context);
        Type[] args = new Type[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) args[i] = this.args[i].compile(context);

        return new FunctionPointer(ret, args);
    }
}

class FunctionPointer : Type
{
    Type ret;

    Type[] args;

    this(this.ret, this.args) { }

    override BackendType emit(Platform platform)
    {
        auto args = new BackendType[](this.args.length);
        for (int i = 0; i < this.args.length; i += 1) args[i] = this.args[i].emit(platform);
        return new BackendFunctionPointerType(this.ret.emit(platform), args);
    }

    override bool same(Type other)
    {
        FunctionPointer otherPtr = other.instanceOf(FunctionPointer);
        if (!otherPtr) return false;
        if (!this.ret.same(otherPtr.ret)) return false;
        if (this.args.length != otherPtr.args.length) return false;
        for (int i = 0; i < this.args.length; i += 1)
            if (!this.args[i].same(otherPtr.args[i])) return false;
        return true;
    }

    override string repr() { return this.ret.repr() ~ "(...)"; }

    override void hash(Hash hash) {
        hash.adds("funcptr");
        ret.hash(hash);
        hash.addl(args.length);
        for (int i = 0; i < args.length; i += 1)
            args[i].hash(hash);
    }
}

ASTType parseType(Parser parser, LexicalContext lexicalContext)
{
    ASTType current = parseLeafType(parser, lexicalContext);
    if (!current) return null;
    while (true)
    {
        if (parser.accept("*"))
        {
            current = new ASTPointer(current);
            continue;
        }
        parser.begin();
        string identifier = parseIdentifier(parser);
        if (identifier == "function")
        {
            parser.expect("(");
            ASTType[] args;
            while (!parser.accept(")"))
            {
                if (args.length)
                {
                    if (!parser.accept(","))
                    {
                        parser.fail("',' or ')' expected");
                    }
                }
                ASTType argType = parseType(parser, lexicalContext);
                assert(!!argType);

                args ~= argType;
            }
            parser.commit();
            current = new ASTFunctionPointer(current, args);
            continue;
        }
        parser.revert();
        parser.begin();
        if (parser.accept("[") && parser.accept("]"))
        {
            parser.commit();

            current = new ASTArray(current);
            continue;
        }
        parser.revert();
        return current;
    }
}

Type nativeWordType(Platform platform)
{
    BackendType type = platform.nativeWordType;
    if (type.instanceOf(BackendIntType)) return new Integer;
    if (type.instanceOf(BackendLongType)) return new Long;
    assert(false);
}
