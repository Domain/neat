module cx.class_;

macro import cx.macros.either;
macro import cx.macros.listcomprehension;
macro import cx.macros.once;
macro import cx.macros.quasiquoting;

import backend.base;
import cx.array;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser;
import cx.parser_base;
import cx.function_;
import cx.struct_;
import cx.types;
import helpers;

class ClassMethod : Function
{
    Loc loc;

    bool override_;

    bool abstract_;

    this(this.loc, Class classType, this.override_, this.abstract_, this.name, this.ret, this.args,
         this.statement, this.macroState)
    {
        // TODO super()
        auto classNamespace = new ClassNamespace(classType.context.namespace, classType);

        this.hasThisArg = true;
        this.contextType = classType;
        this.parent = classNamespace;
    }

    override string mangle()
    {
        // TODO mangle types
        return this.parent.mangle ~ "_" ~ this.contextType.instanceOf(Class).name ~ "_" ~ this.name;
    }

    Type funcPtrType()
    {
        auto argTypes = [this.contextType] ~ [arg.type for arg in this.args];
        return new FunctionPointer(this.ret, argTypes);
    }
}

class ClassNamespace : Namespace
{
    Class class_;

    this(this.parent, this.class_) { this.isContextScope = true; }

    override Symbol lookup(string name, Context context, Expression thisPtr)
    {
        auto thisPtr = new PointerCast(this.class_, thisPtr);

        if (auto result = context.compiler.accessMemberWithLifetime(
                context, thisPtr, name, Loc(null, ReLoc("", 0)), true))
            return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, null);
    }
}

/**
 * Class layout:
 * - super class data OR
 *   - vtable ptr
 *   - reference count
 * - class data
 */
class Class : Type
{
    string name;

    bool final_; // methods may not be overridden

    bool abstract_; // may contain abstract methods

    Class superClass;

    // will resolve members and methods as required
    ASTClassDecl decl;

    // used for resolving
    Context context;

    (string name, Type type)[] members;

    ClassMethod[] methods;

    ClassMethod[] vtable_; // methods appearing in the classinfo struct

    string vtableSymbol;

    string mangledName;

    PolyHashState mangledHash;

    Struct dataStruct;

    this(this.decl, this.superClass, this.context)
    {
        if (superClass && superClass.final_)
            decl.loc.fail("cannot subclass a final class");
        assert(!!decl);
        this.name = decl.name;
        this.final_ = decl.final_;
        this.abstract_ = decl.abstract_;
        this.mangledName = context.namespace.mangle ~ "_class_" ~ this.name;
        auto state = poly_hash_string("Class" ~ this.mangledName);
        this.mangledHash = PolyHashState(state.add, state.mult);
    }

    override string mangle() {
        return this.mangledName;
    }

    override Expression truthy(Context context, Expression value, Loc loc)
    {
        Expression do_(Expression value) {
            Type voidp = once new Pointer(new Void);

            return .truthy(context, new PointerCast(voidp, value), loc);
        }
        return context.compiler.consume(context, value, &do_);
    }

    override Symbol accessMember(Loc loc, Context context, Expression baseExpr, string member)
    {
        ClassMethod[] vtable = this.vtable;
        Expression asStructPtr = new PointerCast(
            new Pointer(this.dataStruct), baseExpr);
        size_t methodOffset = [first i for i, a in vtable where a.name == member else -1];
        if (methodOffset != -1)
        {
            Reference classInfo = context.compiler.dereference(new PointerCast(
                new Pointer(this.classInfoStruct),
                new StructMemberReference(context.compiler.dereference(asStructPtr), 0)));
            if (this.final_) {
                auto funcPtr = new FunctionReference(vtable[methodOffset]);
                return new ClassMethodPtr(funcPtr, baseExpr);
            }
            Expression funcPtrValue = new StructMemberReference(classInfo, methodOffset);
            auto funcPtr = funcPtrValue.type.instanceOf(FunctionPointer);

            auto funcPtrWithVoidpThis = new FunctionPointer(funcPtr.ret, [arg for arg in funcPtr.args]);
            funcPtrWithVoidpThis.args[0] = once new Pointer(new Void);
            funcPtrValue = new PointerCast(funcPtrWithVoidpThis, funcPtrValue);

            return new ClassMethodPtr(funcPtrValue, baseExpr);
        }

        auto members = this.allMembers(context);
        size_t memberOffset = [first i for i, a in members where a.name == member else -1];
        if (memberOffset != -1)
            return new StructMemberReference(context.compiler.dereference(asStructPtr), memberOffset);
    }

    override Expression implicitConvertFrom(Expression from)
    {
        // upcast
        if (from.type.instanceOf(Class))
        {
            Class currentClass = from.type.instanceOf(Class);

            while (currentClass)
            {
                if (currentClass.same(this))
                {
                    return new PointerCast(this, from);
                }
                currentClass = currentClass.superClass;
            }
        }
        // = null
        if (from.instanceOf(NullExpr))
        {
            return new PointerCast(this, from);
        }
        return null;
    }

    override Expression implicitConvertTo(Context context, Expression from, Type to)
    {
        // (void*) class
        auto voidp = once new Pointer(new Void);

        if (to.same(voidp))
        {
            if (from.info.ownership == Ownership.gifted)
            {
                print("cannot convert temporary expression to void* - where would the reference go?");
                // TODO return Either(Expression, Error)
                assert(false);
            }
            return new PointerCast(voidp, from);
        }
        return null;
    }

    void resolve()
    {
        // TODO compilation stage enum
        if (this.vtableSymbol != "") return;
        this.decl.compile2(this.context, this);
    }

    override BackendType emit(Platform platform)
    {
        return platform.voidp;
    }

    (string name, Type type)[] allMembers(Context context)
    {
        if (!this.superClass)
        {
            return [
                ("__classinfo", once cast(Type) new Pointer(new Void)),
                ("__refs", context.nativeWordType),
            ] ~ this.members;
        }
        return this.superClass.allMembers(context) ~ this.members;
    }

    void initDataStruct(Context context)
    {
        auto allMembers = this.allMembers(context);
        auto structMembers = [
            new StructMemberDeclaration(member.name, member.type)
            for member in allMembers];

        this.dataStruct = new Struct("", structMembers, this.decl.loc, this.mangle);
    }

    Struct classInfoStructCache;

    Struct classInfoStruct()
    {
        if (classInfoStructCache) {
            assert(classInfoStructCache.members.length == vtable_.length);
            return classInfoStructCache;
        }

        auto vtableMembers = [
            new StructMemberDeclaration(method.name, method.funcPtrType)
            for method in vtable_];

        classInfoStructCache = new Struct("", vtableMembers, this.decl.loc, this.mangle);
        return classInfoStructCache;
    }

    ClassMethod[] vtable()
    {
        return [a for a in this.vtable_];
    }

    void genVtable(Context context)
    {
        if (this.vtableSymbol != "") return;

        assert(this.vtable_.length == 0);

        ClassMethod[] combinedMethods;
        if (this.superClass) {
            this.superClass.genVtable(context);
            combinedMethods = this.superClass.vtable;
        }

        this.genInstanceofMethod(context);
        this.genReleaseMethod(context);

        for (ClassMethod method <- this.methods) {
            // TODO match types
            bool isCtor = method.name == "__ctor"; // workaround: no final yet, no proper masking yet
            size_t index = [first i for i, a in combinedMethods where a.name == method.name else -1];
            if (index != -1)
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(method.override_ || isCtor,
                        "Expected 'override' attribute for overriding method.");
                // override
                combinedMethods[index] = method;
            }
            else
            {
                if (method.loc.lineNumbers)
                    method.loc.assert2s(!method.override_,
                        "'override specified but method does not override a parent method.");
                combinedMethods ~= method;
            }
        }
        if (!this.abstract_)
        {
            for (auto method <- combinedMethods) {
                if (method.abstract_)
                    this.decl.loc.fail(
                        "Abstract method '" ~ method.name ~ "' not overridden in non-abstract class " ~ this.name);
            }
        }
        this.vtable_ = combinedMethods;
        this.vtableSymbol = this.mangledName ~ "_vtable";
    }

    void declare(Generator generator)
    {
        if (generator.mod.declared(vtableSymbol))
            return;

        generator.mod.declareSymbolList(vtableSymbol, vtable_.length);
    }

    void define(Generator generator)
    {
        auto methods = [
            ({ method.declare(generator); method.mangle; })
            for method in vtable_];

        generator.mod.defineSymbolList(vtableSymbol, methods);
    }

    void genInstanceofMethod(Context context)
    {
        ASTStatement[] castStmts;
        Loc nowhere;
        Class current = this;
        while (current)
        {
            auto classinfo = new ASTSymbolHelper(new ClassInfo(current));
            castStmts ~= context.compiler.$stmt if (targetClassinfo is $classinfo) return this;;
            current = current.superClass;
        }
        castStmts ~= context.compiler.$stmt return null;;
        auto stmt = context.compiler.astSequence(castStmts, nowhere.reloc);

        bool override_ = false;
        if (this.superClass) override_ = true;
        this.methods ~= new ClassMethod(
            nowhere, this, override_, false /* abstract */, "__instanceof",
            this, [Argument(false, "targetClassinfo", once new Pointer(new Void))], stmt, new MacroState);
    }

    void genReleaseMethod(Context context)
    {
        ASTStatement[] statements;
        Loc nowhere;
        auto members = this.allMembers(context);
        assert(members.length >= 2);
        members = members[2 .. $]; // drop __classinfo and __refs
        for (auto member <- members) {
            auto name = context.compiler.astIdentifier(member.name, nowhere.reloc);
            statements ~= context.compiler.$stmt __destroy($name);;
        }
        auto stmt = context.compiler.astSequence(statements, nowhere.reloc);

        bool override_ = false;
        if (this.superClass) override_ = true;
        this.methods ~= new ClassMethod(
            nowhere, this, override_, false /* abstract */, "__destroy",
            once new Void, [], stmt, new MacroState);
    }

    override bool same(Type other) {
        Class otherClass = other.instanceOf(Class);

        return otherClass && otherClass.name == this.name; // TODO module
    }

    override string repr() { return this.name; }

    override void hash(Hash hash) {
        hash.apply(mangledHash.add, mangledHash.mult);
        // does there to be more here? I think not; Class is not being emitted as a distinct symbol
        // the vtable is hashed from the class decl
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        Context context = context; // TODO mut Context context
        Statement do_(Expression source) {
            auto sizeT = context.nativeWordType;
            auto refCountIncFun = once new FunctionDeclaration(
                "cxruntime_refcount_inc", new Void, [
                    Argument(false, "label", new Array(new Character)),
                    Argument(false, "ptr", new Pointer(new Void))]);

            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "this", new IgnoreLifetimeExpr(source)));
            context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "size_t", sizeT));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "cxruntime_refcount_inc", refCountIncFun));
            context = context.withNamespace(context.compiler.exprAlias(
                        context.namespace, "inc_name", new StringLiteral("inc " ~ this.name)));

            auto incref = context.compiler.$stmt
            if (!!this) {
                cxruntime_refcount_inc(inc_name, &(cast(size_t*) this)[1]);
            };
            auto assign = context.compiler.assignStatement(target, source);
            return context.compiler.sequence(incref.compile(context).statement, assign);
        }
        return context.compiler.stmtWithTemporary(source, &do_);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        Context context = context; // TODO mut Context context
        // disable lifetime management
        // (otherwise we get an infinite cycle when the compiler
        // tries to clean up 'this' after the __destroy() call by
        // ending its lifetime (ad infinitum).
        auto tempThis = new PairedTemporary(reference.type, false);
        auto initTemp = new InitializeTemporaryStatement(tempThis, reference);

        auto sizeT = context.nativeWordType;
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "this", tempThis));
        context = context.withNamespace(
            context.compiler.exprAlias(context.namespace, "size_t", sizeT));

        // TODO do in __destroy() once we have function imports
        auto freeFun = once new FunctionDeclaration(
            "free", new Void, [Argument(false, "ptr", new Pointer(new Void))]);
        auto refCountDecFun = once new FunctionDeclaration(
            "cxruntime_refcount_dec", new Integer, [
                Argument(false, "label", new Array(new Character)),
                Argument(false, "ptr", new Pointer(new Void))]);

        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "free", freeFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "cxruntime_refcount_dec", refCountDecFun));
        context = context.withNamespace(context.compiler.exprAlias(
                    context.namespace, "dec_name", new StringLiteral("dec " ~ this.name)));
        auto stmt = context.compiler.$stmt
            if (!!this) {
                if (cxruntime_refcount_dec(dec_name, &(cast(size_t*) this)[1]))
                {
                    this.__destroy;
                    free(this);
                }
            };
        return context.compiler.sequence(initTemp, stmt.compile(context).statement);
    }
}

struct ASTClassDeclMember
{
    string name;

    ASTSymbol type;

    Loc loc;
}

struct ASTClassDeclMethod
{
    Loc loc;

    bool override_;

    bool abstract_;

    string name;

    ASTSymbol ret;

    Either(ASTArgument, ASTThisAssignment)[] args;

    ASTStatement body_;
}

class ASTClassDecl : ASTSymbol
{
    string name;

    string superClass;

    bool final_;

    bool abstract_;

    ASTClassDeclMember[] members;

    ASTClassDeclMethod[] methods;

    MacroState macroState;

    Loc loc;

    this(this.name, this.superClass, this.final_, this.abstract_,
         this.members, this.methods, this.macroState, this.loc) { }

    override Class compile(Context context)
    {
        Class superClass = null;
        if (this.superClass.length)
        {
            Symbol superClassObj = context.namespace.lookup(this.superClass, context, null);
            this.loc.assert2s(!!superClassObj, "super class not found: " ~ this.superClass);
            superClass = superClassObj.instanceOf(Class);
            assert(!!superClass);
        }
        return new Class(this, superClass, context);
    }

    void compile2(Context context, Class target)
    {
        auto classScope = context.compiler.symbolAlias(context.namespace, target.name, target);
        Context classContext = context.withNamespace(classScope);

        target.members = [
            (member.name, beType(member.loc, member.type.compile(classContext)))
            for member in this.members];

        target.methods = new ClassMethod[](this.methods.length);
        target.initDataStruct(context);
        for (int i <- 0 .. this.methods.length)
        {
            ASTClassDeclMethod method = this.methods[i];

            auto methodArgs = new Argument[](method.args.length);
            for (int k <- 0 .. method.args.length)
            {
                auto arg = method.args[k];
                arg.case {
                    ASTThisAssignment arg:
                    {
                        auto members = target.allMembers(context);
                        size_t member = [first i for i, a in members where a.name == arg.name else -1];
                        // TODO specific loc
                        method.loc.assert2s2(member != -1, "no such member: ", arg.name);
                        methodArgs[k] = Argument(true, arg.name, members[member].type);
                    }
                    ASTArgument arg:
                        methodArgs[k] = Argument(false, arg.name, beType(arg.loc, arg.type.compile(classContext)));
                }
            }

            target.methods[i] = new ClassMethod(
                method.loc,
                target,
                method.override_,
                method.abstract_,
                method.name,
                beType(method.loc, method.ret.compile(classContext)),
                methodArgs,
                method.body_, this.macroState);
        }
        target.genVtable(context);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTClassDecl'!"); assert(false); }
}

ASTClassDecl parseClassDecl(Parser parser, LexicalContext lexicalContext)
{
    bool classAbstract = false;
    bool classFinal = false;
    parser.begin;
    parser.strip;
    auto loc = parser.loc;
    while (true) {
        if (acceptIdentifier(parser, "abstract")) {
            classAbstract = true;
            continue;
        }
        if (acceptIdentifier(parser, "final")) {
            classFinal = true;
            continue;
        }
        break;
    }
    if (!acceptIdentifier(parser, "class"))
    {
        parser.revert;
        return null;
    }
    parser.commit;

    string name = parseIdentifier(parser);
    string superClass;
    if (parser.accept(":")) {
        superClass = parseIdentifier(parser);
        parser.assert_(superClass.length > 0, "expected super class identifier");
    }
    ASTClassDeclMember[] members;
    ASTClassDeclMethod[] methods;
    parser.expect("{");
    Loc nowhere;
    while (!parser.accept("}"))
    {
        parser.strip;

        Loc loc = parser.loc;

        ASTSymbol retType;
        string memberName;
        bool override_ = false;
        bool abstract_ = false;
        while (true) {
            if (acceptIdentifier(parser, "override")) {
                override_ = true;
                continue;
            }
            if (acceptIdentifier(parser, "abstract")) {
                abstract_ = true;
                continue;
            }
            break;
        }

        if (parser.accept("this"))
        {
            parser.assert_(!override_, "cannot override constructor");
            retType = new ASTBasicType("void", nowhere);
            memberName = "__ctor";
        }
        else
        {
            retType = lexicalContext.compiler.parseType(parser, lexicalContext);
            parser.assert_(!!retType, "expected member type");
            memberName = parseIdentifier(parser);
            parser.assert_(memberName.length > 0, "expected member name");
        }
        if (parser.accept("(")) // method
        {
            auto args = parseArglist(parser, lexicalContext);
            ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext);
            methods ~= ASTClassDeclMethod(
                parser.loc, override_, abstract_, memberName, retType, args, stmt);
        }
        else
        {
            parser.assert_(!override_, "cannot override class member");
            parser.assert_(!abstract_, "cannot declare class member abstract");
            parser.expect(";");
            members ~= ASTClassDeclMember(memberName, retType, loc);
        }
    }
    return new ASTClassDecl(
        name, superClass, classFinal, classAbstract,
        members, methods, lexicalContext.macroState, loc);
}

class ClassInfo : Expression
{
    Class classType;

    this(this.classType) { }

    override Type type()
    {
        return once new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        this.classType.declare(output);
        return output.fun.symbolList(this.classType.vtableSymbol);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ClassInfo"); classType.hash(hash); }
}

class NewClassExpression : Expression
{
    Class classType;

    this(this.classType) { }

    override Type type()
    {
        return this.classType;
    }

    override int emit(Generator output)
    {
        // oh boy!
        BackendType voidp = once (new Pointer(new Void)).emit(output.platform);
        auto backendClassData = this.classType.dataStruct.emit(output.platform);
        int classDataSize = backendClassData.size(output.platform);
        int classInfoPtr = (new ClassInfo(classType)).emit(output);
        int classPtr = output.fun.call(
            voidp, "cxruntime_alloc", [output.fun.wordLiteral(output.platform, classDataSize)]);
        auto sizeT = output.platform.nativeWordType;
        int classInfoTarget = output.fun.fieldOffset(backendClassData, classPtr, 0);
        output.fun.store(voidp, classInfoTarget, classInfoPtr);
        int refCount = output.fun.fieldOffset(backendClassData, classPtr, 1);
        int one = output.fun.wordLiteral(output.platform, 1);
        output.fun.store(sizeT, refCount, one);

        return classPtr;
    }

    // the archetypal example
    override ExprInfo info() { return ExprInfo(Ownership.gifted); }

    override void hash(Hash hash) { hash.adds("NewClassExpression"); classType.hash(hash); }
}

class ASTInstanceOf : ASTSymbol
{
    ASTSymbol base;

    ASTSymbol target;

    Loc loc;

    this(this.base, this.target, this.loc) { }

    override Symbol compile(Context context)
    {
        Expression base = beExpression3(context, this.base.compile(context), loc);
        auto type = base.type;
        loc.assert2s(!!type.instanceOf(Class), "Base of instanceOf must be a class.");
        Expression do_(Expression base) {
            Class target = target.compile(context).instanceOf(Class);
            loc.assert2s(!!target, "Target of instanceOf must be class.");
            Symbol instanceOf = context.compiler.accessMember(context, base, "__instanceof", loc, false);
            Expression classInfo = new ClassInfo(target);
            return new PointerCast(target,
                context.compiler.callWithLifetime(context, instanceOf, [classInfo], loc));
        }
        return context.compiler.exprWithTemporary(base, &do_);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTInstanceOf'"); assert(false); }
}

ASTSymbol parseInstanceOf(Parser parser, LexicalContext lexicalContext, ASTSymbol left)
{
    parser.begin;
    if (!(parser.accept(".") && parser.accept("instanceOf")))
    {
        parser.revert;
        return null;
    }
    parser.expect("(");
    ASTSymbol type = lexicalContext.compiler.parseType(parser, lexicalContext);
    parser.expect(")");
    parser.commit;
    return new ASTInstanceOf(left, type, parser.loc);
}

class ASTNewExpression : ASTSymbol
{
    ASTSymbol type;

    ASTSymbol[] args;

    Loc loc;

    this(this.type, this.args, this.loc) { }

    override Symbol compile(Context context)
    {
        Type type = beType(this.loc, this.type.compile(context));

        if (Class classType = type.instanceOf(Class)) {
            Expression classptr = new NewClassExpression(classType);

            auto argExpressions = [beExpression3(context, arg.compile(context), this.loc) for arg in this.args];
            this.loc.assert2s2(!!classType, "expected new <class>, not %s", type.repr);

            Expression do_(Expression classptr) {
                // don't clean up classptr after constructor call, we're continuing its lifetime
                auto ctor = context.compiler.accessMember(
                    context, new IgnoreLifetimeExpr(classptr), "__ctor", this.loc, false);
                auto ctorCall = context.compiler.exprStatement(
                    context.compiler.callWithLifetime(context, ctor, argExpressions, this.loc));

                return context.compiler.statementExpression(ctorCall, classptr);
            }
            return context.compiler.exprWithTemporary(classptr, &do_);
        }
        if (Array arrayType = type.instanceOf(Array)) {
            this.loc.assert2s(this.args.length == 1, "expected one argument to loc");

            Type sizeT = context.nativeWordType;
            auto length = expectImplicitConvertTo(
                context, beExpression3(context, this.args[0].compile(context), this.loc), sizeT, this.loc);
            return new ArrayAllocation(arrayType.elementType, length);
        }
        this.loc.assert2s2(false, "don't know how to allocate ", type.repr);
    }

    override ASTSymbol quote(Quoter quoter) {
        auto quotedArgs = [arg.quote(quoter) for arg in this.args];
        return quoter.compilerCall("astNewExpression", [
            this.type.quote(quoter),
            quoter.compiler.astArrayLiteral(quotedArgs, loc.reloc)], loc.reloc);
    }
}
