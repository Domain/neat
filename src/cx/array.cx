module cx.array;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser_base;
import cx.types;
import helpers;

/**
 * There are two things called "array": T[] and the data structure it references.
 * We will call the first an "array value" and the second the "array object".
 *
 * Array values have the following layout:
 * {
 *      size_t length;
 *      T* ptr;
 *      T* base;
 * }
 *
 * Array objects have the following layout:
 * {
 *      size_t references;
 *      size_t capacity; // total length
 * }
 * They are followed directly by the array data.
 */

int getArrayLen(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

class ArrayLength : Expression
{
    Expression arrayValue;

    Type type_;

    this(this.arrayValue, this.type_) { }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayLength"); this.arrayValue.hash(hash); }
}

int getArrayPtr(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 1);
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(this.elementType, this.arrayValue) { }

    override Type type()
    {
        return new Pointer(this.elementType);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayPointer"); this.arrayValue.hash(hash); }
}

int getArrayBase(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 2);
}

class ArrayBase : Expression
{
    Expression arrayValue;

    this(this.arrayValue) { }

    override Type type()
    {
        return new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayBase(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayBase"); this.arrayValue.hash(hash); }
}

int makeArray(Generator output, Type elementType, int lenReg, int ptrReg, int baseReg)
{
    BackendType structType = (new Array(elementType)).emit(output.platform);

    return output.fun.structLiteral(structType, new int[](0) ~ lenReg ~ ptrReg ~ baseReg);
}

// TODO use this as a basis for all array-allocating expressions
class ArrayAllocation : Expression
{
    Type elementType;

    Expression length;

    this(this.elementType, this.length) { }

    override Type type()
    {
        return new Array(this.elementType);
    }

    override int emit(Generator output)
    {
        auto size_t = output.platform.nativeWordType;
        auto voidp = output.platform.voidp();
        auto backendElementType = this.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, backendElementType.size(output.platform));
        int twoWordSizeReg = output.fun.wordLiteral(output.platform, size_t.size(output.platform) * 2);
        int oneReg = output.fun.wordLiteral(output.platform, 1);
        int twoReg = output.fun.wordLiteral(output.platform, 2);
        int arrayLength = this.length.emit(output);
        int arrayBytes = output.fun.binop("*", size_t, arrayLength, elementSizeReg);
        int totalArrayBytes = output.fun.binop("+", size_t, arrayBytes, twoWordSizeReg);
        int arrayBase = output.fun.call(voidp, "cxruntime_alloc", new int[](0) ~ totalArrayBytes);
        // ptr = base + 2
        int arrayPtr = output.fun.bitcast(output.fun.ptrOffset(size_t, arrayBase, twoReg), voidp);
        // base[0] = 1 (refs)
        // base[1] = allocated length (in elements)
        output.fun.store(size_t, output.fun.bitcast(arrayBase, new BackendPointerType(size_t)), oneReg);
        output.fun.store(size_t, output.fun.ptrOffset(size_t, arrayBase, oneReg), arrayLength);

        arrayPtr = output.fun.bitcast(arrayPtr, new BackendPointerType(backendElementType));
        return makeArray(output, this.elementType, arrayLength, arrayPtr, arrayBase);
    }

    override void hash(Hash hash) {
        hash.adds("ArrayAllocation");
        this.length.hash(hash);
    }
}

class ArraySlice : Expression
{
    Expression array;

    Expression lower;

    Expression upper;

    Loc loc;

    this(this.array, this.lower, this.upper, this.loc) { }

    override Type type() { return this.array.type(); }

    override int emit(Generator output)
    {
        BackendType voidp = output.platform.voidp();

        Array arrayType = this.array.type().instanceOf(Array);
        this.loc.assert2s(!!arrayType, "slice of non-array");
        auto elementType = arrayType.elementType.emit(output.platform);

        int arrayReg = this.array.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        int base = getArrayBase(output, arrayType, arrayReg);
        int ptr = getArrayPtr(output, arrayType, arrayReg);
        // ptr = ptr + lower
        int newPtr = output.fun.ptrOffset(elementType, ptr, lowerReg);
        // len = upper - lower
        int newLen = output.fun.binop(
            "-", output.platform.nativeWordType,
            upperReg, lowerReg);

        // TODO acquire ref
        return makeArray(output, arrayType.elementType, newLen, newPtr, base);
    }

    override void hash(Hash hash) {
        hash.adds("ArraySlice");
        array.hash(hash);
        lower.hash(hash);
        upper.hash(hash);
    }
}

class ArrayEqual : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        auto voidp = output.platform.voidp();
        Array leftArray = this.left.type().instanceOf(Array);
        Array rightArray = this.right.type().instanceOf(Array);
        assert(leftArray && rightArray);
        // TODO temp expr once array properties work on nonreferences
        assert(leftArray.same(rightArray));
        int left = this.left.emit(output);
        int right = this.right.emit(output);
        int leftLen = getArrayLen(output, leftArray, left);
        int rightLen = getArrayLen(output, rightArray, right);
        int leftPtr = output.fun.bitcast(getArrayPtr(output, leftArray, left), voidp);
        int rightPtr = output.fun.bitcast(getArrayPtr(output, rightArray, right), voidp);
        int leftSize = output.fun.wordLiteral(
            output.platform,
            leftArray.elementType.emit(output.platform).size(output.platform));
        return output.fun.call(new BackendIntType, "_arraycmp", new int[](0)
            ~ leftPtr ~ rightPtr ~ leftLen ~ rightLen ~ leftSize);
    }

    override void hash(Hash hash) { hash.adds("ArrayEqual"); left.hash(hash); right.hash(hash); }
}

/**
 * Note: does not call constructors/destructors!
 */
class ArrayResize : Expression
{
    Expression array;

    // positive offset
    Expression lengthChange;

    Loc loc;

    this(this.array, this.lengthChange, this.loc) { }

    override Type type() {
        return this.array.type();
    }

    override int emit(Generator output)
    {
        // TODO simplify this?
        auto size_t = output.platform.nativeWordType;
        auto voidp = output.platform.voidp();
        int arrayReg = this.array.emit(output);
        Array arrayType = this.array.type().instanceOf(Array);
        this.loc.assert2s(!!arrayType, "ArrayResize called on non-array!");
        int arrayLen = getArrayLen(output, arrayType, arrayReg);
        int arrayPtr = getArrayPtr(output, arrayType, arrayReg);
        int lengthChangeReg = this.lengthChange.emit(output);
        auto elementType = arrayType.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, elementType.size(output.platform));
        int twoWordSizeReg = output.fun.wordLiteral(output.platform, size_t.size(output.platform) * 2);

        int oneReg = output.fun.wordLiteral(output.platform, 1);
        int twoReg = output.fun.wordLiteral(output.platform, 2);
        // newArrayLen = array.length + lengthChange
        int newArrayLen = output.fun.binop("+", size_t, arrayLen, lengthChangeReg);
        int oldSize = output.fun.binop("*", size_t, arrayLen, elementSizeReg);
        int newSize = output.fun.binop("*", size_t, newArrayLen, elementSizeReg);

        // reserve space for references, capacity
        int totalSize = output.fun.binop("+", size_t, newSize, twoWordSizeReg);

        int newArrayBase = output.fun.call(voidp, "cxruntime_alloc", new int[](0) ~ totalSize);
        // ptr = base + 2
        int newArrayPtr = output.fun.bitcast(output.fun.ptrOffset(size_t, newArrayBase, twoReg), voidp);

        // base[0] = 1 (refs)
        // base[1] = allocated length (in elements)
        output.fun.store(size_t, output.fun.bitcast(newArrayBase, new BackendPointerType(size_t)), oneReg);
        output.fun.store(size_t, output.fun.ptrOffset(size_t, newArrayBase, oneReg), newSize);

        arrayPtr = output.fun.bitcast(arrayPtr, voidp);

        // TODO copy ctors
        output.fun.call(voidp, "memcpy", new int[](0) ~ newArrayPtr ~ arrayPtr ~ oldSize);

        newArrayPtr = output.fun.bitcast(newArrayPtr, new BackendPointerType(elementType));

        return makeArray(output, arrayType.elementType, newArrayLen, newArrayPtr, newArrayBase);
    }

    override void hash(Hash hash) { hash.adds("ArrayResize"); array.hash(hash); lengthChange.hash(hash); }
}

class ASTArrayResize : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lengthChange;

    Loc loc;

    this(this.array, this.lengthChange, this.loc) { }

    override Expression compile(Context context) {
        auto arrayExpr = beExpression2(array.compile(context), loc);
        auto lengthChangeExpr = beExpression2(lengthChange.compile(context), loc);
        return new ArrayResize(arrayExpr, lengthChangeExpr, loc);
    }
}

ASTSymbol parseArrayResize(Parser parser, LexicalContext lexicalContext, ASTSymbol current)
{
    parser.begin();
    auto loc = parser.loc();
    if (!parser.accept(".") || !parser.accept("lengthen"))
    {
        parser.revert();
        return null;
    }
    parser.expect("(");
    ASTSymbol lengthChange = lexicalContext.compiler.parseExpression(parser, lexicalContext);
    if (!lengthChange) parser.fail("Length expression expected");
    parser.expect(")");
    parser.commit();
    return new ASTArrayResize(current, lengthChange, loc);
}

Expression arrayCat(Context context, Expression left, Expression right, Loc loc) {
    auto compiler = context.compiler;

    Array leftArray = left.type().instanceOf(Array);
    assert(!!leftArray);
    Argument[] args = new Argument[](0)
        ~ Argument(false, "left", leftArray) ~ Argument(false, "right", right.type());

    ASTStatement body_;
    auto leftArg = compiler.astIdentifier("left", loc);
    auto rightArg = compiler.astIdentifier("right", loc);
    if (leftArray.elementType.same(right.type())) {
        /**
         * TODO
         * body_ = compiler.$stmt {
         *   auto result = left.resize(left.length + 1);
         *   result[left.length] = right;
         *   return result;
         * };
         */
        auto declare = compiler.astDeclareVar("result",
            new ASTArrayResize(leftArg, compiler.astIntLiteral(1, loc), loc), loc);
        auto resultVar = compiler.astIdentifier("result", loc);
        auto assign = compiler.astAssign(
            compiler.astIndex(resultVar, compiler.astMember(leftArg, "length", loc), loc),
            rightArg, loc);
        auto ret = compiler.astReturn(resultVar, loc);
        body_ = compiler.astScope(new ASTStatement[](0) ~ declare ~ assign ~ ret, loc);
    } else {
        /**
         * TODO
         * body_ = compiler.$stmt {
         *   auto result = left.resize(right.length);
         *   for (int i = 0; i < right.length; i += 1)
         *     result[left.length + i] = right[i];
         *   return result;
         * };
         */
        auto declare = compiler.astDeclareVar("result",
            new ASTArrayResize(leftArg, compiler.astMember(rightArg, "length", loc), loc), loc);
        auto result = compiler.astIdentifier("result", loc);
        auto init = compiler.astDeclareVar("i", compiler.astIntLiteral(0, loc), loc);
        auto i = compiler.astIdentifier("i", loc);
        auto test = compiler.astBinaryOp("<", i, compiler.astMember(rightArg, "length", loc), loc);
        auto step = compiler.astAssign(
            i, compiler.astBinaryOp("+", i, compiler.astIntLiteral(1, loc), loc), loc);
        auto loopLeft = compiler.astIndex(result,
            compiler.astBinaryOp("+", compiler.astMember(leftArg, "length", loc), i, loc), loc);
        auto loopRight = compiler.astIndex(rightArg, i, loc);
        auto loopBody = compiler.astAssign(loopLeft, loopRight, loc);
        auto loop = compiler.astForLoop(init, test, step, loopBody, loc);
        auto ret = compiler.astReturn(result, loc);

        body_ = compiler.astScope(new ASTStatement[](0) ~ declare ~ loop ~ ret, loc);
    }
    auto fn = compiler.createRuntimeFunction(context, "arrayappend", leftArray, args, body_);

    return compiler.call(fn, new Expression[](0) ~ left ~ right, loc);
}
