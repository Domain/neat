module cx.array;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser_base;
import cx.types;
import helpers;

/**
 * There are two things called "array": T[] and the data structure it references.
 * We will call the first an "array value" and the second the "array object".
 *
 * Array values have the following layout:
 * {
 *      size_t length;
 *      T* ptr;
 *      T* base;
 * }
 *
 * Array objects have the following layout:
 * {
 *      size_t references;
 *      size_t capacity; // total length
 * }
 * They are followed directly by the array data.
 */

int getArrayLen(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

class ArrayLength : Expression
{
    Expression arrayValue;

    Type type_;

    this(this.arrayValue, this.type_) { }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayLength"); this.arrayValue.hash(hash); }
}

int getArrayPtr(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 1);
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(this.elementType, this.arrayValue) { }

    override Type type()
    {
        return new Pointer(this.elementType);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayPointer"); this.arrayValue.hash(hash); }
}

int getArrayBase(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 2);
}

class ArrayBase : Expression
{
    Expression arrayValue;

    this(this.arrayValue) { }

    override Type type()
    {
        return new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayBase(output, this.arrayValue.type(), arrayReg);
    }

    override void hash(Hash hash) { hash.adds("ArrayBase"); this.arrayValue.hash(hash); }
}

int makeArray(Generator output, Type elementType, int lenReg, int ptrReg)
{
    BackendType elemp = (new Pointer(elementType)).emit(output.platform);
    BackendType wordType = output.platform.nativeWordType;

    // TODO allocaless
    BackendType structType = (new Array(elementType)).emit(output.platform);
    auto stack = output.fun.saveStack();
    int structReg = output.fun.alloca(structType);
    int zeroReg = output.fun.load(output.platform.voidp(), output.fun.alloca(output.platform.voidp())); // hax
    int lenField = output.fun.fieldOffset(structType, structReg, 0);
    int ptrField = output.fun.fieldOffset(structType, structReg, 1);
    int baseField;
    if (output.platform.newArrays)
        baseField = output.fun.fieldOffset(structType, structReg, 2);

    output.fun.store(wordType, lenField, lenReg);
    output.fun.store(elemp, ptrField, ptrReg);
    if (output.platform.newArrays)
        output.fun.store(output.platform.voidp(), baseField, zeroReg);
    auto ret = output.fun.load(structType, structReg);
    output.fun.restoreStack(stack);
    return ret;
}

class ArrayExpression : Expression
{
    Expression pointer;

    Expression length;

    this(this.pointer, this.length) { }

    override Type type()
    {
        Pointer ptrType = this.pointer.type().instanceOf(Pointer);
        assert(!!ptrType);
        return new Array(ptrType.target);
    }

    override int emit(Generator output)
    {
        int pointer = this.pointer.emit(output);
        int length = this.length.emit(output);

        return makeArray(output, this.type().instanceOf(Array).elementType, length, pointer);
    }

    override void hash(Hash hash) {
        hash.adds("ArrayExpression");
        this.pointer.hash(hash);
        this.length.hash(hash);
    }
}

class ArraySlice : Expression
{
    Expression array;

    Expression lower;

    Expression upper;

    Loc loc;

    this(this.array, this.lower, this.upper, this.loc) { }

    override Type type() { return this.array.type(); }

    override int emit(Generator output)
    {
        BackendType voidp = output.platform.voidp();

        Array arrayType = this.array.type().instanceOf(Array);
        this.loc.assert2s(!!arrayType, "slice of non-array");
        auto elementType = arrayType.elementType.emit(output.platform);

        int arrayReg = this.array.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        int ptr = getArrayPtr(output, arrayType, arrayReg);
        // ptr = ptr + lower
        int newPtr = output.fun.ptrOffset(elementType, ptr, lowerReg);
        // len = upper - lower
        int newLen = output.fun.binop(
            "-", output.platform.nativeWordType,
            upperReg, lowerReg);

        return makeArray(output, arrayType.elementType, newLen, newPtr);
    }

    override void hash(Hash hash) {
        hash.adds("ArraySlice");
        array.hash(hash);
        lower.hash(hash);
        upper.hash(hash);
    }
}

class ArrayEqual : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        Array leftArray = this.left.type().instanceOf(Array);
        Array rightArray = this.right.type().instanceOf(Array);
        assert(leftArray && rightArray);
        // TODO temp expr once array properties work on nonreferences
        assert(leftArray.same(rightArray));
        int left = this.left.emit(output);
        int right = this.right.emit(output);
        int leftLen = getArrayLen(output, leftArray, left);
        int rightLen = getArrayLen(output, rightArray, right);
        int leftPtr = getArrayPtr(output, leftArray, left);
        int rightPtr = getArrayPtr(output, rightArray, right);
        int leftSize = output.fun.wordLiteral(
            output.platform,
            leftArray.elementType.emit(output.platform).size(output.platform));
        return output.fun.call(new BackendIntType, "_arraycmp", new int[](0)
            ~ leftPtr ~ rightPtr ~ leftLen ~ rightLen ~ leftSize);
    }

    override void hash(Hash hash) { hash.adds("ArrayEqual"); left.hash(hash); right.hash(hash); }
}

class ArrayCat : Expression
{
    Expression left;

    Expression right;

    Loc loc;

    this(this.left, this.right, this.loc) { }

    override Type type() {
        Array leftArray = this.left.type().instanceOf(Array);
        this.loc.assert2s(!!leftArray, "left type is not an array");
        Array rightArray = this.right.type().instanceOf(Array);
        this.loc.assert2s(
            this.right.type().same(leftArray.elementType)
            || rightArray && rightArray.same(leftArray),
            "right array is incompatible with left"
        );

        return leftArray;
    }

    override int emit(Generator output)
    {
        // TODO simplify this?
        BackendType voidp = (new Pointer(new Void)).emit(output.platform);
        int leftReg = this.left.emit(output);
        Array leftType = this.left.type().instanceOf(Array);
        this.loc.assert2s(!!leftType, "left expression is not an array");
        Type rightType = this.right.type();
        int leftLen = getArrayLen(output, leftType, leftReg);
        int leftPtr = getArrayPtr(output, leftType, leftReg);
        leftPtr = output.fun.bitcast(leftPtr, voidp);
        auto leftElementType = leftType.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, leftElementType.size(output.platform));
        if (leftType.elementType.same(rightType))
        {
            // newLen = array.length + 1
            int newLen = output.fun.binop(
                "+", output.platform.nativeWordType,
                leftLen, output.fun.wordLiteral(output.platform, 1));
            int oldSize = output.fun.binop(
                "*", output.platform.nativeWordType,
                leftLen, elementSizeReg);
            int newSize = output.fun.binop(
                "*", output.platform.nativeWordType,
                newLen, elementSizeReg);

            int newArrayPtr = output.fun.call(voidp, "cxruntime_alloc", new int[](0) ~ newSize);
            output.fun.call(voidp, "memcpy", new int[](0) ~ newArrayPtr ~ leftPtr ~ oldSize);
            // *(ptr + prevLength) = right;
            int newElement = output.fun.ptrOffset(leftElementType, newArrayPtr, leftLen);
            output.fun.store(this.right.type().emit(output.platform), newElement, this.right.emit(output));

            // return ptr[0 .. prevLength + 1];
            int newArrayLen = output.fun.binop(
                "+", output.platform.nativeWordType,
                leftLen, output.fun.wordLiteral(output.platform, 1));

            newArrayPtr = output.fun.bitcast(newArrayPtr, new BackendPointerType(leftElementType));
            return makeArray(output, leftType.elementType, newArrayLen, newArrayPtr);
        }
        if (leftType.same(rightType))
        {
            auto rightReg = this.right.emit(output);
            auto rightLen = getArrayLen(output, rightType, rightReg);
            auto rightPtr = getArrayPtr(output, rightType, rightReg);
            rightPtr = output.fun.bitcast(rightPtr, voidp);
            auto newArrayLen = output.fun.binop("+", output.platform.nativeWordType, leftLen, rightLen);
            auto leftBytes = output.fun.binop("*", output.platform.nativeWordType, leftLen, elementSizeReg);
            auto rightBytes = output.fun.binop("*", output.platform.nativeWordType, rightLen, elementSizeReg);
            // size = sizeof(T) * (left.length + right.length)
            auto newBytes = output.fun.binop("+", output.platform.nativeWordType, leftBytes, rightBytes);

            auto voidp = (new Pointer(new Void)).emit(output.platform);
            auto newArrayPtr = output.fun.call(voidp, "cxruntime_alloc", new int[](0) ~ newBytes);
            // write left at 0
            output.fun.call(voidp, "memcpy", new int[](0) ~ newArrayPtr ~ leftPtr ~ leftBytes);
            // write right at ptr + leftLen
            auto startRightPtr = output.fun.ptrOffset(leftElementType, newArrayPtr, leftLen);
            startRightPtr = output.fun.bitcast(startRightPtr, output.platform.voidp());
            output.fun.call(voidp, "memcpy", new int[](0) ~ startRightPtr ~ rightPtr ~ rightBytes);

            newArrayPtr = output.fun.bitcast(newArrayPtr, new BackendPointerType(leftElementType));
            return makeArray(output, leftType.elementType, newArrayLen, newArrayPtr);
        }
        this.loc.assert2s(false, "left and right types don't match");
    }

    override void hash(Hash hash) { hash.adds("ArrayCat"); left.hash(hash); right.hash(hash); }
}
