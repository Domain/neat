module cx.array;

macro import cx.macros.either;
macro import cx.macros.hash;
macro import cx.macros.quasiquoting;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser_base;
import cx.types;
import helpers;

/**
 * There are two things called "array": T[] and the data structure it references.
 * We will call the first an "array value" and the second the "array object".
 *
 * Array values have the following layout:
 * {
 *      size_t length;
 *      T* ptr;
 *      T* base;
 * }
 *
 * Array objects have the following layout:
 * {
 *      size_t references;
 *      size_t capacity; // total length
 *      size_t used; // length in use (used for realloc)
 * }
 * They are then followed directly by the array data.
 */
class Array : Type
{
    Type elementType;

    BackendType backendType;

    this(this.elementType) { }

    override BackendType emit(Platform platform)
    {
        if (!this.backendType)
        {
            BackendType[] types;
            types = new BackendType[](3);
            types[0] = platform.nativeWordType;
            types[1] = new BackendPointerType(this.elementType.emit(platform));
            types[2] = platform.voidp();
            this.backendType = new BackendStructType(types);
        }
        return this.backendType;
    }

    override bool same(Type other)
    {
        Array otherArray = other.instanceOf(Array);

        return otherArray && otherArray.elementType.same(this.elementType);
    }

    override string repr() { return this.elementType.repr() ~ "[]"; }

    override string mangle() { return "array_" ~ this.elementType.mangle(); }

    override void hash(Hash hash) { hash.adds("array"); this.elementType.hash(hash); }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        Statement assign(Expression source) {
            auto context = context.withNamespace(context.compiler.exprAlias(context.namespace, "source", source));
            // count up reference
            auto stmt = compiler.$stmt if (source.base) *cast(size_t*) source.base += 1;;
            auto result = stmt.compile(context);
            return compiler.sequenceStatement([
                result.statement,
                compiler.assignStatement(target, source)]);
        }
        return compiler.stmtWithTemporary(source, &assign);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        return context.compiler.exprStatement(releaseArray(context, reference));
    }

    override Symbol accessMember(Context context, Expression base, string field)
    {
        if (field == "length")
            return new ArrayLength(base, nativeWordType(context.platform));
        if (field == "ptr")
            return new ArrayPointer(this.elementType, base);
        if (field == "base")
            return new ArrayBase(base);
        return null;
    }
}

class ASTArray : ASTType
{
    ASTType elementType;

    Loc loc;

    this(this.elementType, this.loc) { }

    override Type compile(Context context)
    {
        return new Array(this.elementType.compile(context));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astArray", [ elementType.quote(quoter) ], loc.reloc);
    }
}

int getArrayLen(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

class ArrayLength : Expression
{
    Expression arrayValue;

    Type type_;

    this(this.arrayValue, this.type_) { }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type(), arrayReg);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ArrayLength"); this.arrayValue.hash(hash); }
}

int getArrayPtr(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 1);
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(this.elementType, this.arrayValue) { }

    override Type type()
    {
        return new Pointer(this.elementType);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type(), arrayReg);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ArrayPointer"); this.arrayValue.hash(hash); }
}

int getArrayBase(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 2);
}

class ArrayBase : Expression
{
    Expression arrayValue;

    this(this.arrayValue) { }

    override Type type()
    {
        return new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayBase(output, this.arrayValue.type(), arrayReg);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ArrayBase"); this.arrayValue.hash(hash); }
}

int makeArray(Generator output, Type elementType, int lenReg, int ptrReg, int baseReg)
{
    BackendType structType = (new Array(elementType)).emit(output.platform);

    return output.fun.structLiteral(structType, [lenReg, ptrReg, baseReg]);
}

// TODO use this as a basis for all array-allocating expressions
class ArrayAllocation : Expression
{
    Type elementType;

    Either(Expression, size_t) length;

    this(this.elementType, this.length) { }

    override Type type()
    {
        return new Array(this.elementType);
    }

    override int emit(Generator output)
    {
        auto backendSizeT = output.platform.nativeWordType;
        auto voidp = output.platform.voidp();
        auto backendElementType = this.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, backendElementType.size(output.platform));
        int threeWordSizeReg = output.fun.wordLiteral(output.platform, backendSizeT.size(output.platform) * 3);
        int oneReg = output.fun.wordLiteral(output.platform, 1);
        int twoReg = output.fun.wordLiteral(output.platform, 2);
        int threeReg = output.fun.wordLiteral(output.platform, 3);
        int arrayLength = this.length.case(
            Expression ex: ex.emit(output),
            size_t sz: output.fun.wordLiteral(output.platform, sz));
        int arrayBytes = output.fun.binop("*", backendSizeT, arrayLength, elementSizeReg);
        int totalArrayBytes = output.fun.binop("+", backendSizeT, arrayBytes, threeWordSizeReg);
        int arrayBase = output.fun.call(voidp, "cxruntime_alloc", [totalArrayBytes]);
        // ptr = base + 2
        int arrayPtr = output.fun.bitcast(output.fun.ptrOffset(backendSizeT, arrayBase, threeReg), voidp);
        // base[0] = refs (1)
        // base[1] = allocated length (in elements)
        // base[2] = used length (in elements, inited to allocated length)
        output.fun.store(backendSizeT, output.fun.bitcast(arrayBase, new BackendPointerType(backendSizeT)), oneReg);
        output.fun.store(backendSizeT, output.fun.ptrOffset(backendSizeT, arrayBase, oneReg), arrayLength);
        output.fun.store(backendSizeT, output.fun.ptrOffset(backendSizeT, arrayBase, twoReg), arrayLength);

        arrayPtr = output.fun.bitcast(arrayPtr, new BackendPointerType(backendElementType));
        return makeArray(output, this.elementType, arrayLength, arrayPtr, arrayBase);
    }

    override void hash(Hash hash) {
        hash.adds("ArrayAllocation");
        this.length.case {
            Expression ex: ex.hash(hash);
            size_t sz: hash.addl(sz);
        }
    }

    override ExprInfo info() { return ExprInfo(Ownership.gifted); }
}

class ArraySlice : Expression
{
    Expression base;

    Expression lower;

    Expression upper;

    Loc loc;

    Array arrayType;

    this(this.base, this.lower, this.upper, this.loc) {
        auto baseType = this.base.type();
        if (baseType.instanceOf(Array)) {
            this.arrayType = baseType.instanceOf(Array);
        } else if (baseType.instanceOf(Pointer)) {
            this.arrayType = new Array(baseType.instanceOf(Pointer).target);
        } else {
            this.loc.assert2s(false, "slice of non-array/non-pointer");
        }
    }

    override Type type() { return this.arrayType; }

    override int emit(Generator output)
    {
        BackendType voidp = output.platform.voidp();

        auto elementType = this.arrayType.elementType.emit(output.platform);

        int baseReg = this.base.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        int base, ptr;
        if (this.base.type().instanceOf(Array)) {
            base = getArrayBase(output, this.arrayType, baseReg);
            ptr = getArrayPtr(output, this.arrayType, baseReg);
        } else {
            base = output.fun.bitcast(output.fun.wordLiteral(output.platform, 0), voidp);
            ptr = baseReg;
        }
        // ptr = ptr + lower
        int newPtr = output.fun.ptrOffset(elementType, ptr, lowerReg);
        // len = upper - lower
        int newLen = output.fun.binop(
            "-", output.platform.nativeWordType,
            upperReg, lowerReg);

        // TODO acquire ref
        return makeArray(output, this.arrayType.elementType, newLen, newPtr, base);
    }

    override ExprInfo info() { return base.info(); }

    override void hash(Hash hash) {
        hash.adds("ArraySlice");
        base.hash(hash);
        lower.hash(hash);
        upper.hash(hash);
    }
}

class ArrayEqual : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        auto voidp = output.platform.voidp();
        Array leftArray = this.left.type().instanceOf(Array);
        Array rightArray = this.right.type().instanceOf(Array);
        assert(leftArray && rightArray);
        // TODO temp expr once array properties work on nonreferences
        assert(leftArray.same(rightArray));
        int left = this.left.emit(output);
        int right = this.right.emit(output);
        int leftLen = getArrayLen(output, leftArray, left);
        int rightLen = getArrayLen(output, rightArray, right);
        int leftPtr = output.fun.bitcast(getArrayPtr(output, leftArray, left), voidp);
        int rightPtr = output.fun.bitcast(getArrayPtr(output, rightArray, right), voidp);
        int leftSize = output.fun.wordLiteral(
            output.platform,
            leftArray.elementType.emit(output.platform).size(output.platform));
        return output.fun.call(new BackendIntType, "_arraycmp", [leftPtr, rightPtr, leftLen, rightLen, leftSize]);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) { hash.adds("ArrayEqual"); left.hash(hash); right.hash(hash); }
}

Expression releaseArray(Context context, Expression value) {
    auto compiler = context.compiler;

    Array array = value.type().instanceOf(Array);
    assert(!!array);
    Argument[] args = [Argument(false, "value", array)];

    ASTStatement body_()
    {
        return compiler.$stmt {
            if (!value.base) return;
            size_t* refs = cast(size_t*) value.base;
            if (*refs <= 0) {
                cxruntime_refcount_violation("array release", refs);
                // assert(false);
            }
            *refs -= 1;
            if (*refs != 0) return;
            for (int i = 0; i < value.length; i += 1) {
                __destroy(value[i]);
            }
            free(value.base);
        };
    }

    auto fn = compiler.createRuntimeFunction(context, "arrayrelease", new Void, args, &body_);

    Loc nowhere;
    return compiler.call(fn, [value], nowhere);
}

Expression arrayCat(Context context, Expression left, Expression right, Loc loc) {
    auto compiler = context.compiler;

    Array leftArray = left.type().instanceOf(Array);
    assert(!!leftArray);
    Argument[] args = [Argument(false, "left", leftArray), Argument(false, "right", right.type())];

    ASTStatement body_() {
        if (leftArray.elementType.same(right.type())) {
            return compiler.$stmt {
                if (left.base) {
                    size_t prevCap = (cast(size_t*) left.base)[1];
                    size_t* prevUsed = &(cast(size_t*) left.base)[2];
                    auto prevFrontier = &(cast(typeof(left.ptr)) &(cast(size_t*) left.base)[3])[*prevUsed];
                    if (&left.ptr[left.length] is prevFrontier && *prevUsed < prevCap) {
                        *prevUsed += 1;
                        prevFrontier[0] = right;
                        return left[0 .. $ + 1];
                    }
                }
                auto result = new typeof(left)(left.length * 2 + 1);
                for (size_t i = 0; i < left.length; i += 1)
                    result[i] = left[i];
                result[left.length] = right;
                // used
                (cast(size_t*) result.base)[2] = left.length + 1;
                return result[0 .. left.length + 1];
            };
        } else if (leftArray.same(right.type())) {
            return compiler.$stmt {
                auto newLength = left.length + right.length;
                if (left.base) {
                    size_t prevCap = (cast(size_t*) left.base)[1];
                    size_t* prevUsed = &(cast(size_t*) left.base)[2];
                    auto prevFrontier = &(cast(typeof(left.ptr)) &(cast(size_t*) left.base)[3])[*prevUsed];
                    if (&left.ptr[left.length] is prevFrontier && *prevUsed + right.length <= prevCap) {
                        *prevUsed += right.length;
                        for (size_t i = 0; i < right.length; i += 1)
                            prevFrontier[i] = right[i];
                        return left[0 .. newLength];
                    }
                }
                auto result = new typeof(left)(left.length * 2 + right.length);
                for (size_t i = 0; i < left.length; i += 1)
                    result[i] = left[i];
                for (size_t i = 0; i < right.length; i += 1)
                    result[left.length + i] = right[i];
                (cast(size_t*) result.base)[2] = newLength;
                return result[0 .. newLength];
            };
        } else {
            loc.fail("incompatible types for concat: " ~ leftArray.repr() ~ " and " ~ right.type().repr());
        }
    }
    auto fn = compiler.createRuntimeFunction(context, "arrayappend", leftArray, args, &body_);

    return compiler.callWithLifetime(context, fn, [left, right], loc);
}

ASTSymbol parseArrayLiteral(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    auto loc = parser.loc();
    if (!parser.accept("[")) {
        parser.revert();
        return null;
    }
    ASTArrayLiteralElement[] values;
    while (!parser.accept("]")) {
        auto loc = parser.loc();
        ASTSymbol value = lexicalContext.compiler.parseExpression(parser, lexicalContext);
        values ~= ASTArrayLiteralElement(value, loc);
        parser.accept(",");
    }
    parser.commit();
    return new ASTArrayLiteral(values);
}

// marker: type that converts to any array type.
// type of [].
class EmptyArrayType : Type
{
    this() { }

    override BackendType emit(Platform platform) {
        assert(false);
    }

    override bool same(Type other) {
        return !!other.instanceOf(EmptyArrayType);
    }

    override Expression implicitConvertTo(Context context, Expression source, Type target)
    {
        if (target.instanceOf(Array)) {
            return new EmptyArrayLiteral(target);
        }
        return null;
    }

    override string repr() { return "typeof([])"; }

    override void hash(Hash hash) { hash.adds("EmptyArrayType"); }
}

class EmptyArrayLiteral : Expression
{
    Type type_; // may be null

    this(this.type_) { }

    override Type type() {
        if (type_) return type_;
        return new EmptyArrayType;
    }

    override int emit(Generator generator) {
        assert(!!this.type_);
        auto elementType = this.type_.instanceOf(Array).elementType;
        auto voidp = generator.platform.voidp();
        auto elementp = new BackendPointerType(elementType.emit(generator.platform));

        int len = generator.fun.wordLiteral(generator.platform, 0);
        int ptr = generator.fun.bitcast(generator.fun.intLiteral(0), elementp);
        int base = generator.fun.bitcast(generator.fun.intLiteral(0), voidp);

        return makeArray(generator, elementType, len, ptr, base);
    }

    override ExprInfo info() { return ExprInfo(Ownership.owned); }

    override void hash(Hash hash) {
        hash.adds("EmptyArrayLiteral");
        assert(!!this.type_);
        this.type_.hash(hash);
    }
}

struct ASTArrayLiteralElement
{
    ASTSymbol value;

    Loc loc;
}

class ASTArrayLiteral : ASTSymbol
{
    ASTArrayLiteralElement[] elements;

    this(this.elements) { }

    override Expression compile(Context context) {
        if (!elements.length)
            return new EmptyArrayLiteral(null);
        Expression[] values;
        for (int i = 0; i < this.elements.length; i += 1) {
            values ~= beExpression2(this.elements[i].value.compile(context), this.elements[i].loc);
        }
        Expression mergedReference;
        for (int i = 0; i < this.elements.length; i += 1) {
            if (!mergedReference) mergedReference = values[i];
            else {
                // TODO centralize somewhere
                auto value = values[i];
                auto left = context.compiler.implicitConvertTo(context, value, mergedReference.type());
                auto right = context.compiler.implicitConvertTo(context, mergedReference, value.type());
                if (!left && !right)
                    this.elements[i].loc.assert2s(false, "incompatible expression type");
                else if (left && right && !left.type().same(right.type()))
                    this.elements[i].loc.assert2s(false, "ambiguous expression type");
                if (left) mergedReference = left;
                else if (right) mergedReference = right;
            }
        }
        auto mergeType = mergedReference.type();
        for (int i = 0; i < this.elements.length; i += 1) {
            assert(!!values[i]);
            values[i] = context.compiler.implicitConvertTo(context, values[i], mergeType);
            assert(!!values[i]);
        }
        auto target = new ArrayAllocation(mergeType, values.length);
        Expression do_(Expression target) {
            Statement[] moves;
            auto base = new ArrayPointer(mergeType, target);
            for (int i = 0; i < values.length; i += 1) {
                auto target = context.compiler.dereference(
                    context.compiler.pointerOffset(base, context.compiler.intLiteral(i)));
                moves ~= context.compiler.move(context, target, values[i]);
            }
            return context.compiler.statementExpression(
                context.compiler.sequenceStatement(moves), target);
        }
        return context.compiler.exprWithTemporary(target, &do_);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTArrayLiteral'"); assert(false); }
}

/**
 * $ for length in an array index context.
 */
class ASTArrayLength : ASTSymbol
{
    ReLoc reloc;

    this(this.reloc) { }

    override Symbol compile(Context context) {
        auto loc = Loc(context.compiler.linenr, reloc);

        auto surroundingArraySymbol = context.compiler.lookup(context, "__array");
        loc.assert2s(
            surroundingArraySymbol && surroundingArraySymbol.instanceOf(Expression),
            "'$' can only be used inside an array index context");

        return new ArrayLength(
            surroundingArraySymbol.instanceOf(Expression),
            nativeWordType(context.platform));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compiler.astNewExpression(
            quoter.compiler.astNamedType("ASTArrayLength", reloc), [
                quoter.quoteReloc(reloc)], reloc);
    }
}
