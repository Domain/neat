module cx.array;

macro import cx.macros.either;
macro import cx.macros.hash;
macro import cx.macros.quasiquoting;

import backend.base;
import cx.base;
import cx.hash;
import cx.parser_base;
import cx.types;
import helpers;

/**
 * There are two things called "array": T[] and the data structure it references.
 * We will call the first an "array value" and the second the "array object".
 *
 * Array values have the following layout:
 * {
 *      size_t length;
 *      T* ptr;
 *      T* base;
 * }
 *
 * Array objects have the following layout:
 * {
 *      size_t references;
 *      size_t capacity; // total length
 * }
 * They are followed directly by the array data.
 */
class Array : Type
{
    Type elementType;

    this(this.elementType) { }

    override BackendType emit(Platform platform)
    {
        BackendType[] types;
        types = new BackendType[](3);
        types[0] = platform.nativeWordType;
        types[1] = new BackendPointerType(this.elementType.emit(platform));
        types[2] = platform.voidp();
        return new BackendStructType(types);
    }

    override bool same(Type other)
    {
        Array otherArray = other.instanceOf(Array);

        return otherArray && otherArray.elementType.same(this.elementType);
    }

    override string repr() { return this.elementType.repr() ~ "[]"; }

    override string mangle() { return "array_" ~ this.elementType.mangle(); }

    override void hash(Hash hash) { hash.adds("array"); this.elementType.hash(hash); }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        Statement assign(Expression source) {
            context = context.withNamespace(context.compiler.exprAlias(context.namespace, "source", source));
            // count up reference
            auto stmt = compiler.$stmt if (source.base) *cast(size_t*) source.base += 1;;
            auto result = stmt.compile(context);
            return compiler.sequenceStatement([
                result.statement,
                compiler.assignStatement(target, source)]);
        }
        return compiler.stmtWithTemporary(source, &assign);
    }

    override Statement endLifetime(Context context, Reference reference)
    {
        return context.compiler.exprStatement(releaseArray(context, reference));
    }
}

class ASTArray : ASTType
{
    ASTType elementType;

    Loc loc;

    this(this.elementType, this.loc) { }

    override Type compile(Context context)
    {
        return new Array(this.elementType.compile(context));
    }

    override ASTSymbol quote(Quoter quoter) {
        return quoter.compilerCall("astArray", [ elementType.quote(quoter) ], loc.reloc);
    }
}

int getArrayLen(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

class ArrayLength : Expression
{
    Expression arrayValue;

    Type type_;

    this(this.arrayValue, this.type_) { }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type(), arrayReg);
    }

    override bool temporary() { return false; }

    override void hash(Hash hash) { hash.adds("ArrayLength"); this.arrayValue.hash(hash); }
}

int getArrayPtr(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 1);
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(this.elementType, this.arrayValue) { }

    override Type type()
    {
        return new Pointer(this.elementType);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type(), arrayReg);
    }

    override bool temporary() { return false; }

    override void hash(Hash hash) { hash.adds("ArrayPointer"); this.arrayValue.hash(hash); }
}

int getArrayBase(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 2);
}

class ArrayBase : Expression
{
    Expression arrayValue;

    this(this.arrayValue) { }

    override Type type()
    {
        return new Pointer(new Void);
    }

    override int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayBase(output, this.arrayValue.type(), arrayReg);
    }

    override bool temporary() { return false; }

    override void hash(Hash hash) { hash.adds("ArrayBase"); this.arrayValue.hash(hash); }
}

int makeArray(Generator output, Type elementType, int lenReg, int ptrReg, int baseReg)
{
    BackendType structType = (new Array(elementType)).emit(output.platform);

    return output.fun.structLiteral(structType, [lenReg, ptrReg, baseReg]);
}

// TODO use this as a basis for all array-allocating expressions
class ArrayAllocation : Expression
{
    Type elementType;

    Either(Expression, size_t) length;

    this(this.elementType, this.length) { }

    override Type type()
    {
        return new Array(this.elementType);
    }

    override int emit(Generator output)
    {
        auto backendSizeT = output.platform.nativeWordType;
        auto voidp = output.platform.voidp();
        auto backendElementType = this.elementType.emit(output.platform);
        int elementSizeReg = output.fun.wordLiteral(output.platform, backendElementType.size(output.platform));
        int twoWordSizeReg = output.fun.wordLiteral(output.platform, backendSizeT.size(output.platform) * 2);
        int oneReg = output.fun.wordLiteral(output.platform, 1);
        int twoReg = output.fun.wordLiteral(output.platform, 2);
        int arrayLength = this.length.case(
            Expression ex: ex.emit(output),
            size_t sz: output.fun.wordLiteral(output.platform, sz));
        int arrayBytes = output.fun.binop("*", backendSizeT, arrayLength, elementSizeReg);
        int totalArrayBytes = output.fun.binop("+", backendSizeT, arrayBytes, twoWordSizeReg);
        int arrayBase = output.fun.call(voidp, "cxruntime_alloc", [totalArrayBytes]);
        // ptr = base + 2
        int arrayPtr = output.fun.bitcast(output.fun.ptrOffset(backendSizeT, arrayBase, twoReg), voidp);
        // base[0] = 1 (refs)
        // base[1] = allocated length (in elements)
        output.fun.store(backendSizeT, output.fun.bitcast(arrayBase, new BackendPointerType(backendSizeT)), oneReg);
        output.fun.store(backendSizeT, output.fun.ptrOffset(backendSizeT, arrayBase, oneReg), arrayLength);

        arrayPtr = output.fun.bitcast(arrayPtr, new BackendPointerType(backendElementType));
        return makeArray(output, this.elementType, arrayLength, arrayPtr, arrayBase);
    }

    override void hash(Hash hash) {
        hash.adds("ArrayAllocation");
        this.length.case {
            Expression ex: ex.hash(hash);
            size_t sz: hash.addl(sz);
        }
    }

    override bool temporary() { return true; }
}

class ArraySlice : Expression
{
    Expression array;

    Expression lower;

    Expression upper;

    Loc loc;

    this(this.array, this.lower, this.upper, this.loc) { }

    override Type type() { return this.array.type(); }

    override int emit(Generator output)
    {
        BackendType voidp = output.platform.voidp();

        Array arrayType = this.array.type().instanceOf(Array);
        this.loc.assert2s(!!arrayType, "slice of non-array");
        auto elementType = arrayType.elementType.emit(output.platform);

        int arrayReg = this.array.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        int base = getArrayBase(output, arrayType, arrayReg);
        int ptr = getArrayPtr(output, arrayType, arrayReg);
        // ptr = ptr + lower
        int newPtr = output.fun.ptrOffset(elementType, ptr, lowerReg);
        // len = upper - lower
        int newLen = output.fun.binop(
            "-", output.platform.nativeWordType,
            upperReg, lowerReg);

        // TODO acquire ref
        return makeArray(output, arrayType.elementType, newLen, newPtr, base);
    }

    override bool temporary() { return array.temporary(); }

    override void hash(Hash hash) {
        hash.adds("ArraySlice");
        array.hash(hash);
        lower.hash(hash);
        upper.hash(hash);
    }
}

class ArrayEqual : Expression
{
    Expression left;

    Expression right;

    this(this.left, this.right) { }

    override Type type() { return new Integer; }

    override int emit(Generator output)
    {
        auto voidp = output.platform.voidp();
        Array leftArray = this.left.type().instanceOf(Array);
        Array rightArray = this.right.type().instanceOf(Array);
        assert(leftArray && rightArray);
        // TODO temp expr once array properties work on nonreferences
        assert(leftArray.same(rightArray));
        int left = this.left.emit(output);
        int right = this.right.emit(output);
        int leftLen = getArrayLen(output, leftArray, left);
        int rightLen = getArrayLen(output, rightArray, right);
        int leftPtr = output.fun.bitcast(getArrayPtr(output, leftArray, left), voidp);
        int rightPtr = output.fun.bitcast(getArrayPtr(output, rightArray, right), voidp);
        int leftSize = output.fun.wordLiteral(
            output.platform,
            leftArray.elementType.emit(output.platform).size(output.platform));
        return output.fun.call(new BackendIntType, "_arraycmp", [leftPtr, rightPtr, leftLen, rightLen, leftSize]);
    }

    override bool temporary() { return false; }

    override void hash(Hash hash) { hash.adds("ArrayEqual"); left.hash(hash); right.hash(hash); }
}

Expression releaseArray(Context context, Expression value) {
    auto compiler = context.compiler;

    Array array = value.type().instanceOf(Array);
    assert(!!array);
    Argument[] args = [Argument(false, "value", array)];

    ASTStatement body_ = compiler.$stmt {
        if (!value.base) return;
        *cast(size_t*) value.base -= 1;
        if (*cast(size_t*) value.base != 0) return;
        for (int i = 0; i < value.length; i += 1) {
            __destroy(value[i]);
        }
        // free(value.base);
    };

    auto fn = compiler.createRuntimeFunction(context, "arrayrelease", new Void, args, body_);

    Loc nowhere;
    return compiler.call(fn, [value], nowhere);
}

Expression arrayCat(Context context, Expression left, Expression right, Loc loc) {
    auto compiler = context.compiler;

    Array leftArray = left.type().instanceOf(Array);
    assert(!!leftArray);
    Argument[] args = [Argument(false, "left", leftArray), Argument(false, "right", right.type())];

    ASTStatement body_;
    if (leftArray.elementType.same(right.type())) {
        body_ = compiler.$stmt {
          auto result = new typeof(left)(left.length + 1);
          for (size_t i = 0; i < left.length; i += 1)
              result[i] = left[i];
          result[left.length] = right;
          return result;
        };
    } else if (leftArray.same(right.type())) {
        body_ = compiler.$stmt {
          auto result = new typeof(left)(left.length + right.length);
          for (size_t i = 0; i < left.length; i += 1)
              result[i] = left[i];
          for (size_t i = 0; i < right.length; i += 1)
            result[left.length + i] = right[i];
          return result;
        };
    } else {
        loc.fail("incompatible types for concat: " ~ leftArray.repr() ~ " and " ~ right.type().repr());
    }
    auto fn = compiler.createRuntimeFunction(context, "arrayappend", leftArray, args, body_);

    return compiler.call(fn, [left, right], loc);
}

ASTSymbol parseArrayLiteral(Parser parser, LexicalContext lexicalContext)
{
    parser.begin();
    auto loc = parser.loc();
    if (!parser.accept("[")) {
        parser.revert();
        return null;
    }
    ASTArrayLiteralElement[] values;
    while (!parser.accept("]")) {
        auto loc = parser.loc();
        ASTSymbol value = lexicalContext.compiler.parseExpression(parser, lexicalContext);
        values ~= ASTArrayLiteralElement(value, loc);
        parser.accept(",");
    }
    parser.commit();
    return new ASTArrayLiteral(values);
}

// marker: type that converts to any array type.
// type of [].
class EmptyArrayType : Type
{
    this() { }

    override BackendType emit(Platform platform) {
        assert(false);
    }

    override bool same(Type other) {
        return !!other.instanceOf(EmptyArrayType);
    }

    override Expression implicitConvertTo(Expression source, Type target)
    {
        if (target.instanceOf(Array)) {
            return new EmptyArrayLiteral(target);
        }
        return null;
    }

    override string repr() { return "typeof([])"; }

    override void hash(Hash hash) { hash.adds("EmptyArrayType"); }
}

class EmptyArrayLiteral : Expression
{
    Type type_; // may be null

    this(this.type_) { }

    override Type type() {
        if (type_) return type_;
        return new EmptyArrayType;
    }

    override int emit(Generator generator) {
        assert(!!this.type_);
        auto elementType = this.type_.instanceOf(Array).elementType;
        auto voidp = generator.platform.voidp();
        auto elementp = new BackendPointerType(elementType.emit(generator.platform));

        int len = generator.fun.wordLiteral(generator.platform, 0);
        int ptr = generator.fun.bitcast(generator.fun.intLiteral(0), elementp);
        int base = generator.fun.bitcast(generator.fun.intLiteral(0), voidp);

        return makeArray(generator, elementType, len, ptr, base);
    }

    override bool temporary() { return false; }

    override void hash(Hash hash) {
        hash.adds("EmptyArrayLiteral");
        assert(!!this.type_);
        this.type_.hash(hash);
    }
}

struct ASTArrayLiteralElement
{
    ASTSymbol value;

    Loc loc;
}

class ASTArrayLiteral : ASTSymbol
{
    ASTArrayLiteralElement[] elements;

    this(this.elements) { }

    override Expression compile(Context context) {
        if (!elements.length)
            return new EmptyArrayLiteral(null);
        Expression[] values;
        for (int i = 0; i < this.elements.length; i += 1) {
            values ~= beExpression2(this.elements[i].value.compile(context), this.elements[i].loc);
        }
        Expression mergedReference;
        for (int i = 0; i < this.elements.length; i += 1) {
            if (!mergedReference) mergedReference = values[i];
            else {
                // TODO centralize somewhere
                auto value = values[i];
                auto left = context.compiler.implicitConvertTo(value, mergedReference.type());
                auto right = context.compiler.implicitConvertTo(mergedReference, value.type());
                if (!left && !right)
                    this.elements[i].loc.assert2s(false, "incompatible expression type");
                else if (left && right && !left.type().same(right.type()))
                    this.elements[i].loc.assert2s(false, "ambiguous expression type");
                if (left) mergedReference = left;
                else if (right) mergedReference = right;
            }
        }
        auto mergeType = mergedReference.type();
        for (int i = 0; i < this.elements.length; i += 1) {
            assert(!!values[i]);
            values[i] = context.compiler.implicitConvertTo(values[i], mergeType);
            assert(!!values[i]);
        }
        return new ArrayLiteral(new Array(mergeType), values, context.compiler);
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTArrayLiteral'"); assert(false); }
}

class ArrayLiteral : Expression
{
    ArrayAllocation allocationHelper;

    Array type_;

    Expression[] values;

    this(this.type_, this.values, CompilerBase compiler) {
        allocationHelper = new ArrayAllocation(type_.elementType, this.values.length);
    }

    override Type type() {
        return this.type_;
    }

    override int emit(Generator output) {
        auto voidp = output.platform.voidp();
        auto backendElementType = this.type_.elementType.emit(output.platform);
        int arrayReg = allocationHelper.emit(output);
        int arrayPtr = getArrayPtr(output, type_, arrayReg);
        for (int i = 0; i < this.values.length; i += 1) {
            int elementPtrReg = output.fun.ptrOffset(backendElementType, arrayPtr, output.fun.intLiteral(i));
            int valueReg = this.values[i].emit(output);
            output.fun.store(backendElementType, elementPtrReg, valueReg);
        }
        return arrayReg;
    }

    override bool temporary() { return true; }

    override void hash(Hash hash) {
        hash.adds("ArrayLiteral");
        hash.addl(values.length);
        for (int i = 0; i < this.values.length; i += 1)
            values[i].hash(hash);
    }
}
