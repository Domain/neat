module cx.struct_;

import backend.base;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser_base;
import cx.statements;
import helpers;

class StructMemberDeclaration
{
    string name;

    Type type;

    this(this.name, this.type) { }
}

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    FunctionDeclaration[] methods;

    Loc loc;

    string mangledName;

    this(this.name, this.members, this.loc, string manglePrefix) {
        this.mangledName = manglePrefix ~ "_struct_" ~ this.name;
    }

    override bool same(Type other) {
        // TODO mangling
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct) return false;
        return this.name == otherStruct.name;
    }

    override BackendType emit(Platform platform)
    {
        auto memberTypes = new BackendType[](this.members.length);
        for (int i = 0; i < this.members.length; i += 1)
        {
            memberTypes[i] = this.members[i].type.emit(platform);
        }
        return new BackendStructType(memberTypes);
    }

    override string repr() { return this.name; }

    override string mangle() {
        return this.mangledName;
    }

    override void hash(Hash hash)
    {
        hash.adds("Struct");
        hash.adds(mangledName);
        hash.addl(members.length);
        for (int i = 0; i < members.length; i += 1)
            members[i].type.hash(hash);
    }

    FunctionDeclaration getDtor()
    {
        for (int i = 0; i < this.methods.length; i += 1) {
            if (this.methods[i].name == "__dtor") {
                return this.methods[i];
            }
        }
        return null;
    }

    /**
     * copy constructor is constructor that takes an arg of this struct.
     */
    FunctionDeclaration getCopyCtor()
    {
        for (int i = 0; i < this.methods.length; i += 1) {
            auto method = this.methods[i];
            if (method.name == "__ctor" && method.args.length == 1 && method.args[0].type.same(this)) {
                return method;
            }
        }
        return null;
    }

    Statement callAutoDtor(Context context, Reference ref_)
    {
        auto compiler = context.compiler;
        Loc nowhere;

        // Argument[] args = [Argument(false, "ptr", new Pointer(ref_.type()))];
        ASTSymbol ptr = compiler.astIdentifier("ptr", nowhere.reloc);

        ASTStatement[] calls;
        for (int i = 0; i < members.length; i += 1) {
            auto entry = members[i];
            auto member = new StructMemberReference(ref_, i);
            auto destroy = entry.type.endLifetime(context, member);
            if (destroy) {
                // calls ~= compiler.$stmt __destroy ptr.$name;;
                calls ~= compiler.astExpressionStmt(
                    compiler.astDestroy(
                        compiler.astMember(ptr, entry.name, nowhere.reloc), nowhere.reloc), nowhere.reloc);
            }
        }
        if (!calls.length) return null;
        ASTStatement body_ = compiler.astSequence(calls, nowhere.reloc);
        // auto fn = compiler.createRuntimeFunction(context, "structrelease", new Void, args, body_);
        // return compiler.call(fn, [compiler.reference(ref_)], loc);
        Statement do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ptr", refptr));

            return body_.compile(context).statement;
        }
        return context.compiler.stmtWithTemporary(compiler.reference(ref_), &do_);
    }

    Statement copyRecursive(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        Statement do1(Expression targetptr) {
            auto target = compiler.dereference(targetptr);
            Statement do2(Expression source) {
                Statement[] assigns;
                bool anySpecialAssignments;
                for (int i = 0; i < members.length; i += 1) {
                    auto targetField = new StructMemberReference(target, i);
                    auto sourceField = new StructMember(source, i);
                    auto copyInto = members[i].type.copyInto(context, targetField, sourceField);
                    if (copyInto) anySpecialAssignments = true;
                    if (!copyInto) copyInto = compiler.assignStatement(targetField, sourceField);
                    assigns ~= copyInto;
                }
                if (!anySpecialAssignments) return null;
                return compiler.sequenceStatement(assigns);
            }
            return context.compiler.stmtWithTemporary(source, &do2);
        }
        return context.compiler.stmtWithTemporary(compiler.reference(target), &do1);
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        FunctionDeclaration copyCtor = getCopyCtor();
        if (copyCtor) {
            Expression targetPtr = new ReferenceExpression(target);
            auto call = new Call(copyCtor, [targetPtr, source], this.loc);
            return new ExprStatement(call);
        }
        auto copyStmt = copyRecursive(context, target, source);
        if (copyStmt)
            return copyStmt;
        return null;
    }

    override Statement endLifetime(Context context, Reference ref_)
    {
        FunctionDeclaration destructor = getDtor();
        Expression ptr = new ReferenceExpression(ref_);
        Statement callDtor, callAutoDtor_ = callAutoDtor(context, ref_);
        if (destructor) callDtor = new ExprStatement(new Call(destructor, [ptr], this.loc));
        return sequence(callDtor, callAutoDtor_);
    }
}

class StructMember : Expression
{
    Expression base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type().instanceOf(Struct);
        assert(!!structType);
    }

    override Type type()
    {
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        return output.fun.field(structType.emit(output.platform), base.emit(output), cast(int) index);
    }

    override ExprInfo info() { return base.info(); }

    override void hash(Hash hash)
    {
        hash.adds("StructMember");
        base.hash(hash);
        hash.addl(index);
    }
}

class StructMemberReference : Reference
{
    Reference base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type().instanceOf(Struct);
        assert(!!structType);
    }

    override Type type()
    {
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type().emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type().emit(output.platform), reg, this.index);
    }

    override ExprInfo info() { return base.info(); }

    override void hash(Hash hash)
    {
        hash.adds("StructMemberReference");
        base.hash(hash);
        hash.addl(index);
    }
}
