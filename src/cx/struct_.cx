module cx.struct_;

macro import cx.macros.listcomprehension;

import backend.base;
import cx.base;
import cx.expr;
import cx.function_;
import cx.hash;
import cx.parser;
import cx.parser_base;
import cx.statements;
import cx.types;
import helpers;

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    FunctionDeclaration[] methods;

    Loc loc;

    string mangledName;

    Hash preHash;

    this(this.name, this.members, this.loc, string manglePrefix) {
        this.mangledName = manglePrefix ~ "_struct_" ~ this.name;
        this.preHash = new Hash;
        // hash methods?
        with (this.preHash) {
            adds("Struct");
            adds(mangledName);
            addl(members.length);
            [member.type.hash(this.preHash) for member in this.members];
        }
    }

    override bool same(Type other) {
        // TODO mangling
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct) return false;
        return this.name == otherStruct.name;
    }

    override BackendType emit(Platform platform)
    {
        auto memberTypes = new BackendType[](this.members.length);
        for (int i <- 0 .. this.members.length)
        {
            memberTypes[i] = this.members[i].type.emit(platform);
        }
        return new BackendStructType(memberTypes);
    }

    override string repr() { return this.name; }

    override string mangle() {
        return this.mangledName;
    }

    override Symbol accessMember(Loc loc, Context context, Expression baseExpr, string member) {
        size_t memberOffset = [first i for i, a in this.members where a.name == member else -1];
        if (memberOffset != -1) {
            if (baseExpr.instanceOf(Reference)) {
                return new StructMemberReference(baseExpr.instanceOf(Reference), memberOffset);
            }
            return new StructMember(baseExpr, memberOffset);
        }
        size_t methodOffset = [first i for i, a in this.methods where a.name == member else -1];
        if (methodOffset != -1)
        {
            // TODO dereference-into-symbol so we can '&' it again
            auto funcPtr = context.compiler.referenceFunction(this.methods[methodOffset]);
            loc.assert2s(!!baseExpr.instanceOf(Reference), "base of method call must be reference");
            return new ClassMethodPtr(funcPtr, new ReferenceExpression(baseExpr.instanceOf(Reference)));
        }
        return null;
    }

    override void hash(Hash hash)
    {
        hash.applyHash(preHash);
    }

    FunctionDeclaration getDtor()
    {
        return [first method for method in this.methods where method.name == "__dtor" else null];
    }

    /**
     * copy constructor is constructor that takes an arg of this struct.
     */
    FunctionDeclaration getCopyCtor()
    {
        return [first method for method in this.methods
            where method.name == "__ctor" && method.args.length == 1 && method.args[0].type.same(this)
            else null];
    }

    Statement callAutoDtor(Context context, Reference ref_)
    {
        auto compiler = context.compiler;
        Loc nowhere;

        // Argument[] args = [Argument(false, "ptr", new Pointer(ref_.type))];
        ASTSymbol ptr = compiler.astIdentifier("ptr", nowhere.reloc);

        mut ASTStatement[] calls;
        for (int i <- 0 .. members.length) {
            auto entry = members[i];
            auto member = new StructMemberReference(ref_, i);
            auto destroy = entry.type.endLifetime(context, member);
            if (destroy) {
                // calls ~= compiler.$stmt __destroy ptr.$name;;
                calls ~= compiler.astExpressionStmt(
                    compiler.astDestroy(
                        compiler.astMember(ptr, entry.name, nowhere.reloc), nowhere.reloc), nowhere.reloc);
            }
        }
        if (!calls.length) return null;
        ASTStatement body_ = compiler.astSequence(calls, nowhere.reloc);
        // auto fn = compiler.createRuntimeFunction(context, "structrelease", new Void, args, body_);
        // return compiler.call(fn, [compiler.reference(ref_)], loc);
        Statement do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ptr", refptr));

            return body_.compile(context).statement;
        }
        return context.compiler.stmtWithTemporaryExpr(compiler.reference(ref_), &do_);
    }

    Statement copyRecursive(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        Statement do1(Expression targetptr) {
            auto target = compiler.dereference(targetptr);
            Statement do2(Expression source) {
                mut Statement[] assigns;
                mut bool anySpecialAssignments;
                for (int i <- 0 .. members.length) {
                    auto targetField = new StructMemberReference(target, i);
                    auto sourceField = new StructMember(source, i);
                    mut auto copyInto = members[i].type.copyInto(context, targetField, sourceField);
                    if (copyInto) anySpecialAssignments = true;
                    if (!copyInto) copyInto = compiler.assignStatement(targetField, sourceField);
                    assigns ~= copyInto;
                }
                if (!anySpecialAssignments) return null;
                return compiler.sequenceStatement(assigns);
            }
            return context.compiler.stmtWithTemporaryExpr(source, &do2);
        }
        return context.compiler.stmtWithTemporaryExpr(compiler.reference(target), &do1);
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        FunctionDeclaration copyCtor = getCopyCtor;
        if (copyCtor) {
            Expression targetPtr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(target));
            auto call = new Call(copyCtor, [targetPtr, source], this.loc);
            return new ExprStatement(call);
        }
        auto copyStmt = copyRecursive(context, target, source);
        if (copyStmt)
            return copyStmt;
        return null;
    }

    override Statement endLifetime(Context context, Reference ref_)
    {
        FunctionDeclaration destructor = getDtor;
        Expression ptr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(ref_));
        mut Statement callDtor;
        if (destructor) callDtor = new ExprStatement(new Call(destructor, [ptr], this.loc));
        Statement callAutoDtor_ = callAutoDtor(context, ref_);
        return sequence(callDtor, callAutoDtor_);
    }
}

class StructMember : Expression
{
    Expression base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type.instanceOf(Struct);
        assert(!!structType);
        this.type = this.structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        return output.fun.field(structType.emit(output.platform), base.emit(output), cast(int) index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMember");
        base.hash(hash);
        hash.addl(index);
    }
}

class StructMemberReference : Reference
{
    Reference base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type.instanceOf(Struct);
        assert(!!this.structType);
        this.type = this.structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type.emit(output.platform), reg, this.index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMemberReference");
        base.hash(hash);
        hash.addl(index);
    }
}

struct ASTStructMethod
{
    Loc loc;

    string name;

    ASTSymbol ret;

    (ASTArgument | ASTThisAssignment)[] args;

    ASTStatement body_;
}

class StructNamespace : Namespace
{
    Struct struct_;

    this(this.parent, this.struct_) { this.isContextScope = true; }

    override Symbol lookup(string name, Context context, Expression thisPtr)
    {
        auto thisPtr = new PointerCast(new Pointer(this.struct_), thisPtr);

        if (auto result = context.compiler.accessMemberWithLifetime(
                context, thisPtr, name, Loc(null, ReLoc("", 0)), true))
            return result;

        // TODO "outer"?
        if (!this.parent) return null;
        return this.parent.lookup(name, context, null);
    }
}

class StructMethod : Function
{
    Loc loc;

    string mangledName;

    this(this.loc, Struct structType, Context context, this.name, this.ret, this.args, this.statement,
         this.macroState)
    {
        // TODO super()
        auto structNamespace = new StructNamespace(context.namespace, structType);
        auto ptr = new Pointer(structType);

        this.hasThisArg = true;
        this.contextType = ptr;
        this.parent = structNamespace;
        // TODO mangle types
        this.mangledName = this.parent.mangle ~ "_" ~ ptr.target.instanceOf(Struct).name ~ "_" ~ this.name;
    }

    override string mangle()
    {
        return mangledName;
    }
}

class ASTStructDecl : ASTSymbol
{
    string name;

    (string name, ASTSymbol type)[] members;

    ASTStructMethod[] methods;

    MacroState macroState;

    Loc loc;

    this(this.name, this.members, this.methods, this.macroState, this.loc) { }

    override Struct compile(Context context)
    {
        auto members = [
            new StructMemberDeclaration(member.name, beType(this.loc, member.type.compile(context)))
            for member in this.members];

        auto struct_ = new Struct(this.name, members, this.loc, context.namespace.mangle);
        // make S visible in struct S {}
        auto structScope = context.compiler.symbolAlias(context.namespace, struct_.name, struct_);
        auto structContext = context.withNamespace(structScope);

        struct_.methods = new FunctionDeclaration[](this.methods.length);
        for (int i <- 0 .. this.methods.length)
        {
            auto method = this.methods[i];
            auto methodArgs = new Argument[](method.args.length);

            for (int k <- 0 .. method.args.length) {
                method.args[k].case {
                    ASTArgument arg:
                        methodArgs[k] = Argument(
                            false, arg.name, arg.mutable, beType(arg.loc, arg.type.compile(structContext)));
                    ASTThisAssignment arg:
                        assert(false); // TODO this.foo
                }
            }

            struct_.methods[i] = new StructMethod(
                method.loc,
                struct_,
                context,
                method.name,
                beType(this.loc, method.ret.compile(structContext)),
                methodArgs,
                method.body_, this.macroState);
        }
        return struct_;
    }

    override ASTSymbol quote(Quoter quoter) { print("cannot quote 'ASTStructDecl'!"); assert(false); }
}

ASTStructDecl parseStructDecl(Parser parser, LexicalContext lexicalContext)
{
    Loc loc = parser.loc;
    parser.begin;
    if (parseIdentifier(parser) != "struct")
    {
        parser.revert;
        return null;
    }
    string name = parseIdentifier(parser);
    assert(!!name.length);
    mut (string, ASTSymbol)[] members;
    mut ASTStructMethod[] methods;
    parser.expect("{");
    while (!parser.accept("}"))
    {
        mut ASTSymbol memberType;
        mut string memberName;
        if (parser.accept("this"))
        {
            memberType = new ASTBasicType("void", loc);
            memberName = "__ctor";
        }
        else if (parser.accept("~this"))
        {
            memberType = new ASTBasicType("void", loc);
            memberName = "__dtor";
        }
        else
        {
            memberType = lexicalContext.compiler.parseType(parser, lexicalContext);
            if (!memberType) parser.fail("expected member type");
            memberName = parseIdentifier(parser);
            if (!memberName.length) parser.fail("expected member name");
        }
        if (parser.accept("(")) // method
        {
            auto args = parseArglist(parser, lexicalContext);
            parser.assert_(
                memberName != "__dtor" || args.length == 0, "destructor cannot take parameters");
            ASTStatement stmt = lexicalContext.compiler.parseStatement(parser, lexicalContext);
            methods ~= ASTStructMethod(
                parser.loc, memberName, memberType, args, stmt);
        }
        else
        {
            void addMember() {
                parser.assert_(memberName != "__ctor", "constructor cannot be member");
                parser.assert_(memberName != "__dtor", "destructor cannot be member");
                members ~= (memberName, memberType);
            }
            addMember;
            while (!parser.accept(";")) {
                parser.expect(",");
                if (parser.accept(";")) break;
                memberName = parseIdentifier(parser);
                if (!memberName.length) parser.fail("expected member name");
                addMember;
            }
        }
    }
    parser.commit;
    return new ASTStructDecl(name, members, methods, lexicalContext.macroState, loc);
}
