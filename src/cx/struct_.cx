module cx.struct_;

import backend.base;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser_base;
import cx.statements;
import helpers;

class StructMemberDeclaration
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    FunctionDeclaration[] methods;

    Loc loc;

    this(string name, StructMemberDeclaration[] members, Loc loc)
    {
        this.name = name;
        this.members = members;
        this.loc = loc;
    }

    override bool same(Type other) {
        // TODO mangling
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct) return false;
        return this.name == otherStruct.name;
    }

    override BackendType emit(Platform platform)
    {
        auto memberTypes = new BackendType[](this.members.length);
        for (int i = 0; i < this.members.length; i += 1)
        {
            memberTypes[i] = this.members[i].type.emit(platform);
        }
        return new BackendStructType(memberTypes);
    }

    override string repr() { return this.name; }

    override void hash(Hash hash)
    {
        hash.adds("Struct");
        hash.adds(name);
        hash.addl(members.length);
        for (int i = 0; i < members.length; i += 1)
            members[i].type.hash(hash);
    }

    FunctionDeclaration getDtor()
    {
        for (int i = 0; i < this.methods.length; i += 1) {
            if (this.methods[i].name == "__dtor") {
                return this.methods[i];
            }
        }
        return null;
    }

    /**
     * copy constructor is constructor that takes a ptr to this struct
     */
    FunctionDeclaration getCopyCtor()
    {
        auto thisPtr = new Pointer(this);
        for (int i = 0; i < this.methods.length; i += 1) {
            auto method = this.methods[i];
            if (method.name == "__ctor" && method.args.length == 1 && method.args[0].type.same(thisPtr)) {
                return method;
            }
        }
        return null;
    }

    override Statement copyInto(Reference target, Expression source)
    {
        FunctionDeclaration copyCtor = getCopyCtor();
        if (!copyCtor) return null;
        auto srcRef = source.instanceOf(Reference);
        this.loc.assert2s(!!srcRef, "TODO struct copy constructor must be called with reference");
        Expression srcPtr = new ReferenceExpression(srcRef);
        Expression targetPtr = new ReferenceExpression(target);
        auto call = new Call(copyCtor, new Expression[](0) ~ targetPtr ~ srcPtr, this.loc);
        return new ExprStatement(call);
    }

    override Statement endLifetime(Expression expr)
    {
        FunctionDeclaration destructor = getDtor();
        if (!destructor) return null;
        auto ref_ = expr.instanceOf(Reference);
        this.loc.assert2s(!!ref_, "TODO struct destructor must be called on reference");
        Expression ptr = new ReferenceExpression(ref_);
        auto call = new Call(destructor, new Expression[](0) ~ ptr, this.loc);
        return new ExprStatement(call);
    }
}

class StructMember : Reference
{
    Reference base;

    int index;

    this(Reference base, int index)
    {
        this.base = base;
        Struct structType = this.base.type().instanceOf(Struct);
        assert(!!structType);
        this.index = index;
    }

    override Type type()
    {
        Type type = this.base.type();
        Struct structType = type.instanceOf(Struct);
        assert(!!structType);
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type().emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type().emit(output.platform), reg, this.index);
    }

    override void hash(Hash hash)
    {
        hash.adds("StructMember");
        base.hash(hash);
        hash.addl(index);
    }
}
