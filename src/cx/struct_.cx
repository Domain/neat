module cx.struct_;

macro import cx.macros.listcomprehension;

import backend.base;
import cx.base;
import cx.expr;
import cx.hash;
import cx.parser_base;
import cx.statements;
import helpers;

class StructMemberDeclaration
{
    string name;

    Type type;

    this(this.name, this.type) { }
}

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    FunctionDeclaration[] methods;

    Loc loc;

    string mangledName;

    Hash preHash;

    this(this.name, this.members, this.loc, string manglePrefix) {
        this.mangledName = manglePrefix ~ "_struct_" ~ this.name;
        this.preHash = new Hash;
        // hash methods?
        with (this.preHash) {
            adds("Struct");
            adds(mangledName);
            addl(members.length);
            [member.type.hash(this.preHash) for member in this.members];
        }
    }

    override bool same(Type other) {
        // TODO mangling
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct) return false;
        return this.name == otherStruct.name;
    }

    override BackendType emit(Platform platform)
    {
        auto memberTypes = new BackendType[](this.members.length);
        for (int i <- 0 .. this.members.length)
        {
            memberTypes[i] = this.members[i].type.emit(platform);
        }
        return new BackendStructType(memberTypes);
    }

    override string repr() { return this.name; }

    override string mangle() {
        return this.mangledName;
    }

    override Symbol accessMember(Context context, Expression baseExpr, string member) {
        size_t memberOffset = [first i for i, a in this.members where a.name == member else -1];
        if (memberOffset != -1) {
            if (baseExpr.instanceOf(Reference)) {
                return new StructMemberReference(baseExpr.instanceOf(Reference), memberOffset);
            }
            return new StructMember(baseExpr, memberOffset);
        }
        size_t methodOffset = [first i for i, a in this.methods where a.name == member else -1];
        if (methodOffset != -1)
        {
            // TODO dereference-into-symbol so we can '&' it again
            auto funcPtr = context.compiler.referenceFunction(this.methods[methodOffset]);
            loc.assert2s(!!baseExpr.instanceOf(Reference), "base of method call must be reference");
            return new ClassMethodPtr(funcPtr, new ReferenceExpression(baseExpr.instanceOf(Reference)));
        }
        return null;
    }

    override void hash(Hash hash)
    {
        hash.applyHash(preHash);
    }

    FunctionDeclaration getDtor()
    {
        return [first method for method in this.methods where method.name == "__dtor" else null];
    }

    /**
     * copy constructor is constructor that takes an arg of this struct.
     */
    FunctionDeclaration getCopyCtor()
    {
        return [first method for method in this.methods
            where method.name == "__ctor" && method.args.length == 1 && method.args[0].type.same(this)
            else null];
    }

    Statement callAutoDtor(Context context, Reference ref_)
    {
        auto compiler = context.compiler;
        Loc nowhere;

        // Argument[] args = [Argument(false, "ptr", new Pointer(ref_.type))];
        ASTSymbol ptr = compiler.astIdentifier("ptr", nowhere.reloc);

        ASTStatement[] calls;
        for (int i <- 0 .. members.length) {
            auto entry = members[i];
            auto member = new StructMemberReference(ref_, i);
            auto destroy = entry.type.endLifetime(context, member);
            if (destroy) {
                // calls ~= compiler.$stmt __destroy ptr.$name;;
                calls ~= compiler.astExpressionStmt(
                    compiler.astDestroy(
                        compiler.astMember(ptr, entry.name, nowhere.reloc), nowhere.reloc), nowhere.reloc);
            }
        }
        if (!calls.length) return null;
        ASTStatement body_ = compiler.astSequence(calls, nowhere.reloc);
        // auto fn = compiler.createRuntimeFunction(context, "structrelease", new Void, args, body_);
        // return compiler.call(fn, [compiler.reference(ref_)], loc);
        Statement do_(Expression refptr) {
            auto context = context.withNamespace(
                context.compiler.exprAlias(context.namespace, "ptr", refptr));

            return body_.compile(context).statement;
        }
        return context.compiler.stmtWithTemporary(compiler.reference(ref_), &do_);
    }

    Statement copyRecursive(Context context, Reference target, Expression source)
    {
        auto compiler = context.compiler;

        Statement do1(Expression targetptr) {
            auto target = compiler.dereference(targetptr);
            Statement do2(Expression source) {
                Statement[] assigns;
                bool anySpecialAssignments;
                for (int i <- 0 .. members.length) {
                    auto targetField = new StructMemberReference(target, i);
                    auto sourceField = new StructMember(source, i);
                    auto copyInto = members[i].type.copyInto(context, targetField, sourceField);
                    if (copyInto) anySpecialAssignments = true;
                    if (!copyInto) copyInto = compiler.assignStatement(targetField, sourceField);
                    assigns ~= copyInto;
                }
                if (!anySpecialAssignments) return null;
                return compiler.sequenceStatement(assigns);
            }
            return context.compiler.stmtWithTemporary(source, &do2);
        }
        return context.compiler.stmtWithTemporary(compiler.reference(target), &do1);
    }

    override Statement copyInto(Context context, Reference target, Expression source)
    {
        FunctionDeclaration copyCtor = getCopyCtor;
        if (copyCtor) {
            Expression targetPtr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(target));
            auto call = new Call(copyCtor, [targetPtr, source], this.loc);
            return new ExprStatement(call);
        }
        auto copyStmt = copyRecursive(context, target, source);
        if (copyStmt)
            return copyStmt;
        return null;
    }

    override Statement endLifetime(Context context, Reference ref_)
    {
        FunctionDeclaration destructor = getDtor;
        Expression ptr = context.compiler.castTo(new Pointer(new Void), new ReferenceExpression(ref_));
        Statement callDtor, callAutoDtor_ = callAutoDtor(context, ref_);
        if (destructor) callDtor = new ExprStatement(new Call(destructor, [ptr], this.loc));
        return sequence(callDtor, callAutoDtor_);
    }
}

class StructMember : Expression
{
    Expression base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type.instanceOf(Struct);
        assert(!!structType);
    }

    override Type type()
    {
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        return output.fun.field(structType.emit(output.platform), base.emit(output), cast(int) index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMember");
        base.hash(hash);
        hash.addl(index);
    }
}

class StructMemberReference : Reference
{
    Reference base;

    size_t index;

    Struct structType;

    this(this.base, this.index)
    {
        this.structType = this.base.type.instanceOf(Struct);
        assert(!!structType);
    }

    override Type type()
    {
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type.emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type.emit(output.platform), reg, this.index);
    }

    override ExprInfo info() { return base.info; }

    override void hash(Hash hash)
    {
        hash.adds("StructMemberReference");
        base.hash(hash);
        hash.addl(index);
    }
}
