module cx.parser;

import cx.base;
// TODO public import
import cx.parser_base;
import helpers;
import cx.linenr;

extern(C) int cxruntime_isAlpha(char);
extern(C) int cxruntime_isDigit(char);

bool parseNumber(Parser parser, int* ip)
{
    parser.begin();
    bool negative = parser.accept("-");
    if (parser.accept("-"))
        negative = true;
    parser.strip();
    if (parser.accept("0x"))
    {
        return parseHexNumber(parser, ip, negative);
    }
    if (parser.eof() || !cxruntime_isDigit(parser.text()[0]))
    {
        parser.revert();
        return false;
    }
    string number;
    while (!parser.eof() && cxruntime_isDigit(parser.text()[0]))
    {
        number ~= parser.text()[0];
        parser.drop(1);
    }
    parser.commit();
    int i = atoi(number);
    if (negative) i = 0 - i; // TODO move to "-a" form
    *ip = i;
    return true;
}

bool parseHexNumber(Parser parser, int* ip, bool negative)
{
    if (parser.eof() || !isHexDigit(parser.text()[0 .. 1]))
    {
        parser.revert();
        return false;
    }
    int result;
    while (!parser.eof() && isHexDigit(parser.text()[0 .. 1]))
    {
        auto ch = parser.text()[0 .. 1];
        int digit;
        if (cxruntime_isDigit(ch[0])) digit = atoi(ch);
        else if (ch == "a" || ch == "A") digit = 10;
        else if (ch == "b" || ch == "B") digit = 11;
        else if (ch == "c" || ch == "C") digit = 12;
        else if (ch == "d" || ch == "D") digit = 13;
        else if (ch == "e" || ch == "E") digit = 14;
        else if (ch == "f" || ch == "F") digit = 15;
        else assert(false);
        result = result * 16 + digit;
        parser.drop(1);
    }
    parser.commit();
    if (negative) result = 0 - result; // TODO -result form
    *ip = result;
    return true;
}

bool isHexDigit(string digit)
{
    if (cxruntime_isDigit(digit[0])) return true;
    if (digit == "a" || digit == "A") return true;
    if (digit == "b" || digit == "B") return true;
    if (digit == "c" || digit == "C") return true;
    if (digit == "d" || digit == "D") return true;
    if (digit == "e" || digit == "E") return true;
    if (digit == "f" || digit == "F") return true;
    return false;
}

bool parseFloat(Parser parser, float* fp)
{
    parser.begin();
    bool negative = parser.accept("-");
    parser.strip();
    string number;
    while (!parser.eof() && cxruntime_isDigit(parser.text()[0]))
    {
        number ~= parser.text()[0];
        parser.drop(1);
    }
    if (!parser.accept("."))
    {
        parser.revert();
        return false;
    }
    number ~= ".";
    // 2.foo
    if (parser.eof() || !cxruntime_isDigit(parser.text()[0]))
    {
        parser.revert();
        return false;
    }
    while (!parser.eof() && cxruntime_isDigit(parser.text()[0]))
    {
        number ~= parser.text()[0];
        parser.drop(1);
    }
    parser.commit();
    float f = atof(number);
    if (negative) f = 0 - f; // TODO move to "-a" form
    *fp = f;
    return true;
}

bool isAlnum(string s)
{
    return cxruntime_isAlpha(s[0]) || cxruntime_isDigit(s[0]);
}

string parseIdentifier2(Parser parser, string allowedChars)
{
    parser.begin();
    parser.strip();
    // identifiers starting with $ are quasiquoted (see ASTIdentifier).
    if (parser.text().length == 0 || (!cxruntime_isAlpha(parser.text()[0])
        && parser.text()[0 .. 1] != "_" && parser.text()[0 .. 1] != "$")
        && find(allowedChars, parser.text()[0 .. 1]) == -1)
    {
        parser.revert();
        return "";
    }
    string parserText = parser.text();
    string identifier = parserText[0 .. 1];
    parser.drop(1);

    while (parser.text().length > 0 && (
        isAlnum(parser.text()[0 .. 1])
        || parser.text()[0 .. 1] == "_"
        || find(allowedChars, parser.text()[0 .. 1]) != -1))
    {
        identifier = parserText[0 .. identifier.length + 1];
        parser.drop(1);
    }
    parser.commit();
    return identifier;
}

string parseIdentifier(Parser parser)
{
    return parseIdentifier2(parser, "");
}

bool acceptIdentifier(Parser parser, string identifier)
{
    parser.begin();

    string nextIdent = parseIdentifier(parser);

    if (nextIdent != identifier)
    {
        parser.revert();
        return false;
    }
    parser.commit();
    return true;
}
