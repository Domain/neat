module cx.parser;

import cx.base;
// TODO public import
import cx.parser_base;
import helpers;
import cx.linenr;

bool isAlpha(char ch) {
    return (ch >= "a"[0] && ch <= "z"[0]) || (ch >= "A"[0] && ch <= "Z"[0]);
}
bool isDigit(char ch) {
    return ch >= "0"[0] && ch <= "9"[0];
}

// TODO multiple return
bool parseNumber(Parser parser, int* ip)
{
    parser.begin;
    mut bool negative = parser.accept("-");
    if (parser.accept("-"))
        negative = true;
    parser.strip;
    if (parser.accept("0x"))
    {
        return parseHexNumber(parser, ip, negative);
    }
    if (parser.eof || !isDigit(parser.text[0]))
    {
        parser.revert;
        return false;
    }
    mut string number;
    while (!parser.eof && isDigit(parser.text[0]))
    {
        number ~= parser.text[0];
        parser.drop(1);
    }
    parser.commit;
    mut int i = atoi(number);
    if (negative) i = -i;
    *ip = i;
    return true;
}

bool parseHexNumber(Parser parser, int* ip, bool negative)
{
    if (parser.eof || !isHexDigit(parser.text[0 .. 1]))
    {
        parser.revert;
        return false;
    }
    mut int result;
    while (!parser.eof && isHexDigit(parser.text[0 .. 1]))
    {
        auto ch = parser.text[0 .. 1];
        mut int digit;
        if (isDigit(ch[0])) digit = atoi(ch);
        else if (ch == "a" || ch == "A") digit = 10;
        else if (ch == "b" || ch == "B") digit = 11;
        else if (ch == "c" || ch == "C") digit = 12;
        else if (ch == "d" || ch == "D") digit = 13;
        else if (ch == "e" || ch == "E") digit = 14;
        else if (ch == "f" || ch == "F") digit = 15;
        else assert(false);
        result = result * 16 + digit;
        parser.drop(1);
    }
    parser.commit;
    if (negative) result = -result;
    *ip = result;
    return true;
}

bool isHexDigit(string digit)
{
    if (isDigit(digit[0])) return true;
    if (digit == "a" || digit == "A") return true;
    if (digit == "b" || digit == "B") return true;
    if (digit == "c" || digit == "C") return true;
    if (digit == "d" || digit == "D") return true;
    if (digit == "e" || digit == "E") return true;
    if (digit == "f" || digit == "F") return true;
    return false;
}

bool parseFloat(Parser parser, float* fp)
{
    parser.begin;
    bool negative = parser.accept("-");
    parser.strip;
    mut string number;
    while (!parser.eof && isDigit(parser.text[0]))
    {
        number ~= parser.text[0];
        parser.drop(1);
    }
    if (!parser.accept("."))
    {
        parser.revert;
        return false;
    }
    number ~= ".";
    // 2.foo
    if (parser.eof || !isDigit(parser.text[0]))
    {
        parser.revert;
        return false;
    }
    while (!parser.eof && isDigit(parser.text[0]))
    {
        number ~= parser.text[0];
        parser.drop(1);
    }
    parser.commit;
    mut float f = atof(number);
    if (negative) f = -f;
    *fp = f;
    return true;
}

bool isAlnum(string s)
{
    return isAlpha(s[0]) || isDigit(s[0]);
}

string parseIdentifier2(Parser parser, string allowedChars)
{
    parser.begin;
    parser.strip;
    // identifiers starting with $ are quasiquoted (see ASTIdentifier).
    if (parser.text.length == 0 || (!isAlpha(parser.text[0])
        && parser.text[0 .. 1] != "_" && parser.text[0 .. 1] != "$")
        && find(allowedChars, parser.text[0 .. 1]) == -1)
    {
        parser.revert;
        return "";
    }
    string parserText = parser.text;
    mut string identifier = parserText[0 .. 1];
    parser.drop(1);

    while (parser.text.length > 0 && (
        isAlnum(parser.text[0 .. 1])
        || parser.text[0 .. 1] == "_"
        || find(allowedChars, parser.text[0 .. 1]) != -1))
    {
        identifier = parserText[0 .. identifier.length + 1];
        parser.drop(1);
    }
    parser.commit;
    return identifier;
}

string parseIdentifier(Parser parser)
{
    return parseIdentifier2(parser, "");
}

bool acceptIdentifier(Parser parser, string identifier)
{
    parser.begin;

    string nextIdent = parseIdentifier(parser);

    if (nextIdent != identifier)
    {
        parser.revert;
        return false;
    }
    parser.commit;
    return true;
}
