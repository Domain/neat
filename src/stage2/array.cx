module array;

import backend.proxy;
import base;
import types;

int getArrayLen(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 1);
}

class ArrayLength : Expression
{
    Expression arrayValue;

    this(Expression arrayValue) { this.arrayValue = arrayValue; }

    Type type()
    {
        // TODO word type
        return new Integer;
    }

    int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayLen(output, this.arrayValue.type(), arrayReg);
    }
}

int getArrayPtr(Generator output, Type arrayType, int arrayReg)
{
    return output.fun.field(arrayType.emit(output.platform), arrayReg, 0);
}

class ArrayPointer : Expression
{
    Type elementType;

    Expression arrayValue;

    this(Type elementType, Expression arrayValue) { this.elementType = elementType; this.arrayValue = arrayValue; }

    Type type()
    {
        return new Pointer(this.elementType);
    }

    int emit(Generator output)
    {
        int arrayReg = this.arrayValue.emit(output);

        return getArrayPtr(output, this.arrayValue.type(), arrayReg);
    }
}

int makeArray(Generator output, Type elementType, int ptrReg, int lenReg)
{
    void* voidp = (new Pointer(new Void)).emit(output.platform);
    void* intType = (new Integer).emit(output.platform);

    // TODO allocaless
    void* structType = (new Array(elementType)).emit(output.platform);
    int structReg = output.fun.alloca(structType);
    int ptrField = output.fun.fieldOffset(structType, structReg, 0);
    int lenField = output.fun.fieldOffset(structType, structReg, 1);

    output.fun.store(voidp, ptrField, ptrReg);
    output.fun.store(intType, lenField, lenReg);
    return output.fun.load(structType, structReg);
}

class ArrayExpression : Expression
{
    Expression pointer;

    Expression length;

    this(Expression pointer, Expression length) { this.pointer = pointer; this.length = length; }

    Type type()
    {
        Pointer ptrType = this.pointer.type().instanceOf(Pointer);
        assert(ptrType);
        return new Array(ptrType.target);
    }

    int emit(Generator output)
    {
        int pointer = this.pointer.emit(output);
        int length = this.length.emit(output);

        return makeArray(output, this.type().instanceOf(Array).elementType, pointer, length);
    }
}

class ASTArraySlice : ASTSymbol
{
    ASTSymbol array;

    ASTSymbol lower;

    ASTSymbol upper;

    this(ASTSymbol array, ASTSymbol lower, ASTSymbol upper)
    {
        this.array = array;
        this.lower = lower;
        this.upper = upper;
    }

    Symbol compile(Context context)
    {
        return new ArraySlice(
            beExpression(this.array.compile(context)),
            beExpression(this.lower.compile(context)),
            beExpression(this.upper.compile(context)));
    }
}

class ArraySlice : Expression
{
    Expression array;

    Expression lower;

    Expression upper;

    this(Expression array, Expression lower, Expression upper)
    {
        this.array = array;
        this.lower = lower;
        this.upper = upper;
    }

    Type type() { return this.array.type(); }

    int emit(Generator output)
    {
        void* voidp = output.platform.pointerType(output.platform.voidType());
        void* intType = output.platform.intType();

        Array arrayType = this.array.type().instanceOf(Array);
        assert(arrayType); // , "slice of non-array");
        int elementSize = output.platform.size(arrayType.elementType.emit(output.platform));

        int arrayReg = this.array.emit(output);
        int lowerReg = this.lower.emit(output);
        int upperReg = this.upper.emit(output);
        int ptr = getArrayPtr(output, arrayType, arrayReg);
        // ptr = ptr + lower
        int lowerOffset = output.fun.binop("*", lowerReg, output.fun.intLiteral(elementSize));
        int newPtr = output.fun.call(voidp, "ptr_offset", new int[](0) ~ ptr ~ lowerOffset);
        // len = upper - lower
        int newLen = output.fun.binop("-", upperReg, lowerReg);

        return makeArray(output, arrayType.elementType, newPtr, newLen);
    }
}
