module backend.llvm;

import backend.base;
import helpers;

class LLVMBackend : Backend {
    this() { }
    override LLVMBackendModule createModule(Platform platform) {
        return new LLVMBackendModule(platform);
    }
}

class Global {
    string name;
    string type;
    this(string name, string type) {
        this.name = name;
        this.type = type;
    }
}

extern(C) void cxruntime_file_write(string file, string content);
extern(C) void cxruntime_system(string command);
extern(C) void cxruntime_dlcall(string soname, string name, void* arg);

class LLVMBackendModule : BackendModule {
    LineWriter output;

    int literalId;
    Global[] globals;

    this(Platform platform) {
        this.output = new LineWriter;
        this.output.print("target triple = \"x86_64-unknown-linux-gnu\"");
        defineIntrinsics(this, platform);
    }

    bool declared(string name) {
        for (int i = 0; i < this.globals.length; i = i + 1)
            if (this.globals[i].name == name) return true;
        return false;
    }

    override void declare(string name, bool extern_, BackendType ret, BackendType[] args)
    {
        if (this.declared(name)) return;
        if (extern_) {
            string argstr = "(";
            for (int i = 0; i < args.length; i = i + 1) {
                if (i) argstr = argstr ~ ", ";
                argstr = argstr ~ llvmFmt(args[i]) ~ " %arg" ~ itoa(i);
            }
            argstr = argstr ~ ")";
            string retstr = llvmFmt(ret);
            if (ret.instanceOf(BackendVoidType)) retstr = "void"; // TODO
            this.output.print("declare " ~ retstr ~ " @" ~ name ~ argstr);
        }
        this.globals = this.globals ~ new Global(name, llvmFmt(new BackendFunctionPointerType(ret, args)));
    }

    override BackendFunction define(string name, BackendType ret, BackendType[] args)
    {
        if (name == "main") name = "_main"; // TODO mangle
        this.globals = this.globals ~ new Global(name, llvmFmt(new BackendFunctionPointerType(ret, args)));
        return new LLVMBackendFunction(this, name, ret, args);
    }
    override void defineSymbolList(string name, string[] symbols)
    {
        string symbolList;
        for (int i = 0; i < symbols.length; i = i + 1) {
            if (i) symbolList = symbolList ~ ", ";
            symbolList = symbolList ~ "void()* bitcast ("
                ~ this.globalType(symbols[i]) ~ " @" ~ symbols[i] ~ " to void()*)";
        }
        string globalType = "[" ~ ltoa(symbols.length) ~ " x void()*]";
        this.output.print("@" ~ name ~ " = global " ~ globalType ~ " [ " ~ symbolList ~ " ]");
        this.globals = this.globals ~ new Global(name, globalType);
    }
    string nextLiteral() {
        string res = "@str" ~ itoa(this.literalId);
        this.literalId = this.literalId + 1;
        return res;
    }
    string globalType(string name) {
        for (int i = 0; i < this.globals.length; i = i + 1)
            if (this.globals[i].name == name)
                return this.globals[i].type;
        print("no such global " ~ name);
        assert(false);
    }
    void callMacroFun(string name, void* ptr)
    {
        // TODO hash, cache backend
        auto filename = ".obj/macro_" ~ name ~ ".ll";
        auto soname = ".obj/macro_" ~ name ~ ".so";
        auto cmd = "clang -shared -fpic " ~ filename ~ " -o " ~ soname;
        cxruntime_file_write(filename, this.output.text());
        print("$ " ~ cmd);
        cxruntime_system(cmd);
        cxruntime_dlcall(soname, name, ptr);
    }
}

string llvmFmt(BackendType type) {
    if (type.instanceOf(BackendLongType)) return "i64";
    if (type.instanceOf(BackendIntType)) return "i32";
    if (type.instanceOf(BackendCharType)) return "i8";
    if (type.instanceOf(BackendFloatType)) return "float";
    if (type.instanceOf(BackendVoidType)) return "TODOVOID";
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            return "i8*";
        }
        return llvmFmt(backendPointerType.target) ~ "*";
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        string res = "{ ";
        for (int i = 0; i < backendStructType.members.length; i = i + 1) {
            if (i) res = res ~ ", ";
            res = res ~ llvmFmt(backendStructType.members[i]);
        }
        res = res ~ " }";
        return res;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        string res = llvmFmt(backendFpType.ret) ~ "(";
        if (backendFpType.ret.instanceOf(BackendVoidType)) res = "void("; // TODO
        for (int i = 0; i < backendFpType.args.length; i = i + 1) {
            if (i) res = res ~ ", ";
            res = res ~ llvmFmt(backendFpType.args[i]);
        }
        res = res ~ ")*";
        return res;
    }
    assert(false);
}

class RegDefine
{
    int reg;
    string type;
    string value;
    this(int reg, string type, string value) {
        this.reg = reg;
        this.type = type;
        this.value = value;
    }
}

class LLVMBackendFunction : BackendFunction {
    string name;
    LLVMBackendModule mod;
    BackendType ret_;
    BackendType[] args;

    LineWriter output;
    RegDefine[] regDefines;
    int regId;
    int blockId;

    this(LLVMBackendModule mod, string name, BackendType ret, BackendType[] args)
    {
        this.name = name;
        this.mod = mod;
        this.ret_ = ret;
        this.args = args;
        this.output = new LineWriter;
        this.regId = 1;
    }
    void print(string msg) { this.output.print("  " ~ msg); }
    string reg(int reg) {
        for (int i = 0; i < this.regDefines.length; i = i + 1) {
            RegDefine def = this.regDefines[i];
            if (def.reg == reg)
                return def.value;
        }
        return "%reg" ~ itoa(reg);
    }
    string treg(int reg) {
        for (int i = 0; i < this.regDefines.length; i = i + 1) {
            RegDefine def = this.regDefines[i];
            if (def.reg == reg)
                return def.type ~ " " ~ def.value;
        }
        return "NOTFOUND %reg" ~ itoa(reg);
    }
    void defReg2(int reg, string type, string value) {
        this.regDefines = this.regDefines ~ new RegDefine(reg, type, value);
    }
    int defReg(string type, string value) {
        int reg = this.nextReg();
        this.defReg2(reg, type, value);
        return reg;
    }
    int nextReg() {
        int result = this.regId;
        this.regId = this.regId + 1;
        return result;
    }
    string nextBlockLabel() {
        string res = "Label" ~ itoa(this.blockId);
        this.blockId = this.blockId + 1;
        return res;
    }
    override string getLabel() {
        return "Label" ~ itoa(this.blockId);
    }
    override void setLabel(string label) {
        this.print("br label %" ~ label);
        this.print(label ~ ":");
    }
    override int arg(int index) {
        return this.defReg(llvmFmt(this.args[index]), "%arg" ~ itoa(index));
    }
    override int intLiteral(long value) {
        return this.defReg("i32", ltoa(value));
    }
    override int longLiteral(long value) {
        return this.defReg("i64", ltoa(value));
    }
    override int wordLiteral(Platform platform, size_t value) {
        string sizestr;
        if (platform.nativeWordType().instanceOf(BackendIntType)) sizestr = "i32";
        else if (platform.nativeWordType().instanceOf(BackendLongType)) sizestr = "i64";
        else assert(false);
        return this.defReg(sizestr, ltoa(value));
    }
    override int stringLiteral(string text) {
        // TODO move to LLVMBackendModule
        string literalId = this.mod.nextLiteral();
        string type = "[" ~ ltoa(text.length) ~ " x i8]";
        string escapedText;
        // TODO ord()
        for (int i = 0; i < text.length; i = i + 1) {
            if (text[i .. i + 1] == "\"") escapedText = escapedText ~ "\\22";
            else if (text[i .. i + 1] == "\\") escapedText = escapedText ~ "\\5C";
            else escapedText = escapedText ~ text[i .. i + 1];
        }
        this.mod.output.print(
            literalId ~ " = private unnamed_addr constant " ~ type ~ " c\"" ~ escapedText ~ "\"");
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ type ~ "* " ~ literalId ~ " to i8*");
        return this.defReg("i8*", "%reg" ~ itoa(reg));
    }
    override int voidLiteral() {
        return this.defReg(llvmFmt(this.ret_), "zeroinitializer");
    }
    override int symbolList(string name) {
        int reg = this.nextReg();
        auto type = this.mod.globalType(name);
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ type ~ "* @" ~ name ~ " to i8*");
        return this.defReg("i8*", "%reg" ~ itoa(reg));
    }
    override int binop(string op, BackendType type, int left, int right) {
        int reg = this.nextReg();
        string typestr = llvmFmt(type);
        string instr;
        if (typestr == "float") {
            if (op == "+") instr = "fadd";
            else if (op == "-") instr = "fsub";
            else if (op == "*") instr = "fmul";
            else if (op == "==") instr = "fcmp oeq";
            else if (op == "<") instr = "fcmp olt";
            else if (op == "<=") instr = "fcmp ole";
            else if (op == ">") instr = "fcmp ogt";
            else if (op == ">=") instr = "fcmp oge";
            else { print(op); assert(false); }
        } else {
            if (op == "+") instr = "add";
            else if (op == "-") instr = "sub";
            else if (op == "*") instr = "mul";
            else if (op == "&") instr = "and";
            else if (op == "==") instr = "icmp eq";
            else if (op == "<") instr = "icmp slt";
            else if (op == "<=") instr = "icmp sle";
            else if (op == ">") instr = "icmp sgt";
            else if (op == ">=") instr = "icmp sge";
            else { print(op); assert(false); }
        }
        this.print("%reg" ~ itoa(reg) ~ " = " ~ instr ~ " " ~ typestr ~ " " ~ this.reg(left) ~ ", " ~ this.reg(right));
        int i1 = reg;
        if (op == "==" || op == "<" || op == ">" || op == "<=" || op == ">=") {
            reg = this.nextReg();
            this.print("%reg" ~ itoa(reg) ~ " = zext i1 %reg" ~ itoa(i1) ~ " to i32");
            this.defReg2(reg, "i32", "%reg" ~ itoa(reg));
        } else {
            this.defReg2(reg, typestr, "%reg" ~ itoa(reg));
        }
        return reg;
    }
    override int bitcast(int from, BackendType to) {
        int reg = this.nextReg();
        string toStr = llvmFmt(to);
        this.print("%reg" ~ itoa(reg) ~ " = bitcast " ~ this.treg(from) ~ " to " ~ toStr);
        this.defReg2(reg, toStr, "%reg" ~ itoa(reg));
        return reg;
    }
    override int zeroExtend(int value, int from, int to) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = zext i" ~ itoa(from * 8) ~ " " ~ this.reg(value) ~ " to i" ~ itoa(to * 8));
        this.defReg2(reg, "i" ~ itoa(to * 8), "%reg" ~ itoa(reg));
        return reg;
    }
    override int signExtend(int value, int from, int to) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = sext i" ~ itoa(from * 8) ~ " " ~ this.reg(value) ~ " to i" ~ itoa(to * 8));
        this.defReg2(reg, "i" ~ itoa(to * 8), "%reg" ~ itoa(reg));
        return reg;
    }
    override int intToFloat(int value) {
        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = sitofp " ~ this.treg(value) ~ " to float");
        this.defReg2(reg, "float", "%reg" ~ itoa(reg));
        return reg;
    }
    override int call(BackendType ret, string name, int[] args) {
        int reg = this.nextReg();
        string argstr = "(";
        for (int i = 0; i < args.length; i = i + 1) {
            if (i) argstr = argstr ~ ", ";
            argstr = argstr ~ this.treg(args[i]);
        }
        argstr = argstr ~ ")";
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void @" ~ name ~ argstr);
            this.defReg2(reg, llvmFmt(ret), "TODOVOIDCALL");
        } else {
            this.print("%reg" ~ itoa(reg) ~ " = call " ~ llvmFmt(ret) ~ " @" ~ name ~ argstr);
            this.defReg2(reg, llvmFmt(ret), "%reg" ~ itoa(reg));
        }
        return reg;
    }
    override int getFuncPtr(string name) {
        auto type = this.mod.globalType(name);

        return this.defReg(type, "@" ~ name);
    }
    override int callFuncPtr(BackendType type, int callReg, int[] args) {
        auto backendFpType = type.instanceOf(BackendFunctionPointerType);
        assert(!!backendFpType);
        auto ret = backendFpType.ret;
        int reg = this.nextReg();
        string argstr = "(";
        for (int i = 0; i < args.length; i = i + 1) {
            if (i) argstr = argstr ~ ", ";
            argstr = argstr ~ this.treg(args[i]);
        }
        argstr = argstr ~ ")";
        if (ret.instanceOf(BackendVoidType)) {
            this.print("call void " ~ this.reg(callReg) ~ argstr);
            this.defReg2(reg, llvmFmt(ret), "TODOVOIDCALL");
        } else {
            this.print("%reg" ~ itoa(reg) ~ " = call " ~ llvmFmt(ret) ~ " " ~ this.reg(callReg) ~ argstr);
            this.defReg2(reg, llvmFmt(ret), "%reg" ~ itoa(reg));
        }
        return reg;
    }
    override int load(BackendType backendType, int source) {
        int reg = this.nextReg();
        string typeFmt = llvmFmt(backendType);
        this.output.appendsi("  %reg", reg);
        this.output.append6s(" = load ", typeFmt, ", ", typeFmt, "* ", this.reg(source));
        this.output.endl();
        this.defReg2(reg, typeFmt, "%reg" ~ itoa(reg));
        return reg;
    }
    override int alloca(BackendType backendType) {
        int reg = this.nextReg();
        string typefmt = llvmFmt(backendType);
        this.print("%reg" ~ itoa(reg) ~ " = alloca " ~ typefmt);
        this.print("store " ~ typefmt ~ " zeroinitializer, " ~ typefmt ~ "* %reg" ~ itoa(reg));
        this.defReg2(reg, typefmt ~ "*", "%reg" ~ itoa(reg));
        return reg;
    }
    override int field(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg = this.nextReg();
        this.print("%reg" ~ itoa(reg) ~ " = extractvalue " ~ this.treg(source) ~ ", " ~ itoa(index));
        this.defReg2(reg, llvmFmt(backendStructType.members[index]), "%reg" ~ itoa(reg));
        return reg;
    }
    override int fieldOffset(BackendType backendType, int source, int index) {
        auto backendStructType = backendType.instanceOf(BackendStructType);
        assert(!!backendStructType);

        int reg1 = this.nextReg();
        string typeStr = llvmFmt(backendType);
        this.output.appendsi("  %reg", reg1);
        this.output.append5s(" = bitcast ", this.treg(source), " to ", typeStr, "*");
        this.output.endl();

        int reg2 = this.nextReg();
        this.output.appendsi("  %reg", reg2);
        this.output.append5s(" = getelementptr ", typeStr, ", ", typeStr, "* ");
        this.output.appendsi("%reg", reg1);
        this.output.appendsi(", i32 0, i32 ", index);
        this.output.endl();
        this.defReg2(reg2, llvmFmt(backendStructType.members[index]) ~ "*", "%reg" ~ itoa(reg2));
        return reg2;
    }
    override void store(BackendType backendType, int target_reg, int value_reg) {
        string typeStr = llvmFmt(backendType);
        this.print("store " ~ typeStr ~ " " ~ this.reg(value_reg) ~ ", " ~ this.treg(target_reg));
    }
    override void ret(int reg) {
        if (this.ret_.instanceOf(BackendVoidType)) {
            this.print("ret void");
        } else {
            this.print("ret " ~ this.treg(reg));
        }
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void branch(string label) {
        this.print("br label %" ~ label);
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void testBranch(int reg, string thenLabel, string elseLabel) {
        int testReg = this.nextReg();
        this.print("%reg" ~ itoa(testReg) ~ " = icmp ne i32 " ~ this.reg(reg) ~ ", 0");
        this.print("br i1 %reg" ~ itoa(testReg) ~ ", label %" ~ thenLabel ~ ", label %" ~ elseLabel);
        this.print(this.nextBlockLabel() ~ ":");
    }
    override void done() {
        this.print("unreachable");
        string argstr = "(";
        for (int i = 0; i < this.args.length; i = i + 1) {
            if (i) argstr = argstr ~ ", ";
            argstr = argstr ~ llvmFmt(this.args[i]) ~ " %arg" ~ itoa(i);
        }
        argstr = argstr ~ ")";
        string retstr = llvmFmt(this.ret_);
        if (this.ret_.instanceOf(BackendVoidType)) retstr = "void"; // TODO
        this.mod.output.print("define " ~ retstr ~ " @" ~ this.name ~ argstr ~ "{");
        this.mod.output.print(this.output.text());
        this.mod.output.print("}");
    }
}

class LineAppender
{
    string buffer;
    size_t used;
    this() {
        this.buffer = new string(128);
    }
    void appends(string msg) {
        this.expand(this.used + msg.length);
        memcpy(&this.buffer[this.used], msg.ptr, msg.length);
        this.used = this.used + msg.length;
    }
    void appendi(int i) {
        this.appends(itoa(i)); // TODO
    }
    void expand(size_t newLength) {
        while (newLength > this.buffer.length)
        {
            size_t newBufLen = this.buffer.length * 2;
            auto newBuf = new string(newBufLen);
            for (int i = 0; i < this.used; i = i + 1) newBuf[i] = this.buffer[i];
            this.buffer = newBuf;
        }
    }
    string flush() {
        string result = new string(this.used);
        memcpy(result.ptr, this.buffer.ptr, this.used);
        this.used = 0;
        return result;
    }
}

class LineWriter
{
    string[] lines;
    int length;
    LineAppender line;
    this() {
        this.line = new LineAppender;
    }
    void print(string msg) {
        this.line.appends(msg);
        this.endl();
    }
    void appendsi(string s, int i)
    {
        this.line.appends(s);
        this.line.appendi(i);
    }
    void append(string a)
    {
        this.line.appends(a);
    }
    void append2s(string a, string b)
    {
        this.line.appends(a);
        this.line.appends(b);
    }
    void append5s(string a, string b, string c, string d, string e)
    {
        this.line.appends(a);
        this.line.appends(b);
        this.line.appends(c);
        this.line.appends(d);
        this.line.appends(e);
    }
    void append6s(string a, string b, string c, string d, string e, string f)
    {
        this.append5s(a, b, c, d, e);
        this.line.appends(f);
    }
    void endl() {
        this.line.appends("\n");
        this.append_(this.line.flush());
    }
    void append_(string line) {
        if (this.length == this.lines.length) {
            size_t newLen = this.lines.length * 2;
            if (newLen == 0) newLen = 1;
            auto newLines = new string[](newLen);
            for (int i = 0; i < this.length; i = i + 1) newLines[i] = this.lines[i];
            this.lines = newLines;
        }
        this.lines[this.length] = line;
        this.length = this.length + 1;
    }
    string text()
    {
        size_t sum;
        for (int i = 0; i < this.length; i = i + 1)
            sum = sum + this.lines[i].length;
        string res = new char[](sum);
        size_t offset = 0;
        for (int i = 0; i < this.length; i = i + 1)
        {
            string line = this.lines[i];
            memcpy(&res[offset], line.ptr, line.length);
            offset = offset + line.length;
        }
        assert(offset == sum);
        return res;
    }
}

void llvmFmtInto(BackendType type, LineWriter output)
{
    if (type.instanceOf(BackendLongType)) { output.append("i64"); return; }
    if (type.instanceOf(BackendIntType)) { output.append("i32"); return; }
    if (type.instanceOf(BackendCharType)) { output.append("i8"); return; }
    if (type.instanceOf(BackendVoidType)) { output.append("TODOVOID"); return; }
    auto backendPointerType = type.instanceOf(BackendPointerType);
    if (backendPointerType) {
        if (backendPointerType.target.instanceOf(BackendVoidType)) {
            output.append("i8*");
            return;
        }
        llvmFmtInto(backendPointerType.target, output);
        output.append("*");
        return;
    }
    auto backendStructType = type.instanceOf(BackendStructType);
    if (backendStructType) {
        output.append("{ ");
        for (int i = 0; i < backendStructType.members.length; i = i + 1) {
            if (i) output.append(", ");
            llvmFmtInto(backendStructType.members[i], output);
        }
        output.append(" }");
        return;
    }
    auto backendFpType = type.instanceOf(BackendFunctionPointerType);
    if (backendFpType) {
        if (backendFpType.ret.instanceOf(BackendVoidType)) {
            output.append("void("); // TODO
        } else {
            llvmFmtInto(backendFpType.ret, output);
            output.append("(");
        }
        for (int i = 0; i < backendFpType.args.length; i = i + 1) {
            if (i) output.append(", ");
            llvmFmtInto(backendFpType.args[i], output);
        }
        output.append(")*");
        return;
    }
    assert(false);
}

void defineIntrinsics(LLVMBackendModule mod, Platform platform) {
    BackendType voidp = new BackendPointerType(new BackendVoidType);
    BackendType sizet = platform.nativeWordType();
    {
        auto argTypes = new BackendType[](5);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        argTypes[3] = sizet;
        argTypes[4] = sizet;
        mod.declare("_arraycmp", true, new BackendIntType, argTypes);
    }
    {
        auto argTypes = new BackendType[](3);
        argTypes[0] = voidp;
        argTypes[1] = voidp;
        argTypes[2] = sizet;
        mod.declare("memcpy", true, voidp, argTypes);
    }
    {
        auto argTypes = new BackendType[](2);
        argTypes[0] = voidp;
        argTypes[1] = sizet;
        mod.declare("ptr_offset", true, voidp, argTypes);
    }
    mod.declare("cxruntime_ptr_test", true, new BackendIntType, new BackendType[](0) ~ voidp);
    mod.declare("cxruntime_alloc", true, voidp, new BackendType[](0) ~ sizet);
}
