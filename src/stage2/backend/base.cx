module backend.base;

extern(C) void assert(int);

class BranchRecord
{
    void resolve(int block) { assert(false); }
}

class TestBranchRecord
{
    void resolveThen(int target) { assert(false); }
    void resolveElse(int target) { assert(false); }
}

class BackendFunction
{
    int arg(int index) { assert(false); }
    int intLiteral(int value) { assert(false); }
    int longLiteral(long value) { assert(false); }
    int wordLiteral(Platform platform, size_t value) { assert(false); }
    int stringLiteral(string text) { assert(false); }
    int voidLiteral() { assert(false); }
    int symbolList(string name) { assert(false); }
    int binop(string op, int size, int left, int right) { assert(false); }
    int zeroExtend(int value, int from, int to) { assert(false); }
    int call(BackendType ret, string name, int[] args) { assert(false); }
    int getFuncPtr(string name) { assert(false); }
    int callFuncPtr(BackendType type, int reg, int[] args) { assert(false); }
    int load(BackendType backendType, int reg) { assert(false); }
    int alloca(BackendType backendType) { assert(false); }
    int field(BackendType backendType, int reg, int index) { assert(false); }
    int fieldOffset(BackendType backendType, int reg, int index) { assert(false); }
    void store(BackendType backendType, int target_reg, int value_reg) { assert(false); }
    void ret(int reg) { assert(false); }
    BranchRecord branch() { assert(false); }
    TestBranchRecord testBranch(int reg) { assert(false); }
    int blockIndex() { assert(false); }
}

class BackendModule
{
    BackendFunction define(string name, BackendType ret, BackendType[] args) { assert(false); }
    void defineSymbolList(string name, string[] symbols) { assert(false); }
}

class Backend
{
    BackendModule createModule() { assert(false); }
}

class Platform {
    int nativeWordSize() { assert(false); }
}

class BackendType
{
    int size(Platform platform) { assert(false); }
    int alignment(Platform platform) { assert(false); }
}

class BackendLongType : BackendType
{
    this() { }
    override int size(Platform platform) { return 8; }
    override int alignment(Platform platform) { return 8; }
}

class BackendIntType : BackendType
{
    this() { }
    override int size(Platform platform) { return 4; }
    override int alignment(Platform platform) { return 4; }
}

class BackendCharType : BackendType
{
    this() { }
    override int size(Platform platform) { return 1; }
    override int alignment(Platform platform) { return 1; }
}

class BackendVoidType : BackendType
{
    this() { }
    override int size(Platform platform) { return 0; }
    override int alignment(Platform platform) { return 1; }
}

class BackendPointerType : BackendType
{
    BackendType target;

    this(BackendType target) { this.target = target; }

    override int size(Platform platform) { return platform.nativeWordSize(); }
    override int alignment(Platform platform) { return platform.nativeWordSize(); }
}

class BackendFunctionPointerType : BackendType
{
    BackendType ret;
    BackendType[] args;

    this(BackendType ret, BackendType[] args) {
        this.ret = ret;
        this.args = args;
    }

    override int size(Platform platform) { return platform.nativeWordSize(); }
    override int alignment(Platform platform) { return platform.nativeWordSize(); }
}

class BackendStructType : BackendType
{
    BackendType[] members;

    this(BackendType[] members) { this.members = members; }

    override int size(Platform platform) {
        int size; int alignment;
        calcPrefix(platform, this.members, &size, &alignment);

        return roundToNext(size, alignment);
    }

    override int alignment(Platform platform) {
        int size; int alignment;
        calcPrefix(platform, this.members, &size, &alignment);

        return alignment;
    }
}

void calcPrefix(Platform platform, BackendType[] members, int* structSize, int* structAlign)
{
    *structSize = 0;
    *structAlign = 1;
    for (int i = 0; i < members.length; i = i + 1) {
        auto member = members[i];
        int alignment = member.alignment(platform);
        int size = member.size(platform);
        // round to next <alignment>
        *structSize = roundToNext(*structSize, alignment) + size;
        if (alignment > *structAlign) *structAlign = alignment;
    }
}

int roundToNext(int size, int alignment)
{
    size = size + alignment - 1;
    // alignment is a power of two, so alignment - 1 is a mask
    // size -= size % alignment;
    size = size - (size & (alignment - 1));
    return size;
}
