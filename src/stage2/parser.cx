module parser;

import backend.proxy;

class Parser
{
    string[] stack;

    int level;

    this(string text)
    {
        this.stack = [text];
        this.level = 0;
    }

    void verify()
    {
        assert(this.stack.length > 0);
        assert(this.level <= this.stack.length);
    }

    string* textp()
    {
        this.verify();
        return &this.stack[this.level];
    }

    string text()
    {
        return *this.textp();
    }

    void begin()
    {
        this.verify();
        if (this.level == this.stack.length - 1)
        {
            this.stack = [...this.stack, this.text()];
        }
        else
        {
            this.stack[this.level + 1] = this.text();
        }
        this.level = this.level + 1;
    }

    void commit()
    {
        this.verify();
        this.stack[this.level - 1] = this.text();
        this.stack = this.stack[0 .. this.stack.length - 1];
    }

    void revert()
    {
        this.verify();
        this.level = this.level - 1;
    }

    bool accept(string match)
    {
        this.begin();
        this.strip();
        if (this.text().length < match.length)
        {
            this.revert();
            return false;
        }
        if (this.text()[0 .. match.length] == match)
        {
            (*this.textp()) = this.text()[match.length .. this.text().length];
            this.commit();
            return true;
        }
        this.revert();
        return true;
    }

    void expect(string match)
    {
        if (!this.accept(match))
        {
            /* this.fail(format("'%s' expected.", match)); */
            this.fail("something expected");
        }
    }

    bool eof()
    {
        this.begin();
        this.strip();
        if (this.text().length == 0)
        {
            this.commit();
            return true;
        }
        this.revert();
        return false;
    }

    void strip()
    {
        while (true)
        {
            /* this.text = this.text.strip; */
            while (this.text().length > 0 && isWhitespace(this.text()[0 .. 1]))
            {
                *this.textp() = this.text()[1 .. this.text().length];
            }
            if (!startsWith(this.text(), "/*")) return;
            *this.textp() = this.text()["/*".length .. this.text().length];
            int commentLevel = 1;
            while (commentLevel > 0)
            {
                int more = find(this.text(), "/*");
                int less = find(this.text(), "*/");

                if (more == -1 && less == -1) this.fail("comment spans end of file");
                if (less != -1 && (more == -1 || less < more))
                {
                    *this.textp() = this.text()[less + "*/".length .. this.text().length];
                    commentLevel = commentLevel - 1;
                }
                if (more != -1 && (less == -1 || more < less))
                {
                    *this.textp() = this.text()[more + "/*".length .. this.text().length];
                    commentLevel = commentLevel + 1;
                }
            }
        }
    }

    void fail(string message)
    {
        /* assert(false, format!"at %s: %s"(this.text, msg)); */
        assert(false); /* TODO */
    }
}

bool startsWith(string haystack, string needle)
{
    return haystack.length >= needle.length && haystack[0 .. needle.length] == needle;
}

int find(string haystack, string needle)
{
    for (int i = 0; i <= haystack.length - needle.length; i = i + 1)
    {
        if (haystack[i .. i + needle.length] == needle) return i;
    }
    return -1;
}

bool parseNumber(Parser parser, int* ip)
{
    parser.begin();
    parser.strip();
    if (parser.eof() || !isNumber(parser.text()[0 .. 1]))
    {
        parser.revert();
        return false;
    }
    string number;
    while (!parser.eof() && isNumber(parser.text()[0 .. 1]))
    {
        number = [...number, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    *ip = atoi(number);
    return true;
}

bool isNumber(string s)
{
    assert(s.length == 1);
    return find("0123456789", s) != -1;
}

bool isAlpha(string s)
{
    assert(s.length == 1);
    return find("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", s) != -1;
}

bool isAlnum(string s)
{
    return isAlpha(s) || isNumber(s);
}

bool isWhitespace(string s)
{
    return s == " " || s == "\t" || s == "\r" || s == "\n";
}

string parseIdentifier(Parser parser)
{
    parser.begin();
    parser.strip();
    if (parser.text().length == 0 || (!isAlpha(parser.text()[0 .. 1]) && parser.text()[0 .. 1] != "_"))
    {
        parser.revert();
        return "";
    }
    string identifier;
    while (parser.text().length > 0 && (isAlnum(parser.text()[0 .. 1]) || parser.text()[0 .. 1] == "_"))
    {
        identifier = [...identifier, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    return identifier;
}

bool acceptIdentifier(Parser parser, string identifier)
{
    parser.begin();
    if (parseIdentifier(parser) != identifier)
    {
        parser.revert();
        return false;
    }
    parser.commit();
    return true;
}

// something that can be referenced by a name
class Symbol
{
}

class Namespace
{
    Namespace parent; // lexical parent

    this(Namespace parent) { this.parent = parent; }

    Symbol lookup(string name) { assert(false); }
}

class Context
{
    /* Platform platform; */

    Namespace namespace;

    this(Namespace namespace) { this.namespace = namespace; }

    Context withNamespace(Namespace namespace)
    {
        /* return new Context(this.platform, namespace); */
        return new Context(namespace);
    }
}

class ASTSymbol
{
    Symbol compile(Context context) { assert(false); }
}

class Type
{
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

class Integer : Type
{
}

class ASTInteger : ASTType
{
    Type compile(Context context) {
        return new Integer;
    }
}

ASTType parseLeafType(Parser parser)
{
    parser.begin();

    string identifier = parseIdentifier(parser);

    if (!identifier.length)
    {
        parser.revert();
        return null;
    }

    if (identifier == "int")
    {
        parser.commit();
        return new ASTInteger;
    }

    assert(false);
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

ASTType parseType(Parser parser)
{
    ASTType current = parseLeafType(parser);
    return current;
}

class ASTArgument
{
    string name;

    ASTType type;

    this(string name, ASTType type)
    {
        this.name = name;
        this.type = type;
    }
}

class Generator
{
    BackendModule mod;

    BackendFunction fun;

    // Platform platform;

    int frameReg;

    this(/*Platform platform, */BackendModule mod)
    {
        // this.platform = platform;
        this.mod = mod;
        this.fun = null;
    }
}

class Statement
{
    void emit(Generator output) { assert(false); }
}

class ASTStatement
{
    Statement compile(Context context) { assert(false); }
}

class Argument
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class Function : Symbol
{
    string name;

    Type ret;

    Argument[] args;

    bool declaration;

    ASTStatement statement;

    this(string name, Type ret, Argument[] args, bool declaration, ASTStatement statement)
    {
        this.name = name;
        this.ret = ret;
        this.args = [...args];
        this.declaration = declaration;
        this.statement = statement;
    }

    void emit(Generator generator, Context module_)
    {
        assert(!generator.fun);
        assert(false);
        /*generator.fun = generator.mod.define(
            name,
            ret.emit(module_.platform),
            args.map!(a => a.type.emit(module_.platform)).array
        );
        auto stackframe = new FunctionScope(module_.namespace);
        auto argscope = new VarDeclScope(stackframe, Yes.frameBase);
        Statement[] argAssignments;
        foreach (i, arg; args)
        {
            auto argExpr = new ArgExpr(cast(int) i, arg.type);

            argAssignments ~= argscope.declare(arg.name, arg.type, argExpr);
        }

        auto functionBody = statement.compile(module_.withNamespace(argscope));

        generator.frameReg = generator.fun.alloca(stackframe.structType.emit(module_.platform));
        scope (success)
            generator.resetFrame;

        foreach (statement; argAssignments)
        {
            statement.emit(generator);
        }

        functionBody.emit(generator);
        generator.fun.ret(generator.fun.voidLiteral);
        generator.fun = null;*/
    }
}

class ASTFunction
{
    string name;

    ASTType ret;

    ASTArgument[] args;

    bool isDeclaration;

    ASTStatement statement;

    this(string name, ASTType ret, ASTArgument[] args, bool isDeclaration, ASTStatement statement)
    {
        this.name = name;
        this.ret = ret;
        this.args = [...args];
        this.isDeclaration = isDeclaration;
        this.statement = statement;
    }

    Function compile(Context context)
    {
        Argument[] arguments;
        for (int i = 0; i < this.args.length; i = i + 1)
        {
            ASTArgument arg = this.args[i];
            arguments = [...arguments, new Argument(arg.name, arg.type.compile(context))];
        }

        return new Function(
            this.name,
            this.ret.compile(context),
            arguments,
            this.isDeclaration,
            this.statement);
    }
}

ASTArgument[] parseIdentifierList(Parser parser)
{
    ASTArgument[] args;
    while (!parser.accept(")"))
    {
        if (args.length)
        {
            if (!parser.accept(","))
            {
                parser.fail("',' or ')' expected");
            }
        }
        ASTType argtype = parseType(parser);
        string argname = parseIdentifier(parser);
        args = [...args, new ASTArgument(argname, argtype)];
    }
    return args;
}

class Expression : Symbol
{
    Type type() { assert(false); }
    int emit(Generator output) { assert(false); }
}

Expression beExpression(Symbol symbol)
{
    Expression expr = symbol.instanceOf(Expression);
    assert(expr);
    return expr;
}

class ASTReturnStatement : ASTStatement
{
    ASTSymbol value;

    this(ASTSymbol value) { this.value = value; }

    Statement compile(Context context)
    {
        Expression expr = beExpression(this.value.compile(context));

        return new ReturnStatement(expr);
    }
}

ASTReturnStatement parseReturn(Parser parser)
{
    parser.begin();
    if (parseIdentifier(parser) != "return")
    {
        parser.revert();
        return null;
    }
    ASTSymbol expr;
    /*if (parser.accept(";")) // return;
    {
        expr = new ASTVoidExpression;
    }
    else
    {*/
        expr = parseExpression(parser);
        parser.expect(";");
    //}
    parser.commit();
    return new ASTReturnStatement(expr);
}

ASTStatement parseStatement(Parser parser)
{
    {
        Statement stmt = parseReturn(parser);
        if (stmt) return stmt;
    }
    {
        Statement stmt = parseIf(parser);
        if (stmt) return stmt;
    }
    {
        Statement stmt = parseScope(parser);
        if (stmt) return stmt;
    }
    parser.fail("statement expected");
    assert(false);
}

ASTFunction parseFunction(Parser parser)
{
    parser.begin();
    ASTType ret = parseType(parser);
    if (!ret)
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    parser.expect("(");
    ASTArgument[] args = parseIdentifierList(parser);
    ASTStatement stmt = parseStatement(parser);
    parser.commit();
    return new ASTFunction(name, ret, args, false, stmt);
}

void main() {
    string src = "
        int ack(int m, int n) {
            if (m == 0) return n + 1;
            if (n == 0) return ack(m - 1, 1);
            return ack(m - 1, ack(m, n - 1));
        }
    ";

    Parser parser = new Parser(src);
    print("--------");
    ASTType returnType = parseLeafType(parser);
    assert(returnType);
}
