module parser;

import backend.proxy;

extern(C) void print(char[]);
extern(C) void assert(int);
extern(C) int atoi(char[]);

class Parser
{
    string[] stack;

    int level;

    this(string text)
    {
        this.stack = [text];
        this.level = 0;
        this.verify();
    }

    void verify()
    {
        assert(this.stack.length > 0);
        assert(this.level <= this.stack.length);
    }

    string* textp()
    {
        this.verify();
        return &this.stack[this.level];
    }

    string text()
    {
        return *this.textp();
    }

    void begin()
    {
        this.verify();
        if (this.level == this.stack.length - 1)
        {
            this.stack = [...this.stack, this.text()];
        }
        else
        {
            this.stack[this.level + 1] = this.text();
        }
        this.level = this.level + 1;
    }

    void commit()
    {
        assert(this.level > 0);
        this.verify();
        this.stack[this.level - 1] = this.text();
        this.level = this.level - 1;
        this.verify();
    }

    void revert()
    {
        this.verify();
        this.level = this.level - 1;
    }

    bool accept(string match)
    {
        this.begin();
        this.strip();
        if (this.text().length < match.length)
        {
            this.revert();
            return false;
        }
        if (this.text()[0 .. match.length] == match)
        {
            (*this.textp()) = this.text()[match.length .. this.text().length];
            this.commit();
            return true;
        }
        this.revert();
        return false;
    }

    void expect(string match)
    {
        if (!this.accept(match))
        {
            this.fail([..."'", ... match, ..."' expected"]);
        }
    }

    bool eof()
    {
        this.begin();
        this.strip();
        if (this.text().length == 0)
        {
            this.commit();
            return true;
        }
        this.revert();
        return false;
    }

    void strip()
    {
        while (true)
        {
            /* this.text = this.text.strip; */
            while (this.text().length > 0 && isWhitespace(this.text()[0 .. 1]))
            {
                *this.textp() = this.text()[1 .. this.text().length];
            }
            if (!startsWith(this.text(), "/*")) return;
            *this.textp() = this.text()["/*".length .. this.text().length];
            int commentLevel = 1;
            while (commentLevel > 0)
            {
                int more = find(this.text(), "/*");
                int less = find(this.text(), "*/");

                if (more == -1 && less == -1) this.fail("comment spans end of file");
                if (less != -1 && (more == -1 || less < more))
                {
                    *this.textp() = this.text()[less + "*/".length .. this.text().length];
                    commentLevel = commentLevel - 1;
                }
                if (more != -1 && (less == -1 || more < less))
                {
                    *this.textp() = this.text()[more + "/*".length .. this.text().length];
                    commentLevel = commentLevel + 1;
                }
            }
        }
    }

    void fail(string message)
    {
        print("failing:");
        print(message);
        print(this.text());
        /* assert(false, format!"at %s: %s"(this.text, msg)); */
        assert(false); /* TODO */
    }
}

bool startsWith(string haystack, string needle)
{
    return haystack.length >= needle.length && haystack[0 .. needle.length] == needle;
}

int find(string haystack, string needle)
{
    for (int i = 0; i <= haystack.length - needle.length; i = i + 1)
    {
        if (haystack[i .. i + needle.length] == needle) return i;
    }
    return -1;
}

bool parseNumber(Parser parser, int* ip)
{
    parser.begin();
    parser.strip();
    if (parser.eof() || !isNumber(parser.text()[0 .. 1]))
    {
        parser.revert();
        return false;
    }
    string number;
    while (!parser.eof() && isNumber(parser.text()[0 .. 1]))
    {
        number = [...number, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    *ip = atoi(number);
    return true;
}

bool isNumber(string s)
{
    assert(s.length == 1);
    return find("0123456789", s) != -1;
}

bool isAlpha(string s)
{
    assert(s.length == 1);
    return find("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", s) != -1;
}

bool isAlnum(string s)
{
    return isAlpha(s) || isNumber(s);
}

bool isWhitespace(string s)
{
    return s == " " || s == "\t" || s == "\r" || s == "\n";
}

string parseIdentifier(Parser parser)
{
    parser.begin();
    parser.strip();
    if (parser.text().length == 0 || (!isAlpha(parser.text()[0 .. 1]) && parser.text()[0 .. 1] != "_"))
    {
        parser.revert();
        return "";
    }
    string identifier;
    while (parser.text().length > 0 && (isAlnum(parser.text()[0 .. 1]) || parser.text()[0 .. 1] == "_"))
    {
        identifier = [...identifier, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    return identifier;
}

bool acceptIdentifier(Parser parser, string identifier)
{
    parser.begin();
    if (parseIdentifier(parser) != identifier)
    {
        parser.revert();
        return false;
    }
    parser.commit();
    return true;
}

// something that can be referenced by a name
class Symbol
{
}

class Namespace
{
    Namespace parent; // lexical parent

    this(Namespace parent) { this.parent = parent; }

    Symbol lookup(string name) { assert(false); }
}

class Context
{
    void* platform;

    Namespace namespace;

    this(void* platform, Namespace namespace) { this.platform = platform; this.namespace = namespace; }

    Context withNamespace(Namespace namespace)
    {
        return new Context(this.platform, namespace);
    }
}

class ASTSymbol
{
    Symbol compile(Context context) { assert(false); }
}

class Type
{
    void* emit(void* platform) { assert(false); }
    bool same(Type type) { return false; }
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

class Integer : Type
{
    void* emit(Platform platform)
    {
        return platform.intType();
    }

    bool same(Type other) { return !!other.instanceOf(Integer); }
}

class ASTInteger : ASTType
{
    Type compile(Context context) {
        return new Integer;
    }
}

class NamedType : ASTType
{
    string name;

    this(string name) { assert(name.length > 0); this.name = name; }

    Type compile(Context context)
    {
        Symbol target = context.namespace.lookup(this.name);

        if (!target || !target.instanceOf(Type)) {
            print([...this.name, ..." is not a type"]);
            assert(false);
        }
        return target.instanceOf(Type);
    }
}

ASTType parseLeafType(Parser parser)
{
    parser.begin();

    string identifier = parseIdentifier(parser);

    if (!identifier.length)
    {
        parser.revert();
        return null;
    }

    if (identifier == "int")
    {
        parser.commit();
        return new ASTInteger;
    }

    return new NamedType(identifier);
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

ASTType parseType(Parser parser)
{
    ASTType current = parseLeafType(parser);
    return current;
}

class ASTArgument
{
    string name;

    ASTType type;

    this(string name, ASTType type)
    {
        this.name = name;
        this.type = type;
    }
}

class Generator
{
    BackendModule mod;

    BackendFunction fun;

    Platform platform;

    int frameReg;

    this(Platform platform, BackendModule mod)
    {
        this.platform = platform;
        this.mod = mod;
        this.fun = null;
    }
}

class Statement
{
    void emit(Generator output) { assert(false); }
}

class ASTStatement
{
    Statement compile(Context context) { assert(false); }
}

class Argument
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class Function : Symbol
{
    string name;

    Type ret;

    Argument[] args;

    bool declaration;

    ASTStatement statement;

    this(string name, Type ret, Argument[] args, bool declaration, ASTStatement statement)
    {
        this.name = name;
        this.ret = ret;
        this.args = [...args];
        this.declaration = declaration;
        this.statement = statement;
    }

    void emit(Generator generator, Context module_)
    {
        assert(!generator.fun);
        void*[] argTypes;
        for (int i = 0; i < this.args.length; i = i + 1)
        {
            argTypes = [...argTypes, this.args[i].type.emit(module_.platform)];
        }
        assert(module_);
        generator.fun = generator.mod.define(
            this.name,
            this.ret.emit(module_.platform),
            argTypes
        );
        FunctionScope stackframe = new FunctionScope(module_.namespace);
        VarDeclScope argscope = new VarDeclScope(stackframe, true);
        Statement[] argAssignments;
        for (int i = 0; i < this.args.length; i = i + 1)
        {
            Argument arg = this.args[i];
            ArgExpr argExpr = new ArgExpr(i, arg.type);

            argAssignments = [...argAssignments, argscope.declare(arg.name, arg.type, argExpr)];
        }

        Statement functionBody = this.statement.compile(module_.withNamespace(argscope));

        generator.frameReg = generator.fun.alloca(stackframe.structType().emit(module_.platform));

        for (int i = 0; i < argAssignments.length; i = i + 1)
        {
            argAssignments[i].emit(generator);
        }

        functionBody.emit(generator);
        generator.fun.ret(generator.fun.voidLiteral());
        generator.fun = null;
        generator.frameReg = 0;
    }
}

class ASTFunction
{
    string name;

    ASTType ret;

    ASTArgument[] args;

    bool isDeclaration;

    ASTStatement statement;

    this(string name, ASTType ret, ASTArgument[] args, bool isDeclaration, ASTStatement statement)
    {
        this.name = name;
        this.ret = ret;
        this.args = [...args];
        this.isDeclaration = isDeclaration;
        this.statement = statement;
    }

    Function compile(Context context)
    {
        Argument[] arguments;
        for (int i = 0; i < this.args.length; i = i + 1)
        {
            ASTArgument arg = this.args[i];
            Type type = arg.type.compile(context);
            arguments = [...arguments, new Argument(arg.name, type)];
        }

        return new Function(
            this.name,
            this.ret.compile(context),
            arguments,
            this.isDeclaration,
            this.statement);
    }
}

ASTArgument[] parseIdentifierList(Parser parser)
{
    ASTArgument[] args;
    while (!parser.accept(")"))
    {
        if (args.length)
        {
            if (!parser.accept(","))
            {
                parser.fail("',' or ')' expected");
            }
        }
        ASTType argtype = parseType(parser);
        string argname = parseIdentifier(parser);
        args = [...args, new ASTArgument(argname, argtype)];
    }
    return args;
}

class Expression : Symbol
{
    Type type() { assert(false); }
    int emit(Generator output) { assert(false); }
}

Expression beExpression(Symbol symbol)
{
    Expression expr = symbol.instanceOf(Expression);
    assert(expr);
    return expr;
}

class Reference : Expression
{
    int emitLocation(Generator output) { assert(false); }
}

class BinaryOp : Expression
{
    string op;

    Expression left;

    Expression right;

    this(string op, Expression left, Expression right)
    {
        this.op = op;
        this.left = left;
        this.right = right;
    }

    Type type()
    {
        return new Integer;
    }

    int emit(Generator output)
    {
        assert(this.left.type().instanceOf(Integer));
        assert(this.right.type().instanceOf(Integer));
        int leftreg = this.left.emit(output);
        int rightreg = this.right.emit(output);
        string op;
        if (this.op == "add") op = "+";
        else if (this.op == "sub") op = "-";
        else if (this.op == "eq") op = "==";
        else { print(this.op); assert(false); }
        return output.fun.binop(op, leftreg, rightreg);
    }
}

class ArgExpr : Expression
{
    int index;

    Type type_;

    this(int index, Type type_) { this.index = index; this.type_ = type_; }

    int emit(Generator output)
    {
        return output.fun.arg(this.index);
    }

    Type type()
    {
        return this.type_;
    }
}

Expression implicitConvertTo(Expression from, Type to)
{
    if (from.type().same(to)) return from;
    // void* casts to any pointer
    /*if (to.instanceOf(Pointer) && from.type().same(new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    // any pointer casts to void*
    if (from.type().instanceOf(Pointer) && to.same(new Pointer(new Void)))
    {
        return new PointerCast(to, from);
    }
    if (to.instanceOf(Class) && from.type().instanceOf(Class))
    {
        Class currentClass = from.type().instanceOf(Class);

        while (currentClass)
        {
            if (currentClass.same(to))
            {
                return new PointerCast(to, from);
            }
            currentClass = currentClass.superClass;
        }
    }
    if (cast(Class) to && cast(NullExpr) from)
    {
        return new PointerCast(to, from);
    }
    // TODO bool
    if (cast(Integer) to && (cast(Pointer) from.type || cast(Class) from.type))
    {
        auto voidp = new Pointer(new Void);
        auto rt_ptr_test = new Function("cxruntime_ptr_test",
            new Integer,
            [Argument("", voidp)],
            true, null);
        return new Call(rt_ptr_test, [new PointerCast(voidp, from)]);
    }*/
    print("todo: cast error");
    assert(false);
}

class Call : Expression
{
    Function function_;

    Expression[] args;

    this(Function function_, Expression[] args)
    {
        /*assert(function_.args.length == args.length, format!"'%s' expected %s args, not %s"(
            function_.name, function_.args.length, args.length));*/
        assert(function_.args.length == args.length);

        for (int i = 0; i < args.length; i = i + 1)
        {
            args[i] = implicitConvertTo(args[i], function_.args[i].type);
        }
        this.function_ = function_;
        this.args = [...args];
    }

    Type type()
    {
        return this.function_.ret;
    }

    int emit(Generator output)
    {
        int[] regs;
        for (int i = 0; i < this.args.length; i = i + 1) {
            regs = [...regs, this.args[i].emit(output)];
        }
        return output.fun.call(this.type().emit(output.platform), this.function_.name, regs);
    }
}

Expression call(Symbol target, Expression[] args)
{
    if (target.instanceOf(Function))
    {
        return new Call(target.instanceOf(Function), args);
    }
    /*if (auto method = cast(ClassMethod) target)
    {
        return new FuncPtrCall(method.funcPtr, [method.thisPtr] ~ args);
    }
    auto expr = cast(Expression) target;
    if (expr && cast(FunctionPointer) expr.type)
    {
        return new FuncPtrCall(expr, args);
    }*/
    // assert(false, format!"unknown call target %s (%s?)"(target, expr ? expr.type : null));
    assert(false);
}

class ASTCall : ASTSymbol
{
    ASTSymbol target;

    ASTSymbol[] args;

    this(ASTSymbol target, ASTSymbol[] args)
    {
        this.target = target;
        this.args = [...args];
    }

    Expression compile(Context context)
    {
        Symbol target = this.target.compile(context);
        Expression[] args;
        for (int i = 0; i < this.args.length; i = i + 1)
        {
            args = [...args, beExpression(this.args[i].compile(context))];
        }
        return call(target, args);
    }
}

ASTSymbol[] parseSymbolList(Parser parser)
{
    ASTSymbol[] args;
    while (!parser.accept(")"))
    {
        if (args.length > 0)
            parser.expect(",");
        args = [...args, parseExpression(parser)];
    }
    return args;
}

ASTCall parseCall(Parser parser, ASTSymbol base)
{
    parser.begin();
    if (!parser.accept("("))
    {
        parser.revert();
        return null;
    }
    ASTSymbol[] args = parseSymbolList(parser);
    parser.commit();
    return new ASTCall(base, args);
}

ASTSymbol parseProperties(Parser parser, ASTSymbol current)
{
    while (true)
    {
        bool any = false;
        {
            ASTSymbol expr = parseCall(parser, current);
            if (expr)
            {
                any = true;
                current = expr;
            }
        }
        if (!any) return current;
        /*if (auto expr = parser.parseInstanceOf(current))
        {
            current = expr;
            continue;
        }
        if (auto expr = parser.parseCall(current))
        {
            current = expr;
            continue;
        }
        if (auto expr = parser.parseMember(current))
        {
            current = expr;
            continue;
        }
        if (auto expr = parser.parseIndex(current))
        {
            current = expr;
            continue;
        }
        break;*/
    }
}

ASTSymbol parseExpressionLeaf(Parser parser)
{
    /*if (accept("*"))
    {
        auto next = parser.parseExpressionLeaf;

        assert(next !is null);
        return new ASTDereference(next);
    }
    if (accept("&"))
    {
        auto next = parser.parseExpressionLeaf;

        assert(next !is null);
        return new ASTReference(next);
    }
    if (parser.acceptIdentifier("new"))
    {
        auto type = parser.parseType;
        Nullable!(ASTSymbol[]) args;
        if (accept("("))
        {
            args = parser.parseSymbolList;
        }

        return new ASTNewClassExpression(type, args);
    }
    if (accept("!"))
    {
        auto next = parser.parseExpressionLeaf;

        assert(next !is null);
        return new ASTNegation(next);
    }*/
    ASTSymbol currentExpr = parseExpressionBase(parser);
    assert(currentExpr);
    return parseProperties(parser, currentExpr);
}

class Variable : ASTSymbol
{
    string name;

    this(string name) { this.name = name; }

    Symbol compile(Context context)
    {
        Symbol symbol = context.namespace.lookup(this.name);
        assert(symbol);
        return symbol;
    }
}

class ASTLiteral : ASTSymbol
{
    int value;

    this(int value) { this.value = value; }

    Symbol compile(Context context)
    {
        return new Literal(this.value);
    }
}

class Literal : Expression
{
    int value;

    this(int value) { this.value = value; }

    Type type()
    {
        return new Integer;
    }

    int emit(Generator output)
    {
        return output.fun.intLiteral(this.value);
    }
}

ASTSymbol parseExpressionBase(Parser parser)
{
    string name = parseIdentifier(parser);
    if (name.length)
    {
        return new Variable(name);
    }
    int i;
    if (parseNumber(parser, &i))
    {
        return new ASTLiteral(i);
    }
    /*if (parser.accept("\""))
    {
        return parser.parseStringLiteral("\"");
    }
    if (parser.accept("("))
    {
        auto result = parser.parseExpression;
        parser.expect(")");
        return result;
    }
    if (auto arrayLiteral = parser.parseArrayLiteral)
    {
        return arrayLiteral;
    }*/
    parser.fail("Base expression expected.");
    assert(false);
}

class ASTBinaryOp : ASTSymbol
{
    string op;

    ASTSymbol left;

    ASTSymbol right;

    this(string op, ASTSymbol left, ASTSymbol right) { this.op = op; this.left = left; this.right = right; }

    Expression compile(Context context)
    {
        Expression left = beExpression(this.left.compile(context));
        Expression right = beExpression(this.right.compile(context));

        return new BinaryOp(this.op, left, right);
    }
}

ASTSymbol parseAddSub(Parser parser, ASTSymbol left, int myLevel)
{
    while (true)
    {
        if (parser.accept("+"))
        {
            ASTSymbol right = parseArithmetic(parser, myLevel + 1);

            left = new ASTBinaryOp("add", left, right);
        }
        else if (parser.accept("-"))
        {
            ASTSymbol right = parseArithmetic(parser, myLevel + 1);

            left = new ASTBinaryOp("sub", left, right);
        } else return left;
    }
}

ASTSymbol parseComparison(Parser parser, ASTSymbol left, int myLevel)
{
    if (parser.accept("=="))
    {
        ASTSymbol right = parseArithmetic(parser, myLevel + 1);

        return new ASTBinaryOp("eq", left, right);
    }
    return left;
    /*
    if (parser.accept("!=")) // same as !(a == b)
    {
        auto right = parser.parseArithmetic(myLevel + 1);
        left = new ASTNegation(new ASTBinaryOp(BinaryOpType.eq, left, right));
    }
    if (parser.accept(">="))
    {
        auto right = parser.parseArithmetic(myLevel + 1);
        left = new ASTBinaryOp(BinaryOpType.ge, left, right);
    }
    if (parser.accept(">"))
    {
        auto right = parser.parseArithmetic(myLevel + 1);
        left = new ASTBinaryOp(BinaryOpType.gt, left, right);
    }
    if (parser.accept("<="))
    {
        auto right = parser.parseArithmetic(myLevel + 1);
        left = new ASTBinaryOp(BinaryOpType.le, left, right);
    }
    if (parser.accept("<"))
    {
        auto right = parser.parseArithmetic(myLevel + 1);
        left = new ASTBinaryOp(BinaryOpType.lt, left, right);
    }*/
}

ASTSymbol parseArithmetic(Parser parser, int level)
{
    ASTSymbol left = parseExpressionLeaf(parser);

    if (level <= 1)
    {
        left = parseAddSub(parser, left, 1);
    }
    if (level <= 0)
    {
        left = parseComparison(parser, left, 0);
    }
    /*if (level <= 4)
    {
        left = parseMul(parser, left, 4);
    }
    if (level <= 3)
    {
        left = parseAddSub(parser, left, 3);
    }
    if (level <= 2)
    {
        left = parseComparison(parser, left, 2);
    }
    if (level <= 1)
    {
        left = parseBoolAnd(parser, left, 1);
    }
    if (level <= 0)
    {
        left = parseBoolOr(parser, left, 0);
    }*/
    return left;
}

ASTSymbol parseExpression(Parser parser)
{
    return parseArithmetic(parser, 0);
}

class ReturnStatement : Statement
{
    Expression value;

    this(Expression value) { this.value = value; }

    void emit(Generator output)
    {
        int reg = this.value.emit(output);

        output.fun.ret(reg);
    }
}

class ASTReturnStatement : ASTStatement
{
    ASTSymbol value;

    this(ASTSymbol value) { this.value = value; }

    Statement compile(Context context)
    {
        Expression expr = beExpression(this.value.compile(context));

        return new ReturnStatement(expr);
    }
}

ASTReturnStatement parseReturn(Parser parser)
{
    parser.begin();
    string identifier = parseIdentifier(parser);
    if (identifier != "return")
    {
        parser.revert();
        return null;
    }
    ASTSymbol expr;
    /*if (parser.accept(";")) // return;
    {
        expr = new ASTVoidExpression;
    }
    else
    {*/
        expr = parseExpression(parser);
        parser.expect(";");
    //}
    parser.commit();
    return new ASTReturnStatement(expr);
}

class StructMemberDeclaration
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    this(string name, StructMemberDeclaration[] members)
    {
        this.name = name;
        this.members = [...members];
    }

    bool same(Type other) {
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct || otherStruct.members.length != this.members.length) return false;
        for (int i = 0; i < this.members.length; i = i + 1)
        {
            if (!this.members[i].type.same(otherStruct.members[i].type)) return false;
        }
        return true;
    }

    void* emit(Platform platform)
    {
        void*[] memberTypes;
        for (int i = 0; i < this.members.length; i = i + 1)
        {
            memberTypes = [...memberTypes, this.members[i].type.emit(platform)];
        }
        return platform.structType(memberTypes);
    }
}

class StructMember : Reference
{
    Reference base;

    int index;

    this(Reference base, int index)
    {
        this.base = base;
        this.index = index;
    }

    Type type()
    {
        Type type = this.base.type();
        Struct structType = type.instanceOf(Struct);
        assert(structType);
        return structType.members[this.index].type;
    }

    int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type().emit(output.platform), locationReg);
    }

    int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type().emit(output.platform), reg, this.index);
    }
}

class StackFrame : Reference
{
    Type targetType;

    this(Type targetType) { this.targetType = targetType; }

    Type type()
    {
        return this.targetType;
    }

    int emit(Generator generator)
    {
        assert(false);
    }

    int emitLocation(Generator generator)
    {
        return generator.frameReg;
    }
}

class FunctionScope : Namespace
{
    Type[] variableTypes;

    this(Namespace parent) { this.parent = parent; }

    StructMember declare(Type type)
    {
        this.variableTypes = [...this.variableTypes, type];

        return new StructMember(
            new StackFrame(this.structType()),
            this.variableTypes.length - 1);
    }

    Struct structType()
    {
        StructMemberDeclaration[] members;
        for (int i = 0; i < this.variableTypes.length; i = i + 1)
        {
            members = [...members, new StructMemberDeclaration("", this.variableTypes[i])];
        }
        return new Struct("", members);
    }

    Symbol lookup(string name)
    {
        assert(this.parent);
        return this.parent.lookup(name);
    }
}

FunctionScope findFunctionScope(Namespace namespace)
{
    FunctionScope functionScope = namespace.instanceOf(FunctionScope);
    if (functionScope) return functionScope;
    assert(namespace.parent);
    return findFunctionScope(namespace.parent);
}

class AssignStatement : Statement
{
    Reference target;

    Expression value;

    this(Reference target, Expression value) { this.target = target; this.value = value; }

    void emit(Generator output)
    {
        Type targetType = this.target.type();
        Type valueType = this.value.type();
        /*assert(targetType == valueType,
                format!"%s - %s => %s - %s"(this.target, this.value, targetType, valueType));*/

        int target_reg = this.target.emitLocation(output);
        int value_reg = this.value.emit(output);

        output.fun.store(valueType.emit(output.platform), target_reg, value_reg);
    }
}

class NoopStatement : Statement
{
    void emit(Generator generator)
    {
    }
}

class DeclaredVariable
{
    string name;

    Expression value;

    this(string name, Expression value) { this.name = name; this.value = value; }
}

class VarDeclScope : Namespace
{
    DeclaredVariable[] declarations;

    bool frameBase; // base of function frame. all variables here are parameters.

    this(Namespace parent, bool frameBase)
    {
        this.parent = parent;
        this.frameBase = frameBase;
    }

    Statement declare(string name, Type type, Expression value)
    {
        StructMember member = findFunctionScope(this).declare(type);

        this.declarations = [...this.declarations, new DeclaredVariable(name, member)];
        // return new AssignStatement(member, implicitConvertTo(value, type));
        return new AssignStatement(member, value);
    }

    Statement declareType(string name, Type type)
    {
        StructMember member = findFunctionScope(this).declare(type);

        this.declarations = [...this.declarations, new DeclaredVariable(name, member)];
        return new NoopStatement;
    }

    Symbol lookup(string name)
    {
        for (int i = 0; i < this.declarations.length; i = i + 1)
        {
            if (this.declarations[i].name == name)
            {
                return this.declarations[i].value;
            }
        }
        if (this.parent)
            return this.parent.lookup(name);
        return null;
    }
}

VarDeclScope findVarDeclScope(Namespace namespace)
{
    VarDeclScope varDeclScope = namespace.instanceOf(VarDeclScope);
    if (varDeclScope) return varDeclScope;
    assert(namespace.parent);
    return findVarDeclScope(namespace.parent);
}

class ASTIfStatement : ASTStatement
{
    ASTSymbol test;

    ASTStatement then;

    ASTStatement else_;

    this(ASTSymbol test, ASTStatement then, ASTStatement else_)
    {
        this.test = test;
        this.then = then;
        this.else_ = else_;
    }

    Statement compile(Context context)
    {
        VarDeclScope ifscope = new VarDeclScope(context.namespace, false);
        Symbol test = this.test.compile(context.withNamespace(ifscope));
        Statement then = this.then.compile(context.withNamespace(ifscope));
        Statement else_;
        if (this.else_) {
            VarDeclScope elsescope = new VarDeclScope(context.namespace, false);
            else_ = this.else_.compile(context.withNamespace(elsescope));
        }

        return new IfStatement(beExpression(test), then, else_);
    }
}

class IfStatement : Statement
{
    Expression test;

    Statement then;

    Statement else_;

    this(Expression test, Statement then, Statement else_)
    {
        this.test = test;
        this.then = then;
        this.else_ = else_;
    }

    void emit(Generator output)
    {
        int reg = this.test.emit(output);

        TestBranchRecord tbrRecord = output.fun.testBranch(reg);

        tbrRecord.resolveThen(output.fun.blockIndex());
        this.then.emit(output);
        BranchRecord brRecord = output.fun.branch();
        tbrRecord.resolveElse(output.fun.blockIndex());

        if (this.else_)
        {
            this.else_.emit(output);
            BranchRecord elseBrRecord = output.fun.branch();

            elseBrRecord.resolve(output.fun.blockIndex());
        }
        brRecord.resolve(output.fun.blockIndex());
    }
}

ASTIfStatement parseIf(Parser parser)
{
    parser.begin();
    string identifier = parseIdentifier(parser);
    if (identifier != "if")
    {
        parser.revert();
        return null;
    }
    parser.expect("(");
    ASTSymbol expr = parseExpression(parser);
    parser.expect(")");
    ASTStatement thenStmt = parseStatement(parser);
    ASTStatement elseStatement;
    if (parser.accept("else"))
    {
        elseStatement = parseStatement(parser);
    }
    parser.commit();
    return new ASTIfStatement(expr, thenStmt, elseStatement);
}

class ASTScopeStatement : ASTStatement
{
    ASTStatement[] statements;

    this(ASTStatement[] statements) { this.statements = [...statements]; }

    Statement compile(Context context)
    {
        VarDeclScope subscope = new VarDeclScope(context.namespace, false);

        Statement[] statements;
        for (int i = 0; i < this.statements.length; i = i + 1)
        {
            statements = [...statements, this.statements[i].compile(context.withNamespace(subscope))];
        }
        return new SequenceStatement(statements);
    }
}

class SequenceStatement : Statement
{
    Statement[] statements;

    this(Statement[] statements) { this.statements = [...statements]; }

    void emit(Generator output)
    {
        for (int i = 0; i < this.statements.length; i = i + 1)
        {
            this.statements[i].emit(output);
        }
    }
}

ASTScopeStatement parseScope(Parser parser)
{
    if (!parser.accept("{"))
    {
        return null;
    }
    ASTStatement[] statements;
    while (!parser.accept("}"))
    {
        ASTStatement stmt = parseStatement(parser);
        statements = [...statements, stmt];
    }
    return new ASTScopeStatement(statements);
}

class ASTAssignStatement : ASTStatement
{
    ASTSymbol target;

    ASTSymbol value;

    this(ASTSymbol target, ASTSymbol value)
    {
        this.target = target;
        this.value = value;
    }

    Statement compile(Context context)
    {
        Symbol target = this.target.compile(context);
        Expression value = beExpression(this.value.compile(context));
        Reference targetref = target.instanceOf(Reference);
        value = implicitConvertTo(value, targetref.type());
        if (!targetref) {
            print("target of assignment must be a reference");
            assert(false);
        }
        return new AssignStatement(targetref, value);
    }
}

class AssignStatement : Statement
{
    Reference target;

    Expression value;

    this(Reference target, Expression value) { this.target = target; this.value = value; }

    void emit(Generator output)
    {
        Type targetType = this.target.type();
        Type valueType = this.value.type();

        // TODO
        /*assert(targetType == valueType,
                format!"%s - %s => %s - %s"(this.target, this.value, targetType, valueType));*/

        int target_reg = this.target.emitLocation(output);
        int value_reg = this.value.emit(output);

        output.fun.store(valueType.emit(output.platform), target_reg, value_reg);
    }
}

ASTAssignStatement parseAssignment(Parser parser)
{
    parser.begin();
    ASTSymbol lhs = parseExpressionLeaf(parser);
    if (!lhs || !parser.accept("="))
    {
        parser.revert();
        return null;
    }
    ASTSymbol expr = parseExpression(parser);
    parser.commit();
    return new ASTAssignStatement(lhs, expr);
}

ASTAssignStatement parseAssignStatement(Parser parser)
{
    ASTAssignStatement ret = parseAssignment(parser);
    if (ret)
    {
        parser.expect(";");
        return ret;
    }
    return null;
}

class ASTVarDeclStatement : ASTStatement
{
    string name;

    ASTType type;

    ASTSymbol initial;

    this(string name, ASTType type, ASTSymbol initial)
    {
        this.name = name;
        this.type = type;
        this.initial = initial;
    }

    Statement compile(Context context)
    {
        if (this.initial)
        {
            Symbol initial = this.initial.compile(context);

            return findVarDeclScope(context.namespace).declare(
                this.name, this.type.compile(context), beExpression(initial));
        }
        else
        {
            return findVarDeclScope(context.namespace).declare(
                this.name, this.type.compile(context));
        }
    }
}

ASTVarDeclStatement parseVarDecl(Parser parser)
{
    parser.begin();
    ASTType type = parseType(parser);
    if (!type)
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    if (!name.length)
    {
        parser.revert();
        return null;
    }
    ASTSymbol initial;
    if (parser.accept("="))
    {
        initial = parseExpression(parser);
        assert(initial);
    }
    parser.expect(";");
    parser.commit();
    return new ASTVarDeclStatement(name, type, initial);
}

ASTStatement parseStatement(Parser parser)
{
    {
        ASTStatement stmt = parseReturn(parser);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseIf(parser);
        if (stmt) return stmt;
    }
    // if (auto stmt = parser.parseWhile) return stmt;
    // if (auto stmt = parser.parseFor) return stmt;
    {
        ASTStatement stmt = parseScope(parser);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseVarDecl(parser);
        if (stmt) return stmt;
    }
    {
        ASTStatement stmt = parseAssignStatement(parser);
        if (stmt) return stmt;
    }
    // if (auto stmt = parser.parseExprStatement) return stmt;
    parser.fail("statement expected");
    assert(false);
}

ASTFunction parseFunction(Parser parser)
{
    parser.begin();
    ASTType ret = parseType(parser);
    if (!ret)
    {
        parser.revert();
        return null;
    }
    string name = parseIdentifier(parser);
    parser.expect("(");
    ASTArgument[] args = parseIdentifierList(parser);
    ASTStatement stmt = parseStatement(parser);
    parser.commit();
    return new ASTFunction(name, ret, args, false, stmt);
}

class ModuleEntry
{
    string name;

    Symbol value;

    this(string name, Symbol value) { this.name = name; this.value = value; }
}

class Module : Namespace
{
    string name;

    this(string name)
    {
        this.parent = null;
        this.name = name;
    }

    // Module[] imports;

    ModuleEntry[] entries;

    void add(string name, Symbol symbol)
    {
        this.entries = [...this.entries, new ModuleEntry(name, symbol)];
    }

    /*
    void addImport(Module module_)
    {
        imports ~= module_;
    }

    void emit(Generator generator)
    in (generator.fun is null)
    {
        foreach (entry; entries)
        {
            if (auto fun = cast(Function) entry.value)
                if (!fun.declaration)
                    fun.emit(generator, Context(generator.platform, this));
            if (auto class_ = cast(Class) entry.value)
            {
                foreach (method; class_.methods)
                {
                    method.emit(generator, this, class_);
                }
            }
        }
        // TODO each only once!
        foreach (import_; imports) import_.emit(generator);
    }
    */

    Symbol lookupPublic(string name)
    {
        // not counting imports (non-transitive)
        for (int i = 0; i < this.entries.length; i = i + 1)
        {
            if (this.entries[i].name == name)
                return this.entries[i].value;
        }
        return null;
    }

    Symbol lookup(string name)
    {
        Symbol public_ = this.lookupPublic(name);
        if (public_) return public_;
        /*foreach (import_; this.imports)
        {
            // TODO error on multiple matches
            if (auto entry = import_.lookupPublic(name))
                return entry;
        }*/
        if (this.parent)
            return this.parent.lookup(name);
        return null;
    }
}

void main() {
    string src = "
        int ack(int m, int n) {
            if (m == 0) { int n2 = n + 1; return n2; }
            if (n == 0) { m = m - 1; return ack(m, 1); }
            return ack(m - 1, ack(m, n - 1));
        }
    ";

    Parser parser = new Parser(src);
    Backend backend = new Backend();
    print("--------");
    ASTFunction astFun = parseFunction(parser);
    assert(astFun);
    Module module_ = new Module("ack");
    BackendModule backendModule_ = backend.createModule();
    Generator generator = new Generator(new Platform(), backendModule_);
    Function fun = astFun.compile(generator);
    module_.add(fun.name, fun);
    Context context = new Context(generator.platform, module_);
    assert(fun);
    fun.emit(generator, context);
    print("ack(3, 8):");
    int m = 3;
    int n = 8;
    void* mp = &m;
    void* np = &n;
    int ret;
    backendModule_.call(&ret, "ack", [mp, np]);
    assert(ret == 2045); print(" 2045");
}
