module parser;

class Parser
{
    string[] stack;

    int level;

    this(string text)
    {
        this.stack = [text];
        this.level = 0;
    }

    void verify()
    {
        assert(this.stack.length > 0);
        assert(this.level <= this.stack.length);
    }

    string* textp()
    {
        this.verify();
        return &this.stack[this.level];
    }

    string text()
    {
        return *this.textp();
    }

    void begin()
    {
        this.verify();
        if (this.level == this.stack.length - 1)
        {
            this.stack = [...this.stack, this.text()];
        }
        else
        {
            this.stack[this.level + 1] = this.text();
        }
        this.level = this.level + 1;
    }

    void commit()
    {
        this.verify();
        this.stack[this.level - 1] = this.text();
        this.stack = this.stack[0 .. this.stack.length - 1];
    }

    void revert()
    {
        this.verify();
        this.level = this.level - 1;
    }

    int accept(string match)
    {
        this.begin();
        this.strip();
        if (this.text().length < match.length) return 0;
        if (this.text()[0 .. match.length] == match)
        {
            (*this.textp()) = this.text()[match.length .. this.text().length];
            this.commit();
            return 1;
        }
        this.revert();
        return 0;
    }

    void expect(string match)
    {
        if (!this.accept(match))
        {
            /* this.fail(format("'%s' expected.", match)); */
            this.fail("something expected");
        }
    }

    int eof()
    {
        this.begin();
        this.strip();
        if (this.text().length == 0)
        {
            this.commit();
            return 1;
        }
        this.revert();
        return 0;
    }

    void strip()
    {
        while (1)
        {
            /* this.text = this.text.strip; */
            while (this.text().length > 0 && this.text()[0 .. 1] == " ")
            {
                *this.textp() = this.text()[1 .. this.text().length];
            }
            if (!startsWith(this.text(), "/*")) return;
            *this.textp() = this.text()["/*".length .. this.text().length];
            int commentLevel = 1;
            while (commentLevel > 0)
            {
                int more = find(this.text(), "/*");
                int less = find(this.text(), "*/");

                if (more == -1 && less == -1) this.fail("comment spans end of file");
                if (less != -1 && (more == -1 || less < more))
                {
                    *this.textp() = this.text()[less + "*/".length .. this.text().length];
                    commentLevel = commentLevel - 1;
                }
                if (more != -1 && (less == -1 || more < less))
                {
                    *this.textp() = this.text()[more + "/*".length .. this.text().length];
                    commentLevel = commentLevel + 1;
                }
            }
        }
    }

    void fail(string message)
    {
        /* assert(false, format!"at %s: %s"(this.text, msg)); */
        assert(false); /* TODO */
    }
}

int startsWith(string haystack, string needle)
{
    return haystack.length >= needle.length && haystack[0 .. needle.length] == needle;
}

int find(string haystack, string needle)
{
    for (int i = 0; i <= haystack.length - needle.length; i = i + 1)
    {
        if (haystack[i .. i + needle.length] == needle) return i;
    }
    return -1;
}

int parseNumber(Parser parser, int* ip)
{
    parser.begin();
    parser.strip();
    if (parser.eof() || !isNumber(parser.text()[0 .. 1]))
    {
        parser.revert();
        return 0;
    }
    string number;
    while (!parser.eof() && isNumber(parser.text()[0 .. 1]))
    {
        number = [...number, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    *ip = atoi(number);
    return 1;
}

int isNumber(string s)
{
    assert(s.length == 1);
    return find("0123456789", s) != -1;
}

int isAlpha(string s)
{
    assert(s.length == 1);
    return find("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", s) != -1;
}

int isAlnum(string s)
{
    return isAlpha(s) || isNumber(s);
}

string parseIdentifier(Parser parser)
{
    parser.begin();
    parser.strip();
    if (parser.text().length == 0 || (!isAlpha(parser.text()[0 .. 1]) && parser.text()[0 .. 1] != "_"))
    {
        parser.revert();
        return "";
    }
    string identifier;
    while (parser.text().length > 0 && (isAlnum(parser.text()[0 .. 1]) || parser.text()[0 .. 1] == "_"))
    {
        identifier = [...identifier, ...parser.text()[0 .. 1]];
        *parser.textp() = parser.text()[1 .. parser.text().length];
    }
    parser.commit();
    return identifier;
}

int acceptIdentifier(Parser parser, string identifier)
{
    parser.begin();
    if (parseIdentifier(parser) != identifier)
    {
        parser.revert();
        return 0;
    }
    parser.commit();
    return 1;
}

class Symbol
{
}

class Namespace
{
    Namespace parent; // lexical parent

    this(Namespace parent) { this.parent = parent; }

    Symbol lookup(string name) { assert(false); }
}

class Context
{
    /* Platform platform; */

    Namespace namespace;

    this(Namespace namespace) { this.namespace = namespace; }

    Context withNamespace(Namespace namespace)
    {
        /* return new Context(this.platform, namespace); */
        return new Context(namespace);
    }
}

class Type
{
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

void main() {
    string src = "
        int ack(int m, int n) {
            if (m == 0) return n + 1;
            if (n == 0) return ack(m - 1, 1);
            return ack(m - 1, ack(m, n - 1));
        }
    ";

    Parser parser = new Parser(src);
}
