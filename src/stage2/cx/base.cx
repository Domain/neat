module cx.base;

import backend.base;
import cx.linenr;
import helpers;

void assert2s(int test, string msg) { if (!test) { print(msg); assert(false); } }
void assert2s2(int test, string a, string b) { if (!test) { print(a ~ b); assert(false); } }
void assert2s3(int test, string a, string b, string c) { if (!test) { print(a ~ b ~ c); assert(false); } }
void assert2s4(int test, string a, string b, string c, string d) {
    if (!test) { print(a ~ b ~ c ~ d); assert(false); } }
void assert2s5(int test, string a, string b, string c, string d, string e) {
    if (!test) { print(a ~ b ~ c ~ d ~ e); assert(false); } }

class Loc {
    LineNumberRegistry lineNumbers;

    string text;

    this(LineNumberRegistry lineNumbers, string text) {
        this.lineNumbers = lineNumbers;
        this.text = text;
    }

    void fail(string message) {
        this.lineNumbers.print(this.text, message);
        assert(false);
    }

    void assert2s(int test, string msg) { if (!test) this.fail(msg); }
    void assert2s2(int test, string a, string b) { if (!test) this.fail(a ~ b); }
    void assert2s3(int test, string a, string b, string c) { if (!test) this.fail(a ~ b ~ c); }
    void assert2s4(int test, string a, string b, string c, string d) {
        if (!test) this.fail(a ~ b ~ c ~ d); }
    void assert2s5(int test, string a, string b, string c, string d, string e) {
        if (!test) this.fail(a ~ b ~ c ~ d ~ e); }
}

// something that can be referenced by a name
class Symbol
{
}

class Namespace
{
    Namespace parent; // lexical parent

    this(Namespace parent) { this.parent = parent; }

    Symbol lookup(string name) { assert(false); }
}

class Context
{
    Platform platform;

    Namespace namespace;

    CompileMacroState compileMacroState;

    this(Platform platform, Namespace namespace, CompileMacroState compileMacroState)
    {
        this.platform = platform;
        this.namespace = namespace;
        this.compileMacroState = compileMacroState;
    }

    Context withNamespace(Namespace namespace)
    {
        return new Context(this.platform, namespace, this.compileMacroState);
    }
}

class ASTSymbol
{
    Symbol compile(Context context) { assert(false); }
}

class Type : Symbol
{
    BackendType emit(Platform platform) { assert(false); }
    bool same(Type type) { assert(false); }
    string repr() { assert(false); }

    Expression implicitConvertFrom(Expression source)
    {
        return null;
    }

    Expression truthy(Expression expr, Loc loc)
    {
        return null;
    }
}

class ASTType
{
    Type compile(Context context) { assert(false); }
}

class Generator
{
    BackendModule mod;

    BackendFunction fun;

    Platform platform;

    int frameReg;

    this(Platform platform, BackendModule mod)
    {
        this.platform = platform;
        this.mod = mod;
        this.fun = null;
    }

    bool once(string name)
    {
        return this.mod.once(name);
    }
}

class Expression : Symbol
{
    Type type() { assert(false); }
    int emit(Generator output) { assert(false); }
}

Expression beExpression(Symbol symbol)
{
    Expression expr = symbol.instanceOf(Expression);
    assert(!!expr);
    return expr;
}

class Reference : Expression
{
    int emitLocation(Generator output) { assert(false); }
}

class RegExpr : Expression
{
    Type type_;

    int reg;

    this(Type type_, int reg) { this.type_ = type_; this.reg = reg; }

    override Type type()
    {
        return this.type_;
    }

    override int emit(Generator output)
    {
        return this.reg;
    }
}

class PointerCast : Expression
{
    Type target;

    Expression value;

    this(Type target, Expression value) {
        this.target = target;
        this.value = value;
    }

    override Type type()
    {
        return this.target;
    }

    override int emit(Generator output)
    {
        int reg = this.value.emit(output);
        return output.fun.bitcast(reg, this.target.emit(output.platform));
    }
}

class Argument
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class FunctionDeclaration : Symbol
{
    string name;

    Type ret;

    Argument[] args;

    this(string name, Type ret, Argument[] args)
    {
        this.name = name;
        this.ret = ret;
        this.args = args;
    }

    string mangle() { return this.name; } // TODO extern

    void declare(Generator generator)
    {
        auto argTypes = new BackendType[](this.args.length);
        for (int i = 0; i < this.args.length; i = i + 1)
            argTypes[i] = this.args[i].type.emit(generator.platform);

        generator.mod.declare(
            this.name,
            true,
            this.ret.emit(generator.platform),
            argTypes
        );
    }
}

/**
 * A CompileMacro is a macro that hooks into the AST -> SemTree compile step.
 *
 * This is in base because it's circular with Context.
 */
class CompileMacroState
{
    CallMacro[] callMacros;

    CompileMacroState[] imports;

    this() { }

    CompileMacroState dup() {
        auto newState = new CompileMacroState;
        newState.callMacros = new CallMacro[](this.callMacros.length);
        for (int i = 0; i < this.callMacros.length; i = i + 1)
            newState.callMacros[i] = this.callMacros[i];
        newState.imports = new CompileMacroState[](this.imports.length);
        for (int i = 0; i < this.imports.length; i = i + 1)
            newState.imports[i] = this.imports[i];
        return newState;
    }

    CallMacro findCallMacro(string identifier) {
        CallMacro result = this.findCallMacroExported(identifier);
        if (result) return result;
        for (int i = 0; i < this.imports.length; i = i + 1) {
            result = this.imports[i].findCallMacroExported(identifier);
            if (result) return result;
        }
        return null;
    }

    CallMacro findCallMacroExported(string identifier) {
        for (int i = 0; i < this.callMacros.length; i = i + 1) {
            if (this.callMacros[i].name == identifier)
                return this.callMacros[i];
        }
        return null;
    }

    void addImport(CompileMacroState target) {
        this.imports = this.imports ~ target;
    }

    void addCallMacro(CallMacro macro_) {
        this.callMacros = this.callMacros ~ macro_;
    }
}

// hook the ASTCall (with ASTIdentifier) -> Call transform
class CallMacro
{
    string name;

    Expression transform(ASTSymbol[] symbols, Context context, Loc loc) { assert(false); }
}
