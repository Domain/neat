module struct_;

import backend.proxy;
import base;

class StructMemberDeclaration
{
    string name;

    Type type;

    this(string name, Type type)
    {
        this.name = name;
        this.type = type;
    }
}

class Struct : Type
{
    string name;

    StructMemberDeclaration[] members;

    this(string name, StructMemberDeclaration[] members)
    {
        this.name = name;
        this.members = members;
    }

    override bool same(Type other) {
        Struct otherStruct = other.instanceOf(Struct);
        if (!otherStruct || otherStruct.members.length != this.members.length) return false;
        for (int i = 0; i < this.members.length; i = i + 1)
        {
            if (!this.members[i].type.same(otherStruct.members[i].type)) return false;
        }
        return true;
    }

    override void* emit(Platform platform)
    {
        void*[] memberTypes = new void*[](this.members.length);
        for (int i = 0; i < this.members.length; i = i + 1)
        {
            memberTypes[i] = this.members[i].type.emit(platform);
        }
        return platform.structType(memberTypes);
    }

    override string repr() { return this.name; }
}

class StructMember : Reference
{
    Reference base;

    int index;

    this(Reference base, int index)
    {
        this.base = base;
        this.index = index;
    }

    override Type type()
    {
        Type type = this.base.type();
        Struct structType = type.instanceOf(Struct);
        assert(!!structType);
        return structType.members[this.index].type;
    }

    override int emit(Generator output)
    {
        int locationReg = this.emitLocation(output);

        return output.fun.load(this.type().emit(output.platform), locationReg);
    }

    override int emitLocation(Generator output)
    {
        int reg = this.base.emitLocation(output);

        return output.fun.fieldOffset(this.base.type().emit(output.platform), reg, this.index);
    }
}
