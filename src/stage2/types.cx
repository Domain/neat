module types;

import backend.proxy;
import base;
import format;
import parser;

class ASTCharacter : ASTType
{
    this() { }

    Type compile(Context context) {
        return new Character;
    }
}

class Character : Type
{
    this() { }

    void* emit(Platform platform)
    {
        return platform.charType();
    }

    bool same(Type other)
    {
        return !!other.instanceOf(Character);
    }

    string repr() { return "char"; }
}

class ASTInteger : ASTType
{
    this() { }

    Type compile(Context context) {
        return new Integer;
    }
}

class Integer : Type
{
    this() { }

    void* emit(Platform platform)
    {
        return platform.intType();
    }

    bool same(Type other) { return !!other.instanceOf(Integer); }

    string repr() { return "int"; }
}

class ASTLong : ASTType
{
    this() { }

    Type compile(Context context) {
        return new Long;
    }
}

class Long : Type
{
    this() { }

    void* emit(Platform platform)
    {
        return platform.longType();
    }

    bool same(Type other) { return !!other.instanceOf(Long); }

    string repr() { return "long"; }
}

class ASTVoid : ASTType
{
    this() { }

    Type compile(Context context) {
        return new Void;
    }
}

class Void : Type
{
    this() { }

    void* emit(Platform platform)
    {
        return platform.voidType();
    }

    bool same(Type other) { return !!other.instanceOf(Void); }

    string repr() { return "void"; }
}

class ASTPointer : ASTType
{
    ASTType subType;

    this(ASTType subType) { this.subType = subType; }

    Type compile(Context context)
    {
        Type subType = this.subType.compile(context);

        return new Pointer(subType);
    }
}

class Pointer : Type
{
    Type target;

    this(Type target) { this.target = target; }

    void* emit(Platform platform)
    {
        return platform.pointerType(this.target.emit(platform));
    }

    bool same(Type other)
    {
        Pointer otherPtr = other.instanceOf(Pointer);

        return otherPtr && this.target.same(otherPtr.target);
    }

    string repr() { return s2join(this.target.repr(), "*"); }
}

class NamedType : ASTType
{
    string name;

    this(string name) { assert(name.length > 0); this.name = name; }

    Type compile(Context context)
    {
        Symbol target = context.namespace.lookup(this.name);

        if (!target || !target.instanceOf(Type)) {
            print(s2join(this.name, " is not a type"));
            assert(false);
        }
        return target.instanceOf(Type);
    }
}

ASTType parseLeafType(Parser parser)
{
    parser.begin();

    string identifier = parseIdentifier(parser);

    if (!identifier.length)
    {
        parser.revert();
        return null;
    }

    if (identifier == "long")
    {
        parser.commit();
        return new ASTLong;
    }

    if (identifier == "int")
    {
        parser.commit();
        return new ASTInteger;
    }

    if (identifier == "char")
    {
        parser.commit();
        return new ASTCharacter;
    }

    if (identifier == "void")
    {
        parser.commit();
        return new ASTVoid;
    }

    parser.commit();
    return new NamedType(identifier);
}

// length, ptr
class Array : Type
{
    Type elementType;

    this(Type elementType) { this.elementType = elementType; }

    void* emit(Platform platform)
    {
        void*[] types = new void*[](2);
        types[0] = nativeWordType(platform).emit(platform);
        types[1] = platform.pointerType(this.elementType.emit(platform));
        return platform.structType(types); // TODO mod.wordType / mod.wordSize
    }

    bool same(Type other)
    {
        Array otherArray = other.instanceOf(Array);

        return otherArray && otherArray.elementType.same(this.elementType);
    }

    string repr() { return s2join(this.elementType.repr(), "[]"); }
}

class ASTArray : ASTType
{
    ASTType elementType;

    this(ASTType elementType) { this.elementType = elementType; }

    Type compile(Context context)
    {
        return new Array(this.elementType.compile(context));
    }
}

class ASTFunctionPointer : ASTType
{
    ASTType ret;

    ASTType[] args;

    this(ASTType ret, ASTType[] args) { this.ret = ret; this.args = args; }

    Type compile(Context context)
    {
        Type ret = this.ret.compile(context);
        Type[] args = new Type[](this.args.length);
        for (int i = 0; i < this.args.length; i = i + 1) args[i] = this.args[i].compile(context);

        return new FunctionPointer(ret, args);
    }
}

class FunctionPointer : Type
{
    Type ret;

    Type[] args;

    this(Type ret, Type[] args) { this.ret = ret; this.args = args; }

    void* emit(Platform platform)
    {
        void*[] args = new void*[](this.args.length);
        for (int i = 0; i < this.args.length; i = i + 1) args[i] = this.args[i].emit(platform);
        return platform.functionPointerType(this.ret.emit(platform), args);
    }

    bool same(Type other)
    {
        FunctionPointer otherPtr = other.instanceOf(FunctionPointer);
        if (!otherPtr) return false;
        if (!this.ret.same(otherPtr.ret)) return false;
        if (this.args.length != otherPtr.args.length) return false;
        for (int i = 0; i < this.args.length; i = i + 1)
            if (!this.args[i].same(otherPtr.args[i])) return false;
        return true;
    }

    string repr() { return s2join(this.ret.repr(), "(...)"); }
}

ASTType parseType(Parser parser)
{
    ASTType current = parseLeafType(parser);
    if (!current) return null;
    while (true)
    {
        if (parser.accept("*"))
        {
            current = new ASTPointer(current);
        }
        else
        {
            parser.begin();
            string identifier = parseIdentifier(parser);
            if (identifier == "function")
            {
                parser.expect("(");
                ASTType[] args;
                while (!parser.accept(")"))
                {
                    if (args.length)
                    {
                        if (!parser.accept(","))
                        {
                            parser.fail("',' or ')' expected");
                        }
                    }
                    ASTType argType = parseType(parser);
                    assert(!!argType);

                    args = args ~ argType;
                }
                parser.commit();
                current = new ASTFunctionPointer(current, args);
            } else {
                parser.revert();
                parser.begin();
                if (parser.accept("[") && parser.accept("]"))
                {
                    parser.commit();

                    current = new ASTArray(current);
                } else {
                    parser.revert();
                    return current;
                }
            }
        }
    }
}

Type nativeWordType(Platform platform)
{
    int size = platform.nativeWordSize();
    if (size == 4) return new Integer;
    if (size == 8) return new Long;
    assert(false);
}
