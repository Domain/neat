module std.string;

macro import neat.macros.assert;
macro import neat.macros.listcomprehension;

public import neat.runtime : itoa, ftoa, ltoa, atoi, atof;

// TODO import or private
extern(C) void* malloc(size_t size);
extern(C) void* memcpy(void* target, void* source, size_t length);
extern(C) size_t strlen(char*);
extern(C) int neat_runtime_atoi(string);
extern(C) float neat_runtime_atof(string);

char* toStringz(string s) {
    char* ret = malloc(s.length + 1);
    memcpy(ret, s.ptr, s.length);
    ret[s.length] = "\0"[0];
    return ret;
}

string cToString(char* ptr) {
    if (!ptr) return "";
    auto len = strlen(ptr);
    auto ret = new char[](len);
    memcpy(ret.ptr, ptr, len);
    return ret;
}

string cToStringFree(char* ptr) {
    string ret = cToString(ptr);
    free(ptr);
    return ret;
}

bool startsWith(string haystack, string needle) {
    if (haystack.length < needle.length) return false;
    return haystack[0 .. needle.length] == needle;
}

unittest {
    assert("Hello World".startsWith("Hello"));
    assert(!"Hello World".startsWith("World"));
}

bool endsWith(string haystack, string needle) {
    if (haystack.length < needle.length) return false;
    return haystack[$ - needle.length .. $] == needle;
}

unittest {
    assert("Hello World".endsWith("World"));
    assert(!"Hello World".endsWith("Hello"));
}

unittest {
    assert(itoa(5) == "5");
    assert(itoa(-3) == "-3");
}

unittest {
    assert(atoi("5") == 5);
    assert(atoi("-3") == -3);
}

///
int find(string text, string match) {
    if (text.length < match.length) {
        return -1;
    }
    for (i in 0 .. text.length - match.length + 1) {
        if (text[i .. i + match.length] == match) return cast(int) i;
    }
    return -1;
}

unittest {
    assert("Hello World".find("o") == 4);
    assert("Hello World".find("p") == -1);
}

string[] split(mut string text, string sep) {
    if (text.length == 0) return [];
    mut string[] result;
    while (true) {
        int pos = find(text, sep);
        if (pos == -1) {
            result ~= text;
            return result;
        }
        result ~= text[0 .. pos];
        text = text[pos + sep.length .. $];
    }
}

unittest {
    assert("Hello World".split(" ") == ["Hello", "World"]);
    assert("Hello".split(" ") == ["Hello"]);
    assert("".split(" ").length == 0);
}

(string fragment, string rest) slice(string text, string sep) {
    int pos = find(text, sep);
    if (pos == -1)
        return (text, "");
    return (text[0 .. pos], text[pos + sep.length .. $]);
}

string toHexString(ubyte[] data) {
    auto hexLetters = "0123456789abcdef";
    string hex(ubyte ub) {
        return [hexLetters[cast(int) ub >> 4], hexLetters[cast(int) ub & 0xf]];
    }
    return [join hex(ub) for ub in data];
}

string join(string[] array, string sep) {
    mut string result;
    for (i in 0 .. array.length) {
        if (i > 0) result ~= sep;
        result ~= array[i];
    }
    return result;
}

string strip(mut string text) {
    bool isWhitespace(char ch) {
        return ch == " "[0] || ch == "\r"[0] || ch == "\n"[0];
    }
    while (!text.empty && text[0].isWhitespace) text = text[1 .. $];
    while (!text.empty && text[$ - 1].isWhitespace) text = text[0 .. $ - 1];
    return text;
}

string replace(string str, string match, string replace) {
    mut string result;
    mut size_t i = 0;
    while (i <= str.length - match.length) {
        if (str[i .. i + match.length] == match) {
            result ~= replace;
            i += match.length;
        } else {
            result ~= str[i];
            i += 1;
        }
    }
    result ~= str[i .. $];
    return result;
}
