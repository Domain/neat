module std.algorithm;

macro import std.macro.assert;
macro import std.macro.listcomprehension;

/**
 * Maps a range onto a lambda.
 *
 * If the input range is `[x, y, z]`,
 * the output range is `[lambda(x), lambda(y), lambda(z)]`.
 */
template map(T, U) {
    MapRange!(T, U) map(T left, U right) {
        return MapRange!(T, U)(left, right);
    }
}

unittest
{
    auto a = (0 .. 5).map(a => a * 2);

    assert(a.length == 5);
    assert(a.array == [0, 2, 4, 6, 8]);
}

private template MapRange(T, U) {
    struct MapRange {
        T nextRange;
        U pred;
        bool empty() { return nextRange.empty; }
        typeof(pred(nextRange.front)) front() { return pred(nextRange.front); }
        MapRange next() { return MapRange(nextRange.next, pred); }
        static if (__traits(hasMember, init!T, "length")) {
            size_t length() { return nextRange.length; }
        }
    }
}

/**
 * Converts a range into an array.
 */
template array(T) {
    typeof(range.front)[] array(T range) {
        mut typeof(range.front)[] ret;
        for (a in range) ret ~= a;
        return ret;
    }
}

unittest
{
    assert((0 .. 5).array == [0, 1, 2, 3, 4]);
}

/**
 * Filters a range by a condition.
 */
template filter(T, U) {
    FilterRange!(T, U) filter(T left, U right) {
        return FilterRange!(T, U)(left, right);
    }
}

unittest
{
    auto a = (0 .. 10).filter(a => a > 4).array;

    assert(a == [5, 6, 7, 8, 9]);
}

private template FilterRange(T, U) {
    struct FilterRange {
        T nextRange;
        U pred;
        bool empty() {
            skip;
            return nextRange.empty;
        }
        void skip() {
            while (!nextRange.empty && !pred(nextRange.front)) {
                nextRange = nextRange.next;
            }
        }
        typeof(nextRange.front) front() { return nextRange.front; }
        FilterRange next() { return FilterRange(nextRange.next, pred); }
    }
}

/**
 * Returns true if any value in the range fulfills the condition.
 */
template any(T, U) {
    bool any(T left, U right) {
        for (a in left) if (right(a)) return true;
        return false;
    }
}

unittest
{
    assert((0 .. 5).any(a => a == 3));
}

/**
 * Returns true if all values in the range fulfill the condition.
 */
template all(T, U) {
    bool all(T left, U right) {
        for (a in left) if (!right(a)) return false;
        return true;
    }
}

unittest
{
    assert((0 .. 5).all(a => a < 5));
}

private template init(T) {
    T init() {
        mut uninitialized T t;
        return t;
    }
}

template sort(T, U) {
    T sort(T array, U smaller) {
        // quick (but horribly memory inefficient) sort
        if (array.length <= 1) return array;
        auto partition = array[$ / 2];
        auto left = [a for a in array where smaller(a, partition)];
        auto mid = [a for a in array where !smaller(a, partition) && !smaller(partition, a)];
        auto right = [a for a in array where smaller(partition, a)];
        return left.sort(smaller) ~ mid ~ right.sort(smaller);
    }
}
