module std.thread;

import c.pthread;
import neat.runtime : assert;
import std.stdio;

pragma(lib, "pthread");

class Mutex
{
    pthread_mutex_t mutex;
    bool isLocked;

    this() {
        pthread_mutexattr_t attrs;
        pthread_mutexattr_init(&attrs);
        pthread_mutexattr_settype(&attrs, PTHREAD_MUTEX_ERRORCHECK);
        pthread_mutex_init(&mutex, &attrs);
        isLocked = false;
    }
    void lock() {
        int ret = pthread_mutex_lock(&mutex);
        if (ret) {
            import c.stdlib : exit;
            print("pthread_mutex_lock $ret");
            exit(1);
        }
        assert(!isLocked);
        isLocked = true;
    }
    LockGuard locked() {
        return LockGuard(this);
    }
    UnlockGuard unlocked() {
        return UnlockGuard(this);
    }
    void unlock() {
        assert(isLocked);
        isLocked = false;
        int ret = pthread_mutex_unlock(&mutex);
        if (ret) {
            import c.stdlib : exit;
            print("pthread_mutex_unlock $ret");
            exit(1);
        }
    }
}

struct LockGuard
{
    Mutex mutex;
    void onEnter() {
        mutex.lock;
    }
    void onExit() {
        mutex.unlock;
    }
}

struct UnlockGuard
{
    Mutex mutex;
    void onEnter() {
        mutex.unlock;
    }
    void onExit() {
        mutex.lock;
    }
}

unittest
{
    auto mutex = new Mutex;

    assert(!mutex.isLocked);
    with (mutex.locked) {
        assert(mutex.isLocked);
    }
    assert(!mutex.isLocked);
}

unittest
{
    auto mutex = new Mutex;

    void returnTest() {
        with (mutex.locked) {
            return;
        }
    }
    returnTest;
    assert(!mutex.isLocked);
}

class CondVar
{
    pthread_cond_t cond;

    Mutex mutex;

    this(this.mutex) { pthread_cond_init(&cond, null); }
    void wait() {
        assert(mutex.isLocked);
        mutex.isLocked = false;
        int ret = pthread_cond_wait(&cond, &this.mutex.mutex);
        if (ret) {
            import c.stdlib : exit;
            print("pthread_cond_wait $ret");
            exit(1);
        }
        assert(!mutex.isLocked);
        mutex.isLocked = true;
    }
    void signal() {
        int ret = pthread_cond_signal(&cond);
        if (ret) {
            import c.stdlib : exit;
            print("pthread_cond_signal $ret");
            exit(1);
        }
    }
    void broadcast() {
        int ret = pthread_cond_broadcast(&cond);
        if (ret) {
            import c.stdlib : exit;
            print("pthread_cond_broadcast $ret");
            exit(1);
        }
    }
}

template Waitable(T)
{
    class Waitable
    {
        Mutex mutex;
        CondVar signal;
        T value;
        this(this.value) {
            this.mutex = new Mutex;
            this.signal = new CondVar(this.mutex);
        }
        void set(T value) {
            with (mutex.locked) {
                this.value = value;
                signal.broadcast;
            }
        }
        void update(T delegate(T) action) {
            with (mutex.locked) {
                this.value = action(this.value);
                signal.broadcast;
            }
        }
        void waitFor(bool delegate(T) condition) {
            T id(T value) { return value; }
            waitReact(condition, &id);
        }
        void waitReact(bool delegate(T) condition, T delegate(T) react) {
            with (mutex.locked) while (true) {
                if (condition(this.value)) {
                    this.value = react(this.value);
                    signal.broadcast;
                    return;
                }
                signal.wait;
            }
        }
    }
}

class Semaphore
{
    Waitable!int waitable;

    this(int i) { this.waitable = new Waitable!int(i); }

    void acquire() {
        bool greaterZero(int i) { return i > 0; }
        int decrement(int i) { return i - 1; }
        waitable.waitReact(&greaterZero, &decrement);
    }
    void release() {
        int increment(int i) { return i + 1; }
        waitable.update(&increment);
    }
}

abstract class Task
{
    abstract void run();
}

class Thread
{
    pthread_t thr;
    ThreadPool pool;
    void delegate() runDg;

    this(this.pool) { runDg = &run; }
    void start() {
        pthread_create(&thr, null, &call_thread_dg, &runDg);
    }
    void run() {
        while (true) {
            pool.getTask.run;
            pool.doneTasks.release;
        }
    }
}

class ThreadPool
{
    Mutex mutex;
    Task[] tasks;
    Thread[] threads;
    int queuedTasks;
    Semaphore waitingTasks;
    Semaphore doneTasks;

    this(int i) {
        this.mutex = new Mutex;
        this.waitingTasks = new Semaphore(0);
        this.doneTasks = new Semaphore(0);
        for (j in 0 .. i) {
            auto thread = new Thread(this);
            thread.start;
            threads ~= thread;
        }
    }
    void waitComplete(void delegate(float) progress) {
        mut int tasks;
        with (this.mutex.locked) {
            tasks = this.queuedTasks;
            this.queuedTasks = 0;
        }
        for (i in 0 .. tasks) {
            this.doneTasks.acquire;
            progress((cast(int) i + 1) * 1.0f / tasks);
        }
    }
    void addTask(Task task) {
        with (mutex.locked) {
            tasks ~= task;
            this.queuedTasks += 1;
        }
        this.waitingTasks.release;
    }
    Task getTask()  {
        this.waitingTasks.acquire;
        with (mutex.locked) {
            auto ret = tasks[$ - 1];
            tasks = tasks[0 .. $ - 1];
            return ret;
        }
    }
}

// TODO: null to function ptr
void nothing(void*) { }

template ThreadLocal(T) {
    class ThreadLocal {
        pthread_key_t key;
        this() {
            pthread_key_create(&key, &nothing);
        }
        void set(mut T value) {
            import neat.runtime.stdlib : malloc, memcpy, memset;

            mut auto memory = pthread_getspecific(key);
            if (!memory) {
                memory = malloc(sizeof(T));
                pthread_setspecific(key, memory);
            }
            // TODO: __leak()?
            memcpy(memory, &value, sizeof(T));
            // destroy the value without releasing it: cause a leak.
            memset(&value, 0, sizeof(T));
        }
        T get() {
            import neat.runtime.stdlib : memcpy, memset;

            auto memory = pthread_getspecific(key);
            if (!memory) {
                T t;
                return t;
            }
            mut uninitialized T copy;
            memcpy(&copy, memory, sizeof(T));
            mut auto result = copy;
            memset(&copy, 0, sizeof(T));
            return result;
        }
    }
}
