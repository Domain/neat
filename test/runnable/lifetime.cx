module lifetime;

macro import cx.macros.assert;
macro import cx.macros.listcomprehension;

extern(C) void print(string);
extern(C) string cxruntime_itoa(int);

string itoa(int i) { return cxruntime_itoa(i); }

void dbg(string text)
{
    print(text);
}

struct S
{
    string name;
    string* trace;
    this(S s)
    {
        name = s.name;
        trace = s.trace;
        if (trace.length) *trace ~= " ";
        *trace ~= "+" ~ name;
    }
    ~this()
    {
        // ~this may be called on a S.init
        if (!trace) return;
        if (trace.length) *trace ~= " ";
        *trace ~= "-" ~ name;
    }
}

struct S2
{
    string name;
    string* trace;
    int* balance;
    this(S2 s2)
    {
        name = s2.name;
        trace = s2.trace;
        balance = s2.balance;
        if (trace.length) *trace ~= " ";
        *trace ~= "+" ~ name;
        *balance += 1;
    }
    ~this()
    {
        // ~this may be called on a S2.init
        if (!trace) return;
        if (trace.length) *trace ~= " ";
        *trace ~= "-" ~ name;
        *balance -= 1;
    }
}

void test_scope()
{
    dbg("- scope");
    string trace;
    { S s = S("S", &trace); }
    assert(trace == "-S");
}

void test_if()
{
    dbg("- if");
    string trace;
    if (true) S s = S("S", &trace);
    assert(trace == "-S");
}

void test_while()
{
    dbg("- while");
    string trace;
    mut bool called;
    bool once() { if (!called) { called = true; return true; } return false; }
    while (once) S s = S("S", &trace);
    assert(trace == "-S");
}

void test_nested()
{
    dbg("- nested");
    string trace;
    void nest() S s = S("S", &trace);
    nest;
    assert(trace == "-S");
}

void test_discard()
{
    dbg("- discard");
    string trace;
    S("S", &trace);
    assert(trace == "-S");
}

void test_discard_variable()
{
    dbg("- discard var");
    string trace;
    {
        S s = S("S", &trace);
        s; // this does nothing, because it's a non-temporary expression
    }
    assert(trace == "-S");
}

void test_discard_return1()
{
    dbg("- discard return 1");
    string trace;
    mut int calls;
    S test() { calls += 1; return S("S", &trace); }
    {
        test;
    }
    assert(trace == "-S");
}

void test_discard_return2()
{
    dbg("- discard return 2");
    string trace;
    mut int calls;
    S test() { calls += 1; S s = S("S", &trace); return s; }
    {
        S s = test;
    }
    assert(trace == "+S -S -S");
}

void test_call1()
{
    dbg("- call 1");
    string trace;
    {
        auto s = S("S", &trace);
        void foo(S s) { }
        foo(s);
    }
    // the function call does not create a copy
    // because s exists in the surrounding lifetime.
    assert(trace == "-S");
}

void test_call2()
{
    dbg("- call 2");
    string trace;
    {
        void foo(S s) { }
        foo(S("S", &trace));
    }
    // the function call still does not create a copy
    // S is cleaned up after the call,
    assert(trace == "-S");
}

void test_array()
{
    dbg("- array");
    {
        string trace;
        {
            S[] array = [S("S", &trace)];
            // temporary initializing a literal
            assert(trace == "");
        }
        assert(trace == "-S");
    }
    {
        string trace;
        {
            mut auto c = new C(S("S", &trace));
            C[] array = [c];
            assert(trace == "+S -S");
            c = null;
            assert(trace == "+S -S");
        }
        assert(trace == "+S -S -S");
    }
}

struct T
{
    S s;
}

struct Pair
{
    S s1;
    S s2;
}

void test_struct_field()
{
    dbg("- struct field");
    {
        string trace;
        {
            T t = T(S("S", &trace));
            assert(trace == "+S -S");
        }
        assert(trace == "+S -S -S");
    }
    string trace;
    {
        S s = Pair(S("S1", &trace), S("S2", &trace)).s1;
        assert(trace == "+S1 +S2 -S2 -S1 +S1 -S1 -S2");
    }
    assert(trace == "+S1 +S2 -S2 -S1 +S1 -S1 -S2 -S1");
}

void test_reassignment()
{
    dbg("- reassignment");
    {
        string trace;
        {
            mut S s = S("S1", &trace);
            s = S("S2", &trace);
            assert(trace == "-S1");
        }
        assert(trace == "-S1 -S2");
    }
    {
        string trace;
        {
            mut T t = T(S("S", &trace));
            assert(trace == "+S -S");
            t = t;
            assert(trace == "+S -S +S -S");
        }
    }
}

void test_parameter_reassignment()
{
    dbg("- parameter reassignment");
    {
        // TODO
        /*string trace;
        void test(S s) {
            s = S("S2", &trace);
        }
        test(S("S1", &trace));
        assert(trace == "-S1 -S2");*/
    }
}

class Object { }

class C : Object
{
    S value;

    this(this.value) { assert((cast(size_t*) this)[1] == 1); }
}

class D
{
    C c;
    this(C c) { this.c = c; }
}

void test_class_field()
{
    dbg("- class field");
    {
        string trace;
        {
            Object obj = new C(S("S", &trace));
            assert((cast(size_t*) obj)[1] == 1);
            assert(trace == "+S -S");
        }
        assert(trace == "+S -S -S");
    }
    {
        string trace;
        {
            mut C c = new C(S("S", &trace));
            assert((cast(size_t*) c)[1] == 1);
            assert(trace == "+S -S");
            Object obj = c.instanceOf(Object);
            // must take a reference cause obj is a root
            assert((cast(size_t*) obj)[1] == 2);
            c = null;
            assert((cast(size_t*) obj)[1] == 1);
        }
        assert(trace == "+S -S -S");
    }
    {
        string trace;
        {
            void recurse(C arg)
            {
                Object obj = arg.instanceOf(Object);
            }
            C c = new C(S("S", &trace));
            recurse(c);
        }
        assert(trace == "+S -S -S");
    }
    {
        string trace;
        mut Object obj = (new C(S("S", &trace))).instanceOf(Object);
        assert((cast(size_t*) obj)[1] == 1);
        assert(trace == "+S -S");
        obj = null;
        assert(trace == "+S -S -S");
    }
    {
        string trace;
        D nest() {
            auto c = new C(S("S", &trace));
            assert((cast(size_t*) c)[1] == 1);

            return new D(c);
        }
        mut D d = nest;
        assert(trace == "+S -S");
        assert((cast(size_t*) d.c)[1] == 1);
        d = null;
        assert(trace == "+S -S -S");
    }
    {
        string trace;
        mut D d = new D(new C(S("S", &trace)));
        mut C c = d.instanceOf(D).c;
        assert(trace == "+S -S");
        assert((cast(size_t*) d.c)[1] == 2);
        c = null;
        assert(trace == "+S -S");
        d = null;
        assert(trace == "+S -S -S");
    }
}

void test_either_member()
{
    dbg("- either member");
    string trace;
    {
        (S | int) either = S("S", &trace);
        auto either2 = either;
        // variable doesn't create a new ref cause either is already owned
        assert(trace == "");
    }
    assert(trace == "-S");
}

void test_array_cat()
{
    dbg("- array cat");
    {
        string trace;
        {
            S[] array = [S("S1", &trace)] ~ [S("S2", &trace)];
            assert(trace == "+S1 +S2 -S2 -S1");
        }
        assert(trace == "+S1 +S2 -S2 -S1 -S1 -S2");
    }
    {
        string trace;
        {
            mut S[] array;
            array ~= S("S1", &trace);
            assert(trace == "+S1 -S1");
            array ~= S("S2", &trace);
            assert(trace == "+S1 -S1 +S1 +S2 -S2 -S1");
        }
        assert(trace == "+S1 -S1 +S1 +S2 -S2 -S1 -S1 -S2");
    }
    {
        string trace;
        {
            mut C[] array;
            array ~= new C(S("S1", &trace));
            assert(trace == "+S1 -S1");
            array ~= new C(S("S2", &trace));
            assert(trace == "+S1 -S1 +S2 -S2");
        }
        assert(trace == "+S1 -S1 +S2 -S2 -S1 -S2");
    }
    {
        string trace;
        int balance = 1;
        {
            auto sArray = [[S2("S", &trace, &balance)]];

            S2[] foo(S2[][] array) {
                mut S2[] ret;
                ret ~= array[0];
                return ret;
            }

            mut S2[] array;
            for (int i <- 0 .. 10)
                array ~= foo(sArray[0 .. $]);
        }
        assert(balance == 0);
    }
}

void test_statement_expr() {
    dbg("- statement expr");
    string trace;
    {
        S s = ({ auto s = S("S", &trace); s; });
        assert(trace == "+S -S");
    }
    assert(trace == "+S -S -S");
}

void test_break_cont() {
    dbg("- break/continue");
    {
        string trace;
        while (true) {
            S s = S("S", &trace);
            break;
        }
        assert(trace == "-S");
    }
    {
        string trace;
        mut bool done;
        while (!done) {
            S s = S("S", &trace);
            done = true;
            continue;
        }
        assert(trace == "-S");
    }
}

void test_array_equals() {
    dbg("- array equals");
    {
        string trace;
        if ([S("S1", &trace)] == [S("S2", &trace)]) { }
        assert(trace == "-S2 -S1");
    }
}

void test_struct_member() {
    dbg("- struct member");
    string trace;
    T t() { return T(S("S", &trace)); }
    auto s = t().s;
    assert(trace == "+S -S +S -S");
}

void test_negation() {
    dbg("- negation");
    string trace;
    assert(!!new C(S("S", &trace)));
    assert(trace == "+S -S -S");
}

void test_with() {
    dbg("- with");
    {
        string trace_;
        with (S("S", &trace_))
        {
            assert(trace_ == "");
        }
        assert(trace_ == "-S");
    }
    {
        string trace_;
        {
            S s = S("S", &trace_);
            with (s)
            {
                assert(trace_ == "");
            }
        }
        assert(trace_ == "-S");
    }
    {
        string trace_;
        void test()
        {
            with (S("S", &trace_))
            {
                return;
            }
        }
        test;
        assert(trace_ == "-S");
    }
    {
        string trace_;
        {
            S s = S("S", &trace_);
            void test2(S s)
            {
                with (s)
                {
                    return;
                }
            }
            test2(s);
            assert(trace_ == "+S -S");
        }
        assert(trace_ == "+S -S -S");
    }
}

void main()
{
    test_scope;
    test_if;
    test_while;
    test_nested;
    test_discard;
    test_discard_variable;
    test_discard_return1;
    test_discard_return2;
    test_call1;
    test_call2;
    test_array;
    test_struct_field;
    test_reassignment;
    // TODO test_parameter_reassignment;
    test_class_field;
    test_either_member;
    test_array_cat;
    test_statement_expr;
    test_break_cont;
    test_array_equals;
    test_struct_member;
    test_negation;
    test_with;
}
