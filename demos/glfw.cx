module glfw;

macro import cx.macros.assert;
macro import cx.macros.cimport;

import c_header("GL/gl.h");
import c_header("GL/glext.h", "-include GL/gl.h -DGL_GLEXT_PROTOTYPES");
import c_header("GLFW/glfw3.h");
import c_header("SOIL.h");
import std.math;
import std.string : toStringz;

alias vec2f = Vector(float, 2);
alias vec3f = Vector(float, 3);
alias vec4f = Vector(float, 4);

struct Vertex {
    vec2f pos;
    vec2f texCoord;
}

Vertex[] vertices() {
    return [
        Vertex(vec2f(-0.6, -0.4), vec2f(1, 0)),
        Vertex(vec2f( 0.6, -0.4), vec2f(0, 0)),
        Vertex(vec2f( 0,    0.6), vec2f(0, 1))];
}

string vertexShader() {
    return "#version 110
uniform mat4 MVP;
attribute vec2 vPos;
attribute vec2 vTexPos;
varying vec2 texCoord;
void main()
{
    gl_Position = MVP * vec4(vPos, 0.0, 1.0);
    texCoord = vTexPos;
};";
}

string fragmentShader() {
    return "#version 110
varying vec2 texCoord;
uniform sampler2D tex;
void main()
{
    gl_FragColor = texture2D(tex, texCoord);
}";
}

/*
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}
*/

// this is all super unoptimized
struct mat4x4 {
    vec4f row1, row2, row3, row4;
    mat4x4 rotateZ(float by) {
        return mul(mat4x4_rotationZ(by));
    }
    mat4x4 mul(mat4x4 other) {
        float rowmul(int row, int col) {
            auto mul = this.row(row) * other.row(col);
            return mul.x + mul.y + mul.z + mul.w;
        }
        return mat4x4(
            vec4f(rowmul(0, 0), rowmul(0, 1), rowmul(0, 2), rowmul(0, 3)),
            vec4f(rowmul(1, 0), rowmul(1, 1), rowmul(1, 2), rowmul(1, 3)),
            vec4f(rowmul(2, 0), rowmul(2, 1), rowmul(2, 2), rowmul(2, 3)),
            vec4f(rowmul(3, 0), rowmul(3, 1), rowmul(3, 2), rowmul(3, 3)));

    }
    vec4f row(int r) {
        if (r == 0) return row1;
        if (r == 1) return row2;
        if (r == 2) return row3;
        if (r == 3) return row4;
        assert(false);
    }
    mat4x4 transpose() {
        return mat4x4(
            vec4f(row1.x, row2.x, row3.x, row4.x),
            vec4f(row1.y, row2.y, row3.y, row4.y),
            vec4f(row1.z, row2.z, row3.z, row4.z),
            vec4f(row1.w, row2.w, row3.w, row4.w));
    }
}

// TODO static methods
mat4x4 mat4x4_identity() {
    return mat4x4(
        vec4f(1, 0, 0, 0),
        vec4f(0, 1, 0, 0),
        vec4f(0, 0, 1, 0),
        vec4f(0, 0, 0, 1));
}

mat4x4 mat4x4_rotationZ(float angle) {
    float cos = cos(angle), sin = sin(angle);
    return mat4x4(
        vec4f(cos, -sin, 0, 0),
        vec4f(sin,  cos, 0, 0),
        vec4f(  0,    0, 1, 0),
        vec4f(  0,    0, 0, 1));
}

mat4x4 mat4x4_ortho(float left, float right, float bottom, float top, float near, float far) {
    float dx = right - left, dy = top - bottom, dz = far - near;
    float tx = -(right + left) / (right - left);
    float ty = -(top + bottom) / (top - bottom);
    float tz = -(far + near) / (far - near);
    return mat4x4(
        vec4f(2/dx,    0,    0, tx),
        vec4f(   0, 2/dy,    0, ty),
        vec4f(   0,    0, 2/dz, tz),
        vec4f(   0,    0,    0,  1));
}

void main() {
    if (!glfwInit) return;

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

    auto window = glfwCreateWindow(640, 480, "Simple example".toStringz, null, null);
    if (!window) {
        glfwTerminate;
        return;
    }

    // glfwSetKeyCallback(window, key_callback);

    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);

    GLuint vertex_buffer;
    glGenBuffers(1, &vertex_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
    auto vertices = vertices;
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices[0]) * vertices.length, cast(void*) vertices.ptr, GL_STATIC_DRAW);

    auto vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    char* vertexShaderPtr = vertexShader.toStringz;
    glShaderSource(vertex_shader, 1, &vertexShaderPtr, null);
    glCompileShader(vertex_shader);

    auto fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    char* fragmentShaderPtr = fragmentShader.toStringz;
    glShaderSource(fragment_shader, 1, &fragmentShaderPtr, null);
    glCompileShader(fragment_shader);
    int isCompiled;
    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &isCompiled);
    if (!isCompiled) {
        int maxLength = 0;
        glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &maxLength);

        auto errorLog = new string(maxLength);
        glGetShaderInfoLog(fragment_shader, maxLength, &maxLength, errorLog.ptr);

        print(errorLog);
        return;
    }

    auto program = glCreateProgram;
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);

    auto mvp_location = glGetUniformLocation(program, "MVP".toStringz);
    auto vpos_location = glGetAttribLocation(program, "vPos".toStringz);
    auto vtexpos_location = glGetAttribLocation(program, "vTexPos".toStringz);

    auto tex = SOIL_load_OGL_texture("some_grass_or_we.png".toStringz,
        SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID,
        SOIL_FLAG_MIPMAPS | SOIL_FLAG_INVERT_Y | SOIL_FLAG_NTSC_SAFE_RGB | SOIL_FLAG_COMPRESS_TO_DXT);
    assert(tex != 0);

    glEnableVertexAttribArray(vpos_location);
    glVertexAttribPointer(vpos_location, 2, GL_FLOAT, false,
                          sizeof(Vertex), null);
    glEnableVertexAttribArray(vtexpos_location);
    // TODO offsetof?
    glVertexAttribPointer(vtexpos_location, 2, GL_FLOAT, false,
                          sizeof(Vertex), cast(void*) (sizeof(float) * 2));

    while (!glfwWindowShouldClose(window)) {
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);
        auto ratio = width * 1.0 / height;

        glViewport(0, 0, width, height);
        glClear(GL_COLOR_BUFFER_BIT);

        auto m = mat4x4_identity.rotateZ(cast(float) glfwGetTime);
        auto p = mat4x4_ortho(-ratio, ratio, -1, 1, 1, -1);
        auto mvp = p.mul(m);

        glUseProgram(program);
        glUniformMatrix4fv(mvp_location, 1, false, cast(GLfloat*) &mvp);

        glBindTexture(GL_TEXTURE_2D, tex);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        glfwSwapBuffers(window);
        glfwPollEvents;
    }

    glfwDestroyWindow(window);

    glfwTerminate;
}
